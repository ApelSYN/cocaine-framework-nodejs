# 1 "../src/worker.cpp"
# 1 "/home/diunko/tmp/no-cocaine.0/build//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "../src/worker.cpp"

# 1 "../src/worker.hpp" 1




# 1 "/usr/include/cocaine/common.hpp" 1 3 4
# 24 "/usr/include/cocaine/common.hpp" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 313 "/usr/include/features.h" 3 4
# 1 "/usr/include/bits/predefs.h" 1 3 4
# 314 "/usr/include/features.h" 2 3 4
# 346 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 353 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 354 "/usr/include/sys/cdefs.h" 2 3 4
# 347 "/usr/include/features.h" 2 3 4
# 378 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 379 "/usr/include/features.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 37 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;







typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 66 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 91 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 104 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 120 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 135 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 25 "/usr/include/cocaine/common.hpp" 2 3 4

# 1 "/usr/include/c++/4.4/map" 1 3 4
# 58 "/usr/include/c++/4.4/map" 3 4
       
# 59 "/usr/include/c++/4.4/map" 3

# 1 "/usr/include/c++/4.4/bits/stl_tree.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_tree.h" 3
# 1 "/usr/include/c++/4.4/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 1 3
# 243 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/os_defines.h" 1 3
# 244 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/cpu_defines.h" 1 3
# 247 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 2 3
# 61 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 45 "/usr/include/c++/4.4/cstddef" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::ptrdiff_t;
  using ::size_t;

}
# 62 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/functexcept.h" 1 3
# 37 "/usr/include/c++/4.4/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.4/exception_defines.h" 1 3
# 38 "/usr/include/c++/4.4/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

}
# 63 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 1 3
# 36 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
       
# 37 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
# 69 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


}
# 64 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.4/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/4.4/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };

}
# 65 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/4.4/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 52 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 97 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 3010 / 10000);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };

}
# 66 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_pair.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.4/bits/move.h" 1 3
# 34 "/usr/include/c++/4.4/bits/move.h" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 35 "/usr/include/c++/4.4/bits/move.h" 2 3
# 1 "/usr/include/c++/4.4/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.4/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/4.4/bits/concept_check.h" 3
# 36 "/usr/include/c++/4.4/bits/move.h" 2 3


# 1 "/usr/include/c++/4.4/type_traits" 1 3
# 32 "/usr/include/c++/4.4/type_traits" 3
       
# 33 "/usr/include/c++/4.4/type_traits" 3
# 42 "/usr/include/c++/4.4/type_traits" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 43 "/usr/include/c++/4.4/type_traits" 2 3
# 51 "/usr/include/c++/4.4/type_traits" 3
# 1 "/usr/include/c++/4.4/tr1_impl/type_traits" 1 3
# 30 "/usr/include/c++/4.4/tr1_impl/type_traits" 3
namespace std
{

# 43 "/usr/include/c++/4.4/tr1_impl/type_traits" 3
  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };
# 66 "/usr/include/c++/4.4/tr1_impl/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static const _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
    };


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<typename _Tp, _Tp __v>
    const _Tp integral_constant<_Tp, __v>::value;


  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };
  template<> struct __is_void_helper<void> : public integral_constant<bool, true> { };




  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };
  template<> struct __is_integral_helper<bool> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<signed char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned char> : public integral_constant<bool, true> { };

  template<> struct __is_integral_helper<wchar_t> : public integral_constant<bool, true> { };


  template<> struct __is_integral_helper<char16_t> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char32_t> : public integral_constant<bool, true> { };

  template<> struct __is_integral_helper<short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long long> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };
  template<> struct __is_floating_point_helper<float> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<double> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<long double> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };
  template<typename _Tp> struct __is_pointer_helper<_Tp*> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_reference;


  template<typename _Tp>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, !is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };




  template<typename _Tp>
    struct is_arithmetic
    : public integral_constant<bool, (is_integral<_Tp>::value
          || is_floating_point<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_fundamental
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_object
    : public integral_constant<bool, !(is_function<_Tp>::value
           || is_reference<_Tp>::value
           || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_enum<_Tp>::value
          || is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };


  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, true> { };

  template<typename _Tp>
  struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };



  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };


  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };




  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };




  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };




  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };

  template<typename>
    struct remove_reference;


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };








}
# 52 "/usr/include/c++/4.4/type_traits" 2 3






namespace std
{







  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };




  template<typename _Tp>
    struct is_reference
    : public integral_constant<bool, (is_lvalue_reference<_Tp>::value
          || is_rvalue_reference<_Tp>::value)>
    { };




  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp,
    bool = !is_reference<_Tp>::value && !is_void<_Tp>::value,
    bool = is_rvalue_reference<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true, false>
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, false, true>
    { typedef typename remove_reference<_Tp>::type& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp,
    bool = !is_reference<_Tp>::value && !is_void<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp,
    bool = is_integral<_Tp>::value,
    bool = is_floating_point<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, false, true>
    : public true_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true, false>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, __is_signed_helper<_Tp>::value>
    { };


  template<typename _Tp>
    struct is_unsigned
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          && !is_signed<_Tp>::value)>
    { };




  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_destructor
    : public integral_constant<bool, __has_trivial_destructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_nothrow_default_constructor
    : public integral_constant<bool, __has_nothrow_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_nothrow_copy_constructor
    : public integral_constant<bool, __has_nothrow_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_nothrow_assign
    : public integral_constant<bool, __has_nothrow_assign(_Tp)>
    { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };


  template<typename _From, typename _To>
    struct __is_convertible_simple
    : public __sfinae_types
    {
    private:
      static __one __test(_To);
      static __two __test(...);
      static _From __makeFrom();

    public:
      static const bool __value = sizeof(__test(__makeFrom())) == 1;
    };

  template<typename _Tp>
    struct __is_int_or_cref
    {
      typedef typename remove_reference<_Tp>::type __rr_Tp;
      static const bool __value = (is_integral<_Tp>::value
       || (is_integral<__rr_Tp>::value
           && is_const<__rr_Tp>::value
           && !is_volatile<__rr_Tp>::value));
    };

  template<typename _From, typename _To,
    bool = (is_void<_From>::value || is_void<_To>::value
     || is_function<_To>::value || is_array<_To>::value

     || (is_floating_point<typename
         remove_reference<_From>::type>::value
         && __is_int_or_cref<_To>::__value))>
    struct __is_convertible_helper
    {

      static const bool __value = (__is_convertible_simple<typename
       add_lvalue_reference<_From>::type,
       _To>::__value);
    };

  template<typename _From, typename _To>
    struct __is_convertible_helper<_From, _To, true>
    { static const bool __value = (is_void<_To>::value
       || (__is_int_or_cref<_To>::__value
           && !is_void<_From>::value)); };




  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::__value>
    { };

  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 303 "/usr/include/c++/4.4/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };





  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };





  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    struct decay
    {
    private:
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };



  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    struct __match_cv_qualifiers
    {
    private:
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };



  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };



  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    struct __make_unsigned_selector;

  template<typename _Tp>
    struct __make_unsigned_selector<_Tp, true, false>
    {
    private:
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    struct __make_unsigned_selector<_Tp, false, true>
    {
    private:

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };



  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    struct __make_signed_selector;

  template<typename _Tp>
    struct __make_signed_selector<_Tp, true, false>
    {
    private:
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    struct __make_signed_selector<_Tp, false, true>
    {
    private:

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;


  template<typename... _Tp>
    struct common_type;

  template<typename _Tp>
    struct common_type<_Tp>
    {
      static_assert(sizeof(_Tp) > 0, "must be complete type");
      typedef _Tp type;
    };

  template<typename _Tp, typename _Up>
    class common_type<_Tp, _Up>
    {
      static_assert(sizeof(_Tp) > 0, "must be complete type");
      static_assert(sizeof(_Up) > 0, "must be complete type");

      static _Tp&& __t();
      static _Up&& __u();




      static bool __true_or_false();

    public:
      typedef decltype(__true_or_false() ? __t() : __u()) type;
    };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    {
      typedef typename
        common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
    };


}
# 39 "/usr/include/c++/4.4/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp>
    struct identity
    {
      typedef _Tp type;
    };

  template<typename _Tp>
    inline _Tp&&
    forward(typename std::identity<_Tp>::type&& __t)
    { return __t; }

  template<typename _Tp>
    inline typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t)
    { return __t; }

}






namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }

}
# 61 "/usr/include/c++/4.4/bits/stl_pair.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
        pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)),
   second(std::forward<_U2>(__y)) { }

      pair(pair&& __p)
      : first(std::move(__p.first)),
 second(std::move(__p.second)) { }



      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }


      template<class _U1, class _U2>
        pair(pair<_U1, _U2>&& __p)
 : first(std::move(__p.first)),
   second(std::move(__p.second)) { }


      template<class _U1, class _Arg0, class... _Args>
        pair(_U1&& __x, _Arg0&& __arg0, _Args&&... __args)
 : first(std::forward<_U1>(__x)),
   second(std::forward<_Arg0>(__arg0),
   std::forward<_Args>(__args)...) { }

      pair&
      operator=(pair&& __p)
      {
 first = std::move(__p.first);
 second = std::move(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
        pair&
        operator=(pair<_U1, _U2>&& __p)
 {
   first = std::move(__p.first);
   second = std::move(__p.second);
   return *this;
 }

      void
      swap(pair&& __p)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    { __x.swap(__y); }

  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>&& __x, pair<_T1, _T2>& __y)
    { __x.swap(__y); }

  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>&& __y)
    { __x.swap(__y); }
# 218 "/usr/include/c++/4.4/bits/stl_pair.h" 3
  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };


  template<class _T1, class _T2>
    inline pair<typename __decay_and_strip<_T1>::__type,
  typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      return pair<typename __decay_and_strip<_T1>::__type,
           typename __decay_and_strip<_T2>::__type>
 (std::forward<_T1>(__x), std::forward<_T2>(__y));
    }


}
# 67 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
       
# 64 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 67 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 79 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };

  struct output_iterator_tag { };

  struct forward_iterator_tag : public input_iterator_tag { };


  struct bidirectional_iterator_tag : public forward_iterator_tag { };


  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 102 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }



}
# 68 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
       
# 64 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 108 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 166 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }


  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }


}
# 69 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator.h" 1 3
# 68 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 89 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 276 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
# 388 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 414 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }


      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 457 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 472 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 497 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }


      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 540 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 559 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 601 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }


      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 646 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 665 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 763 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}



namespace std __attribute__ ((__visibility__ ("default"))) {
# 881 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                               difference_type;

      typedef _Iterator pointer;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                               iterator_category;
      typedef value_type&& reference;

    public:
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return _M_current[__n]; }
    };

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(const _Iterator& __i)
    { return move_iterator<_Iterator>(__i); }

}
# 70 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.4/debug/debug.h" 1 3
# 47 "/usr/include/c++/4.4/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 72 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = std::move(*__a);
          *__a = std::move(*__b);
          *__b = std::move(__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 115 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 156 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 184 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 207 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 230 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }




  template<typename _Iterator,
    bool _IsNormal = __is_normal_iterator<_Iterator>::__value>
    struct __niter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __niter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _Iterator,
    bool _IsMove = __is_move_iterator<_Iterator>::__value>
    struct __miter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __miter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   __builtin_memmove(__result, __first,
       sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>
   (std::__niter_base<_II>::__b(__first),
    std::__niter_base<_II>::__b(__last),
    std::__niter_base<_OI>::__b(__result)));
    }
# 456 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base<_II>::__b(__first),
        std::__miter_base<_II>::__b(__last), __result));
    }
# 489 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<true>
       (std::__miter_base<_II>::__b(__first),
        std::__miter_base<_II>::__b(__last), __result));
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base<_BI1>::__b(__first),
     std::__niter_base<_BI1>::__b(__last),
     std::__niter_base<_BI2>::__b(__result)));
    }
# 626 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base<_BI1>::__b(__first),
        std::__miter_base<_BI1>::__b(__last), __result));
    }
# 662 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<true>
       (std::__miter_base<_BI1>::__b(__first),
        std::__miter_base<_BI1>::__b(__last), __result));
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 728 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base<_ForwardIterator>::__b(__first),
      std::__niter_base<_ForwardIterator>::__b(__last), __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 783 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base<_OI>::__b(__first),
     __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 950 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base<_II1>::__b(__first1),
         std::__niter_base<_II1>::__b(__last1),
         std::__niter_base<_II2>::__b(__first2));
    }
# 982 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1013 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux
 (std::__niter_base<_II1>::__b(__first1),
  std::__niter_base<_II1>::__b(__last1),
  std::__niter_base<_II2>::__b(__first2),
  std::__niter_base<_II2>::__b(__last2));
    }
# 1048 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1088 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1125 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

}
# 63 "/usr/include/c++/4.4/bits/stl_tree.h" 2 3
# 1 "/usr/include/c++/4.4/bits/allocator.h" 1 3
# 48 "/usr/include/c++/4.4/bits/allocator.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++allocator.h" 1 3
# 34 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.4/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/4.4/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.4/new" 1 3
# 39 "/usr/include/c++/4.4/new" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 40 "/usr/include/c++/4.4/new" 2 3
# 1 "/usr/include/c++/4.4/exception" 1 3
# 35 "/usr/include/c++/4.4/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 59 "/usr/include/c++/4.4/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 115 "/usr/include/c++/4.4/exception" 3
  bool uncaught_exception() throw();


}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 138 "/usr/include/c++/4.4/exception" 3
  void __verbose_terminate_handler();

}

}

#pragma GCC visibility pop



# 1 "/usr/include/c++/4.4/exception_ptr.h" 1 3
# 34 "/usr/include/c++/4.4/exception_ptr.h" 3
#pragma GCC visibility push(default)
# 43 "/usr/include/c++/4.4/exception_ptr.h" 3
extern "C++" {

namespace std
{






  namespace __exception_ptr
  {



    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() throw();


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));


  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) throw();

  namespace __exception_ptr
  {
    bool
    operator==(const exception_ptr&, const exception_ptr&) throw();

    bool
    operator!=(const exception_ptr&, const exception_ptr&) throw();

    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) throw();

      void _M_addref() throw();
      void _M_release() throw();

      void *_M_get() const throw();

      void _M_safe_bool_dummy();

      friend exception_ptr std::current_exception() throw();
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() throw();

      typedef void (exception_ptr::*__safe_bool)();


      exception_ptr(__safe_bool) throw();

      exception_ptr(const exception_ptr&) throw();


      exception_ptr(exception_ptr&& __o) throw()
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }


      exception_ptr&
      operator=(const exception_ptr&) throw();


      exception_ptr&
      operator=(exception_ptr&& __o) throw()
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() throw();

      void
      swap(exception_ptr&) throw();







      friend bool
      operator==(const exception_ptr&, const exception_ptr&) throw();

      const type_info*
      __cxa_exception_type() const throw();
    };

  }


  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) throw()
    {
      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception ();
 }
    }


}

}

#pragma GCC visibility pop
# 149 "/usr/include/c++/4.4/exception" 2 3
# 41 "/usr/include/c++/4.4/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/include/c++/4.4/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/4.4/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  using std::size_t;
  using std::ptrdiff_t;
# 50 "/usr/include/c++/4.4/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }


      template<typename... _Args>
        void
        construct(pointer __p, _Args&&... __args)
 { ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }


      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 35 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/usr/include/c++/4.4/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/usr/include/c++/4.4/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 85 "/usr/include/c++/4.4/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };

}
# 64 "/usr/include/c++/4.4/bits/stl_tree.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_function.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 99 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 134 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 198 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 262 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 345 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 416 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 523 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}


# 1 "/usr/include/c++/4.4/backward/binders.h" 1 3
# 60 "/usr/include/c++/4.4/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 96 "/usr/include/c++/4.4/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }


}
# 713 "/usr/include/c++/4.4/bits/stl_function.h" 2 3
# 65 "/usr/include/c++/4.4/bits/stl_tree.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 85 "/usr/include/c++/4.4/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;


      template<typename... _Args>
        _Rb_tree_node(_Args&&... __args)
 : _Rb_tree_node_base(),
   _M_value_field(std::forward<_Args>(__args)...) { }

    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }
# 387 "/usr/include/c++/4.4/bits/stl_tree.h" 3
      template<typename... _Args>
        _Link_type
        _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   try
     {
       _M_get_Node_allocator().construct(__tmp,
          std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__tmp);
       throw;
     }
   return __tmp;
 }

      void
      _M_destroy_node(_Link_type __p)
      {
 _M_get_Node_allocator().destroy(__p);
 _M_put_node(__p);
      }


      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }


      _Rb_tree(_Rb_tree&& __x);


      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }

      void

      swap(_Rb_tree&& __t);





      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      void
      erase(const_iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const_iterator __first, const_iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __x)
    : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
    {
      if (__x._M_root() != 0)
 {
   _M_root() = __x._M_root();
   _M_leftmost() = __x._M_leftmost();
   _M_rightmost() = __x._M_rightmost();
   _M_root()->_M_parent = _M_end();

   __x._M_root() = 0;
   __x._M_leftmost() = __x._M_end();
   __x._M_rightmost() = __x._M_end();

   this->_M_impl._M_node_count = __x._M_impl._M_node_count;
   __x._M_impl._M_node_count = 0;
 }
    }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __t)



    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else

 return iterator(static_cast<_Link_type>
   (const_cast<_Base_ptr>(__position._M_node)));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }

}
# 61 "/usr/include/c++/4.4/map" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_map.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_map.h" 3
# 1 "/usr/include/c++/4.4/initializer_list" 1 3
# 35 "/usr/include/c++/4.4/initializer_list" 3
#pragma GCC visibility push(default)

# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 38 "/usr/include/c++/4.4/initializer_list" 2 3

namespace std
{

  template<class _E>
    class initializer_list
    {
      const _E* __array;
      size_t __len;


      initializer_list(const _E* __a, size_t __l)
      : __array(__a), __len(__l) { }

    public:
      initializer_list()
      : __array(__null), __len(0) { }


      size_t size() const
      { return __len; }


      const _E* begin() const
      { return __array; }


      const _E* end() const
      { return begin() + size(); }
  };
}

#pragma GCC visibility pop
# 63 "/usr/include/c++/4.4/bits/stl_map.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 84 "/usr/include/c++/4.4/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 170 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 181 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map(map&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
# 195 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map(initializer_list<value_type> __l,
   const _Compare& __c = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__c, __a)
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
# 211 "/usr/include/c++/4.4/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 227 "/usr/include/c++/4.4/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 250 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 265 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map&
      operator=(map&& __x)
      {

 this->clear();
 this->swap(__x);
 return *this;
      }
# 285 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }







      const_iterator
      cbegin() const
      { return _M_t.begin(); }






      const_iterator
      cend() const
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const
      { return _M_t.rend(); }






      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 441 "/usr/include/c++/4.4/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 463 "/usr/include/c++/4.4/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 498 "/usr/include/c++/4.4/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 510 "/usr/include/c++/4.4/bits/stl_map.h" 3
      void
      insert(std::initializer_list<value_type> __list)
      { insert (__list.begin(), __list.end()); }
# 538 "/usr/include/c++/4.4/bits/stl_map.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 550 "/usr/include/c++/4.4/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 565 "/usr/include/c++/4.4/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 580 "/usr/include/c++/4.4/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 595 "/usr/include/c++/4.4/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 610 "/usr/include/c++/4.4/bits/stl_map.h" 3
      void

      swap(map&& __x)



      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 657 "/usr/include/c++/4.4/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 672 "/usr/include/c++/4.4/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 684 "/usr/include/c++/4.4/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 699 "/usr/include/c++/4.4/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 714 "/usr/include/c++/4.4/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 753 "/usr/include/c++/4.4/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 772 "/usr/include/c++/4.4/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 797 "/usr/include/c++/4.4/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 814 "/usr/include/c++/4.4/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>&& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>&& __y)
    { __x.swap(__y); }


}
# 62 "/usr/include/c++/4.4/map" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_multimap.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 168 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 179 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap(multimap&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
# 192 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a)
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }
# 208 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 224 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 247 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 262 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap&
      operator=(multimap&& __x)
      {

 this->clear();
 this->swap(__x);
 return *this;
      }
# 282 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }







      const_iterator
      cbegin() const
      { return _M_t.begin(); }






      const_iterator
      cend() const
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const
      { return _M_t.rend(); }




      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 436 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 460 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 473 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 486 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 501 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 516 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 531 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 546 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      void

      swap(multimap&& __x)



      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 593 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 608 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 632 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 647 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 684 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 701 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 726 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 743 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>&& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>&& __y)
    { __x.swap(__y); }


}
# 63 "/usr/include/c++/4.4/map" 2 3
# 27 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/c++/4.4/memory" 1 3 4
# 47 "/usr/include/c++/4.4/memory" 3 4
       
# 48 "/usr/include/c++/4.4/memory" 3



# 1 "/usr/include/c++/4.4/bits/stl_construct.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(&*__first);
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }

}
# 52 "/usr/include/c++/4.4/memory" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<bool>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  ::new(static_cast<void*>(&*__cur)) typename
      iterator_traits<_ForwardIterator>::value_type(*__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_pod(_ValueType1)
     && __is_pod(_ValueType2))>::
 uninitialized_copy(__first, __last, __result);
    }


  template<bool>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 162 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_pod(_ValueType)>::
 uninitialized_fill(__first, __last, __x);
    }


  template<bool>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 216 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_pod(_ValueType)>::
 uninitialized_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 330 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     ::new(static_cast<void*>(&*__cur)) typename
  iterator_traits<_ForwardIterator>::value_type(*__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 468 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }


}
# 53 "/usr/include/c++/4.4/memory" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 1 3
# 64 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (!__is_pod(_Tp) && _M_len > 0)
     std::uninitialized_fill_n(_M_buffer, _M_len, *__first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }

}
# 54 "/usr/include/c++/4.4/memory" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_raw_storage_iter.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };

}
# 55 "/usr/include/c++/4.4/memory" 2 3






# 1 "/usr/include/c++/4.4/typeinfo" 1 3
# 36 "/usr/include/c++/4.4/typeinfo" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/4.4/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name; }
# 117 "/usr/include/c++/4.4/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }

    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 62 "/usr/include/c++/4.4/memory" 2 3
# 1 "/usr/include/c++/4.4/iosfwd" 1 3
# 38 "/usr/include/c++/4.4/iosfwd" 3
       
# 39 "/usr/include/c++/4.4/iosfwd" 3


# 1 "/usr/include/c++/4.4/bits/stringfwd.h" 1 3
# 38 "/usr/include/c++/4.4/bits/stringfwd.h" 3
       
# 39 "/usr/include/c++/4.4/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;





  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;

  typedef basic_string<char16_t> u16string;
  typedef basic_string<char32_t> u32string;



}
# 42 "/usr/include/c++/4.4/iosfwd" 2 3
# 1 "/usr/include/c++/4.4/bits/postypes.h" 1 3
# 40 "/usr/include/c++/4.4/bits/postypes.h" 3
       
# 41 "/usr/include/c++/4.4/bits/postypes.h" 3

# 1 "/usr/include/c++/4.4/cwchar" 1 3
# 41 "/usr/include/c++/4.4/cwchar" 3
       
# 42 "/usr/include/c++/4.4/cwchar" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 37 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 38 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/usr/include/wchar.h" 2 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 352 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 129 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();



# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 178 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
           __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 303 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
           size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();

# 403 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 528 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();
# 578 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
# 678 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 734 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 799 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 825 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 835 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 889 "/usr/include/wchar.h" 3 4
}
# 48 "/usr/include/c++/4.4/cwchar" 2 3
# 65 "/usr/include/c++/4.4/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::mbstate_t;

}
# 139 "/usr/include/c++/4.4/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 230 "/usr/include/c++/4.4/cwchar" 3
}







namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  using ::wcstold;
# 254 "/usr/include/c++/4.4/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 283 "/usr/include/c++/4.4/cwchar" 3
# 1 "/usr/include/c++/4.4/tr1_impl/cwchar" 1 3
# 32 "/usr/include/c++/4.4/tr1_impl/cwchar" 3
namespace std
{



  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;



}
# 284 "/usr/include/c++/4.4/cwchar" 2 3
# 43 "/usr/include/c++/4.4/bits/postypes.h" 2 3
# 70 "/usr/include/c++/4.4/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 88 "/usr/include/c++/4.4/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/4.4/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/4.4/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/4.4/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;


}
# 43 "/usr/include/c++/4.4/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 127 "/usr/include/c++/4.4/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 63 "/usr/include/c++/4.4/memory" 2 3
# 1 "/usr/include/c++/4.4/ext/atomicity.h" 1 3
# 34 "/usr/include/c++/4.4/ext/atomicity.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 162 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 1 3
# 41 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 24 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 25 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 26 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 27 "/usr/include/sched.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 33 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/bits/sched.h" 1 3 4
# 71 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 113 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 196 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 36 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 110 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;








extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 27 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/signal.h" 2 3 4
# 50 "/usr/include/signal.h" 3 4
typedef __sigset_t sigset_t;
# 408 "/usr/include/signal.h" 3 4
}
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 76 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
# 187 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 32 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 33 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 117 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 149 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 184 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 222 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 468 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 480 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 514 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 716 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
                                    __const struct timespec *__restrict
                                    __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 782 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 864 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 976 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
                                        __restrict __attr,
                                        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
                                        int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1020 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
                                           int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1087 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1121 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1135 "/usr/include/pthread.h" 3 4
}
# 42 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4
extern "C" {
# 203 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 204 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 208 "/usr/include/unistd.h" 2 3 4
# 221 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 228 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;







typedef __off64_t off_t;




typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 275 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 288 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) throw () __asm__ ("" "lseek64");







extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 385 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") ;


extern ssize_t pwrite (int __fd, __const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64") ;
# 401 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 429 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 441 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 465 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 507 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();






extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));




extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (1)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS

  };
# 605 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 641 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 667 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 684 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();






extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 887 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 187 "/usr/include/getopt.h" 3 4
}
# 888 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 973 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();




extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 1002 "/usr/include/unistd.h" 3 4
extern int truncate (__const char *__file, __off64_t __length) throw () __asm__ ("" "truncate64") __attribute__ ((__nonnull__ (1))) ;







extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1023 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) throw () __asm__ ("" "ftruncate64") ;






extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1040 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1061 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1087 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64") ;






extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1115 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();
# 1153 "/usr/include/unistd.h" 3 4
}
# 43 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 118 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));
static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));
static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 237 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
# 648 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 791 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 163 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 35 "/usr/include/c++/4.4/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "/usr/include/c++/4.4/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 61 "/usr/include/c++/4.4/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 64 "/usr/include/c++/4.4/memory" 2 3
# 1 "/usr/include/c++/4.4/ext/concurrence.h" 1 3
# 38 "/usr/include/c++/4.4/ext/concurrence.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;
# 63 "/usr/include/c++/4.4/ext/concurrence.h" 3
  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  {

    throw __concurrence_lock_error();



  }

  inline void
  __throw_concurrence_unlock_error()
  {

    throw __concurrence_unlock_error();



  }


  inline void
  __throw_concurrence_broadcast_error()
  {

    throw __concurrence_broadcast_error();



  }

  inline void
  __throw_concurrence_wait_error()
  {

    throw __concurrence_wait_error();



  }


  class __mutex
  {
  private:
    __gthread_mutex_t _M_mutex;

    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {

      if (__gthread_active_p())
 {

   __gthread_mutex_t __tmp = { { 0, 0, 0, 0, 0, 0, { 0, 0 } } };
   _M_mutex = __tmp;



 }

    }

    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:
    __gthread_recursive_mutex_t _M_mutex;

    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {

      if (__gthread_active_p())
 {

   __gthread_recursive_mutex_t __tmp = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, { 0, 0 } } };
   _M_mutex = __tmp;



 }

    }

    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
      { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:
    __gthread_cond_t _M_cond;

    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {

      if (__gthread_active_p())
 {

   __gthread_cond_t __tmp = { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } };
   _M_cond = __tmp;



 }

    }

    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };


}
# 65 "/usr/include/c++/4.4/memory" 2 3


# 1 "/usr/include/c++/4.4/bits/unique_ptr.h" 1 3
# 40 "/usr/include/c++/4.4/bits/unique_ptr.h" 3
# 1 "/usr/include/c++/4.4/utility" 1 3
# 59 "/usr/include/c++/4.4/utility" 3
       
# 60 "/usr/include/c++/4.4/utility" 3


# 1 "/usr/include/c++/4.4/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/4.4/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  namespace rel_ops
  {
# 83 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 96 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 109 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 122 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 63 "/usr/include/c++/4.4/utility" 2 3
# 76 "/usr/include/c++/4.4/utility" 3
# 1 "/usr/include/c++/4.4/tr1_impl/utility" 1 3
# 30 "/usr/include/c++/4.4/tr1_impl/utility" 3
namespace std
{


  template<class _Tp>
    class tuple_size;


  template<std::size_t _Int, class _Tp>



    class tuple_element;


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2> >

    { static const std::size_t value = 2; };




  template<class _Tp1, class _Tp2>

    const std::size_t



    tuple_size<std::pair<_Tp1, _Tp2> >::value;

  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2> >
    { typedef _Tp1 type; };

  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2> >
    { typedef _Tp2 type; };


  template<std::size_t _Int>



    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
      static _Tp2& __get(std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
      static const _Tp2& __const_get(const std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.second; }
    };


  template<std::size_t _Int, class _Tp1, class _Tp2>



    inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&
    get(std::pair<_Tp1, _Tp2>& __in)
    { return __pair_get<_Int>::__get(__in); }


  template<std::size_t _Int, class _Tp1, class _Tp2>



    inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&
    get(const std::pair<_Tp1, _Tp2>& __in)
    { return __pair_get<_Int>::__const_get(__in); }


}
# 77 "/usr/include/c++/4.4/utility" 2 3
# 41 "/usr/include/c++/4.4/bits/unique_ptr.h" 2 3
# 1 "/usr/include/c++/4.4/tuple" 1 3
# 32 "/usr/include/c++/4.4/tuple" 3
       
# 33 "/usr/include/c++/4.4/tuple" 3







namespace std
{

  template<typename _Tp>
    struct __add_c_ref
    { typedef const _Tp& type; };

  template<typename _Tp>
    struct __add_c_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_ref
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_ref<_Tp&>
    { typedef _Tp& type; };

  template<std::size_t _Idx, typename _Head, bool _IsEmpty>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      _Head_base()
      : _Head() { }

      _Head_base(const _Head& __h)
      : _Head(__h) { }

      template<typename _UHead>
        _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head& _M_head() { return *this; }
      const _Head& _M_head() const { return *this; }

      void _M_swap_impl(_Head&&) { }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      _Head_base()
      : _M_head_impl() { }

      _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      template<typename _UHead>
        _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head& _M_head() { return _M_head_impl; }
      const _Head& _M_head() const { return _M_head_impl; }

      void
      _M_swap_impl(_Head&& __h)
      {
 using std::swap;
 swap(__h, _M_head_impl);
      }

      _Head _M_head_impl;
    };
# 117 "/usr/include/c++/4.4/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;





  template<std::size_t _Idx>
    struct _Tuple_impl<_Idx>
    {
    protected:
      void _M_swap_impl(_Tuple_impl&&) { }
    };






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, std::is_empty<_Head>::value>
    {
      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, std::is_empty<_Head>::value> _Base;

      _Head& _M_head() { return _Base::_M_head(); }
      const _Head& _M_head() const { return _Base::_M_head(); }

      _Inherited& _M_tail() { return *this; }
      const _Inherited& _M_tail() const { return *this; }

      _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail>
        explicit
        _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      _Tuple_impl(const _Tuple_impl& __in)
      : _Inherited(__in._M_tail()), _Base(__in._M_head()) { }

      _Tuple_impl(_Tuple_impl&& __in)
      : _Inherited(std::move<_Inherited&&>(__in._M_tail())),
 _Base(std::forward<_Head>(__in._M_head())) { }

      template<typename... _UElements>
        _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__in._M_tail()), _Base(__in._M_head()) { }

      template<typename... _UElements>
        _Tuple_impl(_Tuple_impl<_Idx, _UElements...>&& __in)
 : _Inherited(std::move<typename _Tuple_impl<_Idx, _UElements...>::
       _Inherited&&>(__in._M_tail())),
   _Base(std::forward<typename _Tuple_impl<_Idx, _UElements...>::
  _Base>(__in._M_head())) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head() = __in._M_head();
 _M_tail() = __in._M_tail();
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      {
 _M_head() = std::move(__in._M_head());
 _M_tail() = std::move(__in._M_tail());
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head() = __in._M_head();
   _M_tail() = __in._M_tail();
   return *this;
 }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UElements...>&& __in)
        {
   _M_head() = std::move(__in._M_head());
   _M_tail() = std::move(__in._M_tail());
   return *this;
 }

    protected:
      void
      _M_swap_impl(_Tuple_impl&& __in)
      {
 _Base::_M_swap_impl(__in._M_head());
 _Inherited::_M_swap_impl(__in._M_tail());
      }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

    public:
      tuple()
      : _Inherited() { }

      explicit
      tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename... _UElements>
        explicit
        tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      tuple(const tuple& __in)
      : _Inherited(static_cast<const _Inherited&>(__in)) { }

      tuple(tuple&& __in)
      : _Inherited(std::move<_Inherited>(__in)) { }

      template<typename... _UElements>
        tuple(const tuple<_UElements...>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements>
        tuple(tuple<_UElements...>&& __in)
 : _Inherited(std::move<_Tuple_impl<0, _UElements...> >(__in)) { }


      template<typename... _UElements>
        tuple(tuple<_UElements...>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple&& __in)
      { _Inherited::_M_swap_impl(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&&) { }
    };


  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      tuple()
      : _Inherited() { }

      explicit
      tuple(const _T1& __a1, const _T2& __a2)
      : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2>
        explicit
        tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      tuple(const tuple& __in)
      : _Inherited(static_cast<const _Inherited&>(__in)) { }

      tuple(tuple&& __in)
      : _Inherited(std::move<_Inherited>(__in)) { }

      template<typename _U1, typename _U2>
        tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2>
        tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(std::move<_Tuple_impl<0, _U1, _U2> >(__in)) { }

      template<typename _U1, typename _U2>
        tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2>
        tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::move(__in.first), std::move(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head() = __in.first;
   this->_M_tail()._M_head() = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head() = std::move(__in.first);
   this->_M_tail()._M_head() = std::move(__in.second);
   return *this;
 }

      void
      swap(tuple&& __in)
      {
 using std::swap;
 swap(this->_M_head(), __in._M_head());
 swap(this->_M_tail()._M_head(), __in._M_tail()._M_head());
      }
    };



  template<std::size_t __i, typename _Tp>
    struct tuple_element;





  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };


  template<typename _Tp>
    struct tuple_size;


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...> >
    {
      static const std::size_t value = sizeof...(_Elements);
    };

  template<typename... _Elements>
    const std::size_t tuple_size<tuple<_Elements...> >::value;

  template<std::size_t __i, typename _Head, typename... _Tail>
    inline typename __add_ref<_Head>::type
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)
    { return __t._M_head(); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    inline typename __add_c_ref<_Head>::type
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)
    { return __t._M_head(); }



  template<std::size_t __i, typename... _Elements>
    inline typename __add_ref<
                      typename tuple_element<__i, tuple<_Elements...> >::type
                    >::type
    get(tuple<_Elements...>& __t)
    { return __get_helper<__i>(__t); }

  template<std::size_t __i, typename... _Elements>
    inline typename __add_c_ref<
                      typename tuple_element<__i, tuple<_Elements...> >::type
                    >::type
    get(const tuple<_Elements...>& __t)
    { return __get_helper<__i>(__t); }


  template<std::size_t __check_equal_size, std::size_t __i, std::size_t __j,
    typename _Tp, typename _Up>
    struct __tuple_compare;

  template<std::size_t __i, std::size_t __j, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __j, _Tp, _Up>
    {
      static bool __eq(const _Tp& __t, const _Up& __u)
      {
 return (get<__i>(__t) == get<__i>(__u) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u));
      }

      static bool __less(const _Tp& __t, const _Up& __u)
      {
 return ((get<__i>(__t) < get<__i>(__u))
  || !(get<__i>(__u) < get<__i>(__t)) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));
      }
    };

  template<std::size_t __i, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __i, _Tp, _Up>
    {
      static bool __eq(const _Tp&, const _Up&)
      { return true; }

      static bool __less(const _Tp&, const _Up&)
      { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    inline tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }

  template<std::size_t...> struct __index_holder { };

  template<std::size_t __i, typename _IdxHolder, typename... _Elements>
    struct __index_holder_impl;

  template<std::size_t __i, std::size_t... _Indexes, typename _IdxHolder,
    typename... _Elements>
    struct __index_holder_impl<__i, __index_holder<_Indexes...>,
          _IdxHolder, _Elements...>
    {
      typedef typename __index_holder_impl<__i + 1,
        __index_holder<_Indexes..., __i>,
        _Elements...>::type type;
    };

  template<std::size_t __i, std::size_t... _Indexes>
    struct __index_holder_impl<__i, __index_holder<_Indexes...> >
    { typedef __index_holder<_Indexes...> type; };

  template<typename... _Elements>
    struct __make_index_holder
    : __index_holder_impl<0, __index_holder<>, _Elements...> { };

  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(const tuple<_TElements...>& __t,
         const __index_holder<_TIdx...>&,
                       const tuple<_UElements...>& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>(get<_TIdx>(__t)...,
       get<_UIdx>(__u)...); }

  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(tuple<_TElements...>&& __t,
         const __index_holder<_TIdx...>&,
         const tuple<_UElements...>& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>
 (std::move(get<_TIdx>(__t))..., get<_UIdx>(__u)...); }

  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(const tuple<_TElements...>& __t,
         const __index_holder<_TIdx...>&,
         tuple<_UElements...>&& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>
 (get<_TIdx>(__t)..., std::move(get<_UIdx>(__u))...); }

  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(tuple<_TElements...>&& __t,
         const __index_holder<_TIdx...>&,
         tuple<_UElements...>&& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>
 (std::move(get<_TIdx>(__t))..., std::move(get<_UIdx>(__u))...); }

  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)
    {
      return __tuple_cat_helper(__t, typename
    __make_index_holder<_TElements...>::type(),
    __u, typename
    __make_index_holder<_UElements...>::type());
    }

  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(tuple<_TElements...>&& __t, const tuple<_UElements...>& __u)
    {
      return __tuple_cat_helper(std::move(__t), typename
     __make_index_holder<_TElements...>::type(),
     __u, typename
     __make_index_holder<_UElements...>::type());
    }

  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(const tuple<_TElements...>& __t, tuple<_UElements...>&& __u)
    {
      return __tuple_cat_helper(__t, typename
    __make_index_holder<_TElements...>::type(),
    std::move(__u), typename
    __make_index_holder<_UElements...>::type());
    }

  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(tuple<_TElements...>&& __t, tuple<_UElements...>&& __u)
    {
      return __tuple_cat_helper(std::move(__t), typename
    __make_index_holder<_TElements...>::type(),
    std::move(__u), typename
    __make_index_holder<_UElements...>::type());
    }

  template<typename... _Elements>
    inline tuple<_Elements&...>
    tie(_Elements&... __args)
    { return tuple<_Elements&...>(__args...); }

  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    { __x.swap(__y); }

  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>&& __x, tuple<_Elements...>& __y)
    { __x.swap(__y); }

  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>&& __y)
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      _Swallow_assign&
      operator=(const _Tp&)
      { return *this; }
  };


  namespace
  {
    _Swallow_assign ignore;
  };
}
# 42 "/usr/include/c++/4.4/bits/unique_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp>
    struct default_delete
      {
 default_delete() { }

 template<typename _Up>
   default_delete(const default_delete<_Up>&) { }

 void
 operator()(_Tp* __ptr) const
 {
   static_assert(sizeof(_Tp)>0,
   "can't delete pointer to incomplete type");
   delete __ptr;
 }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
      void
      operator()(_Tp* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };


  template <typename _Tp, typename _Tp_Deleter = default_delete<_Tp> >
    class unique_ptr
    {
      typedef std::tuple<_Tp*, _Tp_Deleter> __tuple_type;
      typedef __tuple_type unique_ptr::* __unspecified_bool_type;
      typedef _Tp* unique_ptr::* __unspecified_pointer_type;

    public:
      typedef _Tp* pointer;
      typedef _Tp element_type;
      typedef _Tp_Deleter deleter_type;


      unique_ptr()
      : _M_t(pointer(), deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }

      explicit
      unique_ptr(pointer __p)
      : _M_t(__p, deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }

      unique_ptr(pointer __p,
          typename std::conditional<std::is_reference<deleter_type>::value,
            deleter_type, const deleter_type&>::type __d)
      : _M_t(__p, __d) { }

      unique_ptr(pointer __p,
          typename std::remove_reference<deleter_type>::type&& __d)
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u)
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }

      template<typename _Up, typename _Up_Deleter>
        unique_ptr(unique_ptr<_Up, _Up_Deleter>&& __u)
        : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))
 { }


      ~unique_ptr() { reset(); }


      unique_ptr&
      operator=(unique_ptr&& __u)
      {
        reset(__u.release());
        get_deleter() = std::move(__u.get_deleter());
        return *this;
      }

      template<typename _Up, typename _Up_Deleter>
        unique_ptr&
        operator=(unique_ptr<_Up, _Up_Deleter>&& __u)
 {
          reset(__u.release());
          get_deleter() = std::move(__u.get_deleter());
          return *this;
        }

      unique_ptr&
      operator=(__unspecified_pointer_type)
      {
 reset();
 return *this;
      }


      typename std::add_lvalue_reference<element_type>::type operator*() const
      {
 ;
 return *get();
      }

      pointer
      operator->() const
      {
 ;
 return get();
      }

      pointer
      get() const
      { return std::get<0>(_M_t); }

      typename std::add_lvalue_reference<deleter_type>::type
      get_deleter()
      { return std::get<1>(_M_t); }

      typename std::add_lvalue_reference<
          typename std::add_const<deleter_type>::type
              >::type
      get_deleter() const
      { return std::get<1>(_M_t); }

      operator __unspecified_bool_type () const
      { return get() == 0 ? 0 : &unique_ptr::_M_t; }


      pointer
      release()
      {
 pointer __p = get();
 std::get<0>(_M_t) = 0;
 return __p;
      }

      void
      reset(pointer __p = pointer())
      {
 if (__p != get())
   {
     get_deleter()(get());
     std::get<0>(_M_t) = __p;
   }
      }

      void
      swap(unique_ptr&& __u)
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;

      template<typename _Up, typename _Up_Deleter>
        unique_ptr(const unique_ptr<_Up, _Up_Deleter>&) = delete;

      unique_ptr& operator=(const unique_ptr&) = delete;

      template<typename _Up, typename _Up_Deleter>
        unique_ptr& operator=(const unique_ptr<_Up, _Up_Deleter>&) = delete;

    private:
      __tuple_type _M_t;
  };





  template<typename _Tp, typename _Tp_Deleter>
    class unique_ptr<_Tp[], _Tp_Deleter>
    {
      typedef std::tuple<_Tp*, _Tp_Deleter> __tuple_type;
      typedef __tuple_type unique_ptr::* __unspecified_bool_type;
      typedef _Tp* unique_ptr::* __unspecified_pointer_type;

    public:
      typedef _Tp* pointer;
      typedef _Tp element_type;
      typedef _Tp_Deleter deleter_type;


      unique_ptr()
      : _M_t(pointer(), deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }

      explicit
      unique_ptr(pointer __p)
      : _M_t(__p, deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }

      unique_ptr(pointer __p,
          typename std::conditional<std::is_reference<deleter_type>::value,
              deleter_type, const deleter_type&>::type __d)
      : _M_t(__p, __d) { }

      unique_ptr(pointer __p,
   typename std::remove_reference<deleter_type>::type && __d)
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u)
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }

      template<typename _Up, typename _Up_Deleter>
        unique_ptr(unique_ptr<_Up, _Up_Deleter>&& __u)
 : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))
 { }


      ~unique_ptr() { reset(); }


      unique_ptr&
      operator=(unique_ptr&& __u)
      {
 reset(__u.release());
 get_deleter() = std::move(__u.get_deleter());
 return *this;
      }

      template<typename _Up, typename _Up_Deleter>
        unique_ptr&
        operator=(unique_ptr<_Up, _Up_Deleter>&& __u)
 {
          reset(__u.release());
          get_deleter() = std::move(__u.get_deleter());
          return *this;
        }

      unique_ptr&
      operator=(__unspecified_pointer_type)
      {
 reset();
 return *this;
      }


      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }

      pointer
      get() const
      { return std::get<0>(_M_t); }

      typename std::add_lvalue_reference<deleter_type>::type
      get_deleter()
      { return std::get<1>(_M_t); }

      typename std::add_lvalue_reference<
          typename std::add_const<deleter_type>::type
              >::type
      get_deleter() const
      { return std::get<1>(_M_t); }

      operator __unspecified_bool_type () const
      { return get() == 0 ? 0 : &unique_ptr::_M_t; }


      pointer
      release()
      {
 pointer __p = get();
 std::get<0>(_M_t) = 0;
 return __p;
      }

      void
      reset(pointer __p = pointer())
      {
 if (__p != get())
 {
   get_deleter()(get());
   std::get<0>(_M_t) = __p;
 }
      }


      template<typename _Up>
        void reset(_Up) = delete;

      void
      swap(unique_ptr&& __u)
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;



      template<typename _Up>
        unique_ptr(_Up*, typename
     std::conditional<std::is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type,
     typename std::enable_if<std::is_convertible<_Up*,
     pointer>::value>::type* = 0) = delete;

      template<typename _Up>
        unique_ptr(_Up*, typename std::remove_reference<deleter_type>::type&&,
     typename std::enable_if<std::is_convertible<_Up*,
     pointer>::value>::type* = 0) = delete;

      template<typename _Up>
        explicit
        unique_ptr(_Up*, typename std::enable_if<std::is_convertible<_Up*,
     pointer>::value>::type* = 0) = delete;

    private:
      __tuple_type _M_t;
  };

  template<typename _Tp, typename _Tp_Deleter>
    inline void
    swap(unique_ptr<_Tp, _Tp_Deleter>& __x,
  unique_ptr<_Tp, _Tp_Deleter>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Tp_Deleter>
    inline void
    swap(unique_ptr<_Tp, _Tp_Deleter>&& __x,
  unique_ptr<_Tp, _Tp_Deleter>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Tp_Deleter>
    inline void
    swap(unique_ptr<_Tp, _Tp_Deleter>& __x,
  unique_ptr<_Tp, _Tp_Deleter>&& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator==(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator!=(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return !(__x.get() == __y.get()); }

  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator<(const unique_ptr<_Tp, _Tp_Deleter>& __x,
       const unique_ptr<_Up, _Up_Deleter>& __y)
    { return __x.get() < __y.get(); }

  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator<=(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return !(__y.get() < __x.get()); }

  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator>(const unique_ptr<_Tp, _Tp_Deleter>& __x,
       const unique_ptr<_Up, _Up_Deleter>& __y)
    { return __y.get() < __x.get(); }

  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator>=(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return !(__x.get() < __y.get()); }



}
# 68 "/usr/include/c++/4.4/memory" 2 3


# 1 "/usr/include/c++/4.4/functional" 1 3
# 47 "/usr/include/c++/4.4/functional" 3
       
# 48 "/usr/include/c++/4.4/functional" 3
# 61 "/usr/include/c++/4.4/functional" 3
# 1 "/usr/include/c++/4.4/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/4.4/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/4.4/bits/functional_hash.h" 3
# 50 "/usr/include/c++/4.4/bits/functional_hash.h" 3
# 1 "/usr/include/c++/4.4/tr1_impl/functional_hash.h" 1 3
# 30 "/usr/include/c++/4.4/tr1_impl/functional_hash.h" 3
namespace std
{





  template<typename _Tp>
    struct hash : public std::unary_function<_Tp, size_t>
    {
      size_t
      operator()(_Tp __val) const;
    };


  template<typename _Tp>
    struct hash<_Tp*> : public std::unary_function<_Tp*, size_t>
    {
      size_t
      operator()(_Tp* __p) const
      { return reinterpret_cast<size_t>(__p); }
    };
# 60 "/usr/include/c++/4.4/tr1_impl/functional_hash.h" 3
  template<> inline size_t hash<bool>::operator()(bool __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<char>::operator()(char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<signed char>::operator()(signed char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned char>::operator()(unsigned char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<wchar_t>::operator()(wchar_t __val) const { return static_cast<size_t>(__val); };

  template<> inline size_t hash<char16_t>::operator()(char16_t __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<char32_t>::operator()(char32_t __val) const { return static_cast<size_t>(__val); };

  template<> inline size_t hash<short>::operator()(short __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<int>::operator()(int __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<long>::operator()(long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<long long>::operator()(long long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned short>::operator()(unsigned short __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned int>::operator()(unsigned int __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned long>::operator()(unsigned long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned long long>::operator()(unsigned long long __val) const { return static_cast<size_t>(__val); };







  template<size_t = sizeof(size_t)>
    struct _Fnv_hash
    {
      static size_t
      hash(const char* __first, size_t __length)
      {
 size_t __result = 0;
 for (; __length > 0; --__length)
   __result = (__result * 131) + *__first++;
 return __result;
      }
    };

  template<>
    struct _Fnv_hash<4>
    {
      static size_t
      hash(const char* __first, size_t __length)
      {
 size_t __result = static_cast<size_t>(2166136261UL);
 for (; __length > 0; --__length)
   {
     __result ^= static_cast<size_t>(*__first++);
     __result *= static_cast<size_t>(16777619UL);
   }
 return __result;
      }
    };

  template<>
    struct _Fnv_hash<8>
    {
      static size_t
      hash(const char* __first, size_t __length)
      {
 size_t __result =
   static_cast<size_t>(14695981039346656037ULL);
 for (; __length > 0; --__length)
   {
     __result ^= static_cast<size_t>(*__first++);
     __result *= static_cast<size_t>(1099511628211ULL);
   }
 return __result;
      }
    };


  template<>
    inline size_t
    hash<float>::operator()(float __val) const
    {
      size_t __result = 0;


      if (__val != 0.0f)
 __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__val),
         sizeof(__val));
      return __result;
    };


  template<>
    inline size_t
    hash<double>::operator()(double __val) const
    {
 size_t __result = 0;


 if (__val != 0.0)
   __result = _Fnv_hash<>::hash(reinterpret_cast<const char*>(&__val),
           sizeof(__val));
 return __result;
    };


  template<>
    size_t
    hash<long double>::operator()(long double __val) const;


  template<>
    size_t
    hash<string>::operator()(string) const;

  template<>
    size_t
    hash<const string&>::operator()(const string&) const;


  template<>
    size_t
    hash<wstring>::operator()(wstring) const;

  template<>
    size_t
    hash<const wstring&>::operator()(const wstring&) const;



}
# 51 "/usr/include/c++/4.4/bits/functional_hash.h" 2 3







namespace std
{
  struct error_code;

  template<>
    size_t
    hash<error_code>::operator()(error_code) const;
}
# 62 "/usr/include/c++/4.4/functional" 2 3
# 70 "/usr/include/c++/4.4/functional" 3
# 1 "/usr/include/c++/4.4/tr1_impl/functional" 1 3
# 30 "/usr/include/c++/4.4/tr1_impl/functional" 3
namespace std
{


  template<typename _MemberPointer>
    class _Mem_fn;






  template<typename _Tp>
    class _Has_result_type_helper : __sfinae_types
    {
      template<typename _Up>
        struct _Wrap_type
 { };

      template<typename _Up>
        static __one __test(_Wrap_type<typename _Up::result_type>*);

      template<typename _Up>
        static __two __test(...);

    public:
      static const bool value = sizeof(__test<_Tp>(0)) == 1;
    };

  template<typename _Tp>
    struct _Has_result_type
    : integral_constant<bool,
       _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>
    { };





  template<bool _Has_result_type, typename _Functor>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<true, _Functor>
    {
      typedef typename _Functor::result_type result_type;
    };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>
    {
    };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    {
      typedef _Res result_type;
    };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    {
      typedef _Res result_type;
    };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    {
      typedef _Res result_type;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    {
      typedef _Res result_type;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    {
      typedef _Res result_type;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    {
      typedef _Res result_type;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>
    {
      typedef _Res result_type;
    };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    {
    };

  template<typename _Signature>
    class result_of;







  template<bool _Has_result_type, typename _Signature>
    struct _Result_of_impl;


  template<typename _Res, typename _Class, typename _T1>
    struct _Result_of_impl<false, _Res _Class::*(_T1)>
    {
      typedef typename _Mem_fn<_Res _Class::*>
                ::template _Result_type<_T1>::type type;
    };





  template<typename _Functor, typename... _ArgTypes>
    class result_of<_Functor(_ArgTypes...)>
    : public _Result_of_impl<
               _Has_result_type<_Weak_result_type<_Functor> >::value,
               _Functor(_ArgTypes...)>
    {
    };


  template<typename _Functor, typename... _ArgTypes>
    struct _Result_of_impl<true, _Functor(_ArgTypes...)>
    {
      typedef typename _Weak_result_type<_Functor>::result_type type;
    };





  template<typename _Functor, typename... _ArgTypes>
    struct _Result_of_impl<false, _Functor(_ArgTypes...)>
    {
      typedef typename _Functor
                ::template result<_Functor(_ArgTypes...)>::type type;
    };





  template<typename _Functor>
    struct _Result_of_impl<false, _Functor()>
    {
      typedef void type;
    };


  template<typename _Tp>
    struct _Derives_from_unary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _Res>
        static __one __test(const volatile unary_function<_T1, _Res>*);



      static __two __test(...);

    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };


  template<typename _Tp>
    struct _Derives_from_binary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _T2, typename _Res>
        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);



      static __two __test(...);

    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };


  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>
    struct _Function_to_function_pointer
    {
      typedef _Tp type;
    };

  template<typename _Tp>
    struct _Function_to_function_pointer<_Tp, true>
    {
      typedef _Tp* type;
    };





  template<typename _Functor, typename... _Args>
    inline
    typename __gnu_cxx::__enable_if<
             (!is_member_pointer<_Functor>::value
              && !is_function<_Functor>::value
              && !is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args...)>::type
           >::__type
    __invoke(_Functor& __f, _Args&... __args)
    {
      return __f(__args...);
    }

  template<typename _Functor, typename... _Args>
    inline
    typename __gnu_cxx::__enable_if<
             (is_member_pointer<_Functor>::value
              && !is_function<_Functor>::value
              && !is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args...)>::type
           >::__type
    __invoke(_Functor& __f, _Args&... __args)
    {
      return mem_fn(__f)(__args...);
    }


  template<typename _Functor, typename... _Args>
    inline
    typename __gnu_cxx::__enable_if<
             (is_pointer<_Functor>::value
              && is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args...)>::type
           >::__type
    __invoke(_Functor __f, _Args&... __args)
    {
      return __f(__args...);
    }






  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : unary_function<typename _Tp::argument_type,
       typename _Tp::result_type>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : binary_function<typename _Tp::first_argument_type,
        typename _Tp::second_argument_type,
        typename _Tp::result_type>
    { };



   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : unary_function<typename _Tp::argument_type,
       typename _Tp::result_type>,
      binary_function<typename _Tp::first_argument_type,
        typename _Tp::second_argument_type,
        typename _Tp::result_type>
    {
      typedef typename _Tp::result_type result_type;
    };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      _Derives_from_unary_function<_Tp>::value,
      _Derives_from_binary_function<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };


  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {


      typedef typename _Function_to_function_pointer<_Tp>::type
        _M_func_type;

      _Tp* _M_data;
    public:
      typedef _Tp type;

      explicit
      reference_wrapper(_Tp& __indata): _M_data(&__indata)
      { }

      reference_wrapper(const reference_wrapper<_Tp>& __inref):
      _M_data(__inref._M_data)
      { }

      reference_wrapper&
      operator=(const reference_wrapper<_Tp>& __inref)
      {
        _M_data = __inref._M_data;
        return *this;
      }

      operator _Tp&() const
      { return this->get(); }

      _Tp&
      get() const
      { return *_M_data; }

      template<typename... _Args>
        typename result_of<_M_func_type(_Args...)>::type
        operator()(_Args&... __args) const
        {
   return __invoke(get(), __args...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t)
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t)
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t)
    { return ref(__t.get()); }

  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t)
    { return cref(__t.get()); }

  template<typename _Tp, bool>
    struct _Mem_fn_const_or_non
    {
      typedef const _Tp& type;
    };

  template<typename _Tp>
    struct _Mem_fn_const_or_non<_Tp, false>
    {
      typedef _Tp& type;
    };






  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...);

      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(__args...); }

      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(__args...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(_Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(__args...); }


      _Res
      operator()(_Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(__args...); }


      template<typename _Tp>
        _Res
 operator()(_Tp& __object, _ArgTypes... __args) const
        { return _M_call(__object, &__object, __args...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>
    : public _Maybe_unary_or_binary_function<_Res, const _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;

      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(__args...); }

      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(__args...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(const _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(__args...); }


      _Res
      operator()(const _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(__args...); }


      template<typename _Tp>
        _Res operator()(_Tp& __object, _ArgTypes... __args) const
        { return _M_call(__object, &__object, __args...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>
    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;

      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(__args...); }

      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(__args...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(volatile _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(__args...); }


      _Res
      operator()(volatile _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(__args...); }


      template<typename _Tp>
        _Res
 operator()(_Tp& __object, _ArgTypes... __args) const
        { return _M_call(__object, &__object, __args...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>
    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;

      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(__args...); }

      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(__args...); }

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      _Res
      operator()(const volatile _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(__args...); }


      _Res
      operator()(const volatile _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(__args...); }


      template<typename _Tp>
        _Res operator()(_Tp& __object, _ArgTypes... __args) const
        { return _M_call(__object, &__object, __args...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class>
    class _Mem_fn<_Res _Class::*>
    {


      template<typename _Tp>
        _Res&
        _M_call(_Tp& __object, _Class *) const
        { return __object.*__pm; }

      template<typename _Tp, typename _Up>
        _Res&
        _M_call(_Tp& __object, _Up * const *) const
        { return (*__object).*__pm; }

      template<typename _Tp, typename _Up>
        const _Res&
        _M_call(_Tp& __object, const _Up * const *) const
        { return (*__object).*__pm; }

      template<typename _Tp>
        const _Res&
        _M_call(_Tp& __object, const _Class *) const
        { return __object.*__pm; }

      template<typename _Tp>
        const _Res&
        _M_call(_Tp& __ptr, const volatile void*) const
        { return (*__ptr).*__pm; }

      template<typename _Tp> static _Tp& __get_ref();

      template<typename _Tp>
        static __sfinae_types::__one __check_const(_Tp&, _Class*);
      template<typename _Tp, typename _Up>
        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);
      template<typename _Tp, typename _Up>
        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);
      template<typename _Tp>
        static __sfinae_types::__two __check_const(_Tp&, const _Class*);
      template<typename _Tp>
        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);

    public:
      template<typename _Tp>
        struct _Result_type
 : _Mem_fn_const_or_non<_Res,
   (sizeof(__sfinae_types::__two)
    == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>
        { };

      template<typename _Signature>
        struct result;

      template<typename _CVMem, typename _Tp>
        struct result<_CVMem(_Tp)>
 : public _Result_type<_Tp> { };

      template<typename _CVMem, typename _Tp>
        struct result<_CVMem(_Tp&)>
 : public _Result_type<_Tp> { };

      explicit
      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }


      _Res&
      operator()(_Class& __object) const
      { return __object.*__pm; }

      const _Res&
      operator()(const _Class& __object) const
      { return __object.*__pm; }


      _Res&
      operator()(_Class* __object) const
      { return __object->*__pm; }

      const _Res&
      operator()(const _Class* __object) const
      { return __object->*__pm; }


      template<typename _Tp>
        typename _Result_type<_Tp>::type
        operator()(_Tp& __unknown) const
        { return _M_call(__unknown, &__unknown); }

    private:
      _Res _Class::*__pm;
    };





  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm)
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }






  template<typename _Tp>
    struct is_bind_expression
    { static const bool value = false; };

  template<typename _Tp>
    const bool is_bind_expression<_Tp>::value;





  template<typename _Tp>
    struct is_placeholder
    { static const int value = 0; };

  template<typename _Tp>
    const int is_placeholder<_Tp>::value;


  template<int _Num> struct _Placeholder { };
# 832 "/usr/include/c++/4.4/tr1_impl/functional" 3
  namespace placeholders
  {
    namespace
    {
      _Placeholder<1> _1;
      _Placeholder<2> _2;
      _Placeholder<3> _3;
      _Placeholder<4> _4;
      _Placeholder<5> _5;
      _Placeholder<6> _6;
      _Placeholder<7> _7;
      _Placeholder<8> _8;
      _Placeholder<9> _9;
      _Placeholder<10> _10;
      _Placeholder<11> _11;
      _Placeholder<12> _12;
      _Placeholder<13> _13;
      _Placeholder<14> _14;
      _Placeholder<15> _15;
      _Placeholder<16> _16;
      _Placeholder<17> _17;
      _Placeholder<18> _18;
      _Placeholder<19> _19;
      _Placeholder<20> _20;
      _Placeholder<21> _21;
      _Placeholder<22> _22;
      _Placeholder<23> _23;
      _Placeholder<24> _24;
      _Placeholder<25> _25;
      _Placeholder<26> _26;
      _Placeholder<27> _27;
      _Placeholder<28> _28;
      _Placeholder<29> _29;
    }
  }





  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    { static const int value = _Num; };

  template<int _Num>
    const int is_placeholder<_Placeholder<_Num> >::value;





  template<int... _Indexes>
    struct _Index_tuple { };


  template<std::size_t _Num, typename _Tuple = _Index_tuple<> >
    struct _Build_index_tuple;

  template<std::size_t _Num, int... _Indexes>
    struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >
    : _Build_index_tuple<_Num - 1,
                         _Index_tuple<_Indexes..., sizeof...(_Indexes)> >
    {
    };

  template<int... _Indexes>
    struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >
    {
      typedef _Index_tuple<_Indexes...> __type;
    };





  struct _No_tuple_element;






  template<int __i, typename _Tuple, bool _IsSafe>
    struct _Safe_tuple_element_impl
    : tuple_element<__i, _Tuple> { };






  template<int __i, typename _Tuple>
    struct _Safe_tuple_element_impl<__i, _Tuple, false>
    {
      typedef _No_tuple_element type;
    };





 template<int __i, typename _Tuple>
   struct _Safe_tuple_element
   : _Safe_tuple_element_impl<__i, _Tuple,
                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>
   {
   };
# 951 "/usr/include/c++/4.4/tr1_impl/functional" 3
  template<typename _Arg,
           bool _IsBindExp = is_bind_expression<_Arg>::value,
           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;





  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:
      typedef _Tp& result_type;





      template<typename _CVRef, typename _Tuple>
        result_type
        operator()(_CVRef& __arg, const _Tuple&) const volatile
        { return __arg.get(); }
    };






  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _Signature> class result;




      template<typename _CVMu, typename _CVArg, typename... _Args>
        class result<_CVMu(_CVArg, tuple<_Args...>)>
 : public result_of<_CVArg(_Args...)> { };

      template<typename _CVArg, typename... _Args>
        typename result_of<_CVArg(_Args...)>::type
        operator()(_CVArg& __arg,
     const tuple<_Args...>& __tuple) const volatile
        {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, int... _Indexes>
        typename result_of<_CVArg(_Args...)>::type
        __call(_CVArg& __arg, const tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
        {
   return __arg( get<_Indexes>(__tuple)...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Signature> class result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
        class result<_CVMu(_CVArg, _Tuple)>
        {



   typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
      - 1), _Tuple>::type
     __base_type;

 public:

   typedef typename add_lvalue_reference<__base_type>::type type;



 };

      template<typename _Tuple>
        typename result<_Mu(_Arg, _Tuple)>::type
        operator()(const volatile _Arg&, const _Tuple& __tuple) const volatile
        {
   return ::std:: get<(is_placeholder<_Arg>::value
       - 1)>(__tuple);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _Signature> struct result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
        struct result<_CVMu(_CVArg, _Tuple)>
        {

   typedef typename add_lvalue_reference<_CVArg>::type type;



 };


      template<typename _CVArg, typename _Tuple>
        _CVArg&
        operator()(_CVArg& __arg, const _Tuple&) const volatile
        { return __arg; }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename... _Args, int... _Indexes>
        typename result_of<
                   _Functor(typename result_of<_Mu<_Bound_args>
                            (_Bound_args, tuple<_Args...>)>::type...)
                 >::type
        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }


      template<typename... _Args, int... _Indexes>
        typename result_of<
                   const _Functor(typename result_of<_Mu<_Bound_args>
                                    (const _Bound_args, tuple<_Args...>)
                                  >::type...)>::type
        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }


      template<typename... _Args, int... _Indexes>
        typename result_of<
                   volatile _Functor(typename result_of<_Mu<_Bound_args>
                                    (volatile _Bound_args, tuple<_Args...>)
                                  >::type...)>::type
        __call(const tuple<_Args...>& __args,
               _Index_tuple<_Indexes...>) volatile
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }


      template<typename... _Args, int... _Indexes>
        typename result_of<
                   const volatile _Functor(typename result_of<_Mu<_Bound_args>
                                    (const volatile _Bound_args,
                                     tuple<_Args...>)
                                  >::type...)>::type
        __call(const tuple<_Args...>& __args,
               _Index_tuple<_Indexes...>) const volatile
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }

     public:
      explicit _Bind(_Functor __f, _Bound_args... __bound_args)
        : _M_f(__f), _M_bound_args(__bound_args...) { }


      template<typename... _Args>
        typename result_of<
                   _Functor(typename result_of<_Mu<_Bound_args>
                            (_Bound_args, tuple<_Args...>)>::type...)
                 >::type
        operator()(_Args&... __args)
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }


      template<typename... _Args>
        typename result_of<
                   const _Functor(typename result_of<_Mu<_Bound_args>
                            (const _Bound_args, tuple<_Args...>)>::type...)
                 >::type
        operator()(_Args&... __args) const
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }



      template<typename... _Args>
        typename result_of<
                   volatile _Functor(typename result_of<_Mu<_Bound_args>
                            (volatile _Bound_args, tuple<_Args...>)>::type...)
                 >::type
        operator()(_Args&... __args) volatile
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }



      template<typename... _Args>
        typename result_of<
                   const volatile _Functor(typename result_of<_Mu<_Bound_args>
                            (const volatile _Bound_args,
                             tuple<_Args...>)>::type...)
                 >::type
        operator()(_Args&... __args) const volatile
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename... _Args, int... _Indexes>
        _Result
        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }


      template<typename... _Args, int... _Indexes>
        _Result
        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }


      template<typename... _Args, int... _Indexes>
        _Result
        __call(const tuple<_Args...>& __args,
               _Index_tuple<_Indexes...>) volatile
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }


      template<typename... _Args, int... _Indexes>
        _Result
        __call(const tuple<_Args...>& __args,
               _Index_tuple<_Indexes...>) const volatile
        {
          return _M_f(_Mu<_Bound_args>()
                      ( get<_Indexes>(_M_bound_args), __args)...);
        }

    public:
      typedef _Result result_type;

      explicit
      _Bind_result(_Functor __f, _Bound_args... __bound_args)
      : _M_f(__f), _M_bound_args(__bound_args...) { }


      template<typename... _Args>
        result_type
        operator()(_Args&... __args)
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }


      template<typename... _Args>
        result_type
        operator()(_Args&... __args) const
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }


      template<typename... _Args>
        result_type
        operator()(_Args&... __args) volatile
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }


      template<typename... _Args>
        result_type
        operator()(_Args&... __args) const volatile
        {
          return this->__call( tie(__args...), _Bound_indexes());
        }
    };


  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    { static const bool value = true; };

  template<typename _Signature>
    const bool is_bind_expression<_Bind<_Signature> >::value;


  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature> >
    { static const bool value = true; };

  template<typename _Result, typename _Signature>
    const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;


  template<typename _Functor, typename... _ArgTypes>
    inline
    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>
    bind(_Functor __f, _ArgTypes... __args)
    {
      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;
      return __result_type(__maybe_type::__do_wrap(__f), __args...);
    }

  template<typename _Result, typename _Functor, typename... _ArgTypes>
    inline
    _Bind_result<_Result,
   typename _Maybe_wrap_member_pointer<_Functor>::type
                            (_ArgTypes...)>
    bind(_Functor __f, _ArgTypes... __args)
    {
      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>
 __result_type;
      return __result_type(__maybe_type::__do_wrap(__f), __args...);
    }






  class bad_function_call : public std::exception { };






  struct _M_clear_type;






  template<typename _Tp>
    struct __is_location_invariant
    : integral_constant<bool,
                        (is_pointer<_Tp>::value
                         || is_member_pointer<_Tp>::value)>
    {
    };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    {
    };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
        (__is_location_invariant<_Functor>::value
         && sizeof(_Functor) <= _M_max_size
         && __alignof__(_Functor) <= _M_max_align
         && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? &__source._M_access<_Functor>()
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, const _Functor& __f)
 { _M_init_functor(__functor, __f, _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return __f; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp*& __fp)
   { return __fp; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* const& __mp)
   { return __mp; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, const _Functor& __f, true_type)
 { new (__functor._M_access()) _Functor(__f); }

 static void
 _M_init_functor(_Any_data& __functor, const _Functor& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(__f); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

    public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {

   _Base::_M_init_functor(__functor, &__f.get());
 }
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
                                  _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        return (*_Base::_M_get_pointer(__functor))(__args...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        (*_Base::_M_get_pointer(__functor))(__args...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        return
          __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
           typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
        _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        return
   mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
                 _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

     public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
                 _Manager_operation __op)
      {
        switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
        return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
       
   mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);
      }
    };


  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {

      struct _Hidden_type
      {
 _Hidden_type* _M_bool;
      };


      typedef _Hidden_type* _Hidden_type::* _Safe_bool;

      typedef _Res _Signature_type(_ArgTypes...);

      struct _Useless { };

    public:
      typedef _Res result_type;







      function() : _Function_base() { }





      function(_M_clear_type*) : _Function_base() { }
# 1802 "/usr/include/c++/4.4/tr1_impl/functional" 3
      function(const function& __x);
# 1820 "/usr/include/c++/4.4/tr1_impl/functional" 3
      template<typename _Functor>
        function(_Functor __f,
                 typename __gnu_cxx::__enable_if<
                           !is_integral<_Functor>::value, _Useless>::__type
                   = _Useless());
# 1838 "/usr/include/c++/4.4/tr1_impl/functional" 3
      function&
      operator=(const function& __x)
      {
        function(__x).swap(*this);
        return *this;
      }
# 1852 "/usr/include/c++/4.4/tr1_impl/functional" 3
      function&
      operator=(_M_clear_type*)
      {
        if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = 0;
     _M_invoker = 0;
   }
        return *this;
      }
# 1880 "/usr/include/c++/4.4/tr1_impl/functional" 3
      template<typename _Functor>
        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,
                                 function&>::__type
 operator=(_Functor __f)
 {
   function(__f).swap(*this);
   return *this;
 }
# 1898 "/usr/include/c++/4.4/tr1_impl/functional" 3
      void swap(function& __x)
      {
 _Any_data __old_functor = _M_functor;
 _M_functor = __x._M_functor;
 __x._M_functor = __old_functor;
 _Manager_type __old_manager = _M_manager;
 _M_manager = __x._M_manager;
 __x._M_manager = __old_manager;
 _Invoker_type __old_invoker = _M_invoker;
 _M_invoker = __x._M_invoker;
 __x._M_invoker = __old_invoker;
      }
# 1921 "/usr/include/c++/4.4/tr1_impl/functional" 3
      operator _Safe_bool() const
      {
        if (_M_empty())
   return 0;
 else
   return &_Hidden_type::_M_bool;
      }
# 1939 "/usr/include/c++/4.4/tr1_impl/functional" 3
      _Res operator()(_ArgTypes... __args) const;
# 1952 "/usr/include/c++/4.4/tr1_impl/functional" 3
      const type_info& target_type() const;
# 1963 "/usr/include/c++/4.4/tr1_impl/functional" 3
      template<typename _Functor> _Functor* target();


      template<typename _Functor> const _Functor* target() const;


    private:

      template<typename _Function>
 void operator==(const function<_Function>&) const;
      template<typename _Function>
 void operator!=(const function<_Function>&) const;

      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);
      _Invoker_type _M_invoker;
  };

  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (__x)
 {
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f,
        typename __gnu_cxx::__enable_if<
                       !is_integral<_Functor>::value, _Useless>::__type)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
     _My_handler::_M_init_functor(_M_functor, __f);
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
        {

          throw bad_function_call();



        }
      return _M_invoker(_M_functor, __args...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const
    {
      if (_M_manager)
        {
          _Any_data __typeinfo_result;
          _M_manager(__typeinfo_result, _M_functor, __get_type_info);
          return *__typeinfo_result._M_access<const type_info*>();
        }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target()
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
# 2088 "/usr/include/c++/4.4/tr1_impl/functional" 3
  template<typename _Signature>
    inline bool
    operator==(const function<_Signature>& __f, _M_clear_type*)
    { return !__f; }


  template<typename _Signature>
    inline bool
    operator==(_M_clear_type*, const function<_Signature>& __f)
    { return !__f; }
# 2106 "/usr/include/c++/4.4/tr1_impl/functional" 3
  template<typename _Signature>
    inline bool
    operator!=(const function<_Signature>& __f, _M_clear_type*)
    { return __f; }


  template<typename _Signature>
    inline bool
    operator!=(_M_clear_type*, const function<_Signature>& __f)
    { return __f; }
# 2124 "/usr/include/c++/4.4/tr1_impl/functional" 3
  template<typename _Signature>
    inline void
    swap(function<_Signature>& __x, function<_Signature>& __y)
    { __x.swap(__y); }


}
# 71 "/usr/include/c++/4.4/functional" 2 3
# 71 "/usr/include/c++/4.4/memory" 2 3

# 1 "/usr/include/c++/4.4/backward/auto_ptr.h" 1 3
# 36 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 45 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));
# 84 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 110 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 122 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 133 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 150 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 168 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 178 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 208 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 222 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 237 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 258 "/usr/include/c++/4.4/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));

}
# 73 "/usr/include/c++/4.4/memory" 2 3
# 82 "/usr/include/c++/4.4/memory" 3
# 1 "/usr/include/c++/4.4/tr1_impl/boost_sp_counted_base.h" 1 3
# 50 "/usr/include/c++/4.4/tr1_impl/boost_sp_counted_base.h" 3
namespace std
{


  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const*
    what() const throw()

    { return "std::bad_weak_ptr"; }



  };


  inline void
  __throw_bad_weak_ptr()
  {

    throw bad_weak_ptr();



  }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base()
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base()
      { }



      virtual void
      _M_dispose() = 0;


      virtual void
      _M_destroy()
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      void
      _M_release()
      {
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
         __asm __volatile ("":::"memory");
         __asm __volatile ("":::"memory");
       }

     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
       _M_destroy();
   }
      }

      void
      _M_weak_add_ref()
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release()
      {
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


         __asm __volatile ("":::"memory");
         __asm __volatile ("":::"memory");
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const
      {


        return const_cast<const volatile _Atomic_word&>(_M_use_count);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&);
      _Sp_counted_base& operator=(_Sp_counted_base const&);

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count;
      do
 {
   __count = _M_use_count;
   if (__count == 0)
     __throw_bad_weak_ptr();



 }
      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,
        __count + 1));
    }


}
# 83 "/usr/include/c++/4.4/memory" 2 3
# 1 "/usr/include/c++/4.4/bits/shared_ptr.h" 1 3
# 60 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr
    : public _Sp_counted_base<_Lp>
    {
    public:
      _Sp_counted_ptr(_Ptr __p)
      : _M_ptr(__p) { }

      virtual void
      _M_dispose()
      { delete _M_ptr; }

      virtual void
      _M_destroy()
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info& __ti)
      { return 0; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    protected:
      _Ptr _M_ptr;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter
    : public _Sp_counted_ptr<_Ptr, _Lp>
    {
      typedef typename _Alloc::template
          rebind<_Sp_counted_deleter>::other _My_alloc_type;




      struct _My_Deleter
      : public _My_alloc_type
      {
        _Deleter _M_del;
        _My_Deleter(_Deleter __d, const _Alloc& __a)
          : _My_alloc_type(__a), _M_del(__d) { }
      };

    protected:
      typedef _Sp_counted_ptr<_Ptr, _Lp> _Base_type;

    public:




      _Sp_counted_deleter(_Ptr __p, _Deleter __d)
      : _Base_type(__p), _M_del(__d, _Alloc()) { }





      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)
      : _Base_type(__p), _M_del(__d, __a) { }

      virtual void
      _M_dispose()
      { _M_del._M_del(_Base_type::_M_ptr); }

      virtual void
      _M_destroy()
      {
        _My_alloc_type __a(_M_del);
        this->~_Sp_counted_deleter();
        __a.deallocate(this, 1);
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti)
      { return __ti == typeid(_Deleter) ? &_M_del._M_del : 0; }

    protected:
      _My_Deleter _M_del;
    };



  template<typename _Tp>
    struct _Sp_destroy_inplace
    {
      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }
    };

  struct _Sp_make_shared_tag { };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace
    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>
    {
      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>
        _Base_type;

    public:
      _Sp_counted_ptr_inplace(_Alloc __a)
      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)
      , _M_storage()
      {
        void* __p = &_M_storage;
        ::new (__p) _Tp();
        _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);
      }

      template<typename... _Args>
        _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
        : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)
        , _M_storage()
        {
          void* __p = &_M_storage;
          ::new (__p) _Tp(std::forward<_Args>(__args)...);
          _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);
        }


      virtual void
      _M_destroy()
      {
        typedef typename _Alloc::template
            rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;
        _My_alloc_type __a(_Base_type::_M_del);
        this->~_Sp_counted_ptr_inplace();
        __a.deallocate(this, 1);
      }


      virtual void*
      _M_get_deleter(const std::type_info& __ti)
      {
        return __ti == typeid(_Sp_make_shared_tag)
               ? static_cast<void*>(&_M_storage)
               : _Base_type::_M_get_deleter(__ti);
      }

    private:
      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type
        _M_storage;
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count
    {
    public:
      __shared_count()
      : _M_pi(0)
      { }

      template<typename _Ptr>
        __shared_count(_Ptr __p) : _M_pi(0)
        {
          try
            {
              _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
            }
          catch(...)
            {
              delete __p;
              throw;
            }
        }

      template<typename _Ptr, typename _Deleter>
        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)
        {

          typedef std::allocator<int> _Alloc;
          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
          typedef std::allocator<_Sp_cd_type> _Alloc2;
          _Alloc2 __a2;
          try
            {
              _M_pi = __a2.allocate(1);
              ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);
            }
          catch(...)
            {
              __d(__p);
              if (_M_pi)
                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);
              throw;
            }
        }

      template<typename _Ptr, typename _Deleter, typename _Alloc>
        __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
        {
          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
          typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;
          _Alloc2 __a2(__a);
          try
            {
              _M_pi = __a2.allocate(1);
              ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);
            }
          catch(...)
            {
              __d(__p);
              if (_M_pi)
                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);
              throw;
            }
        }

      template<typename _Tp, typename _Alloc, typename... _Args>
        __shared_count(_Sp_make_shared_tag, _Tp*, _Alloc __a, _Args&&... __args)
        : _M_pi(0)
        {
          typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
          typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;
          _Alloc2 __a2(__a);
          try
            {
              _M_pi = __a2.allocate(1);
              ::new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,
                    std::forward<_Args>(__args)...);
            }
          catch(...)
            {
              if (_M_pi)
         __a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);
              throw;
            }
        }



      template<typename _Tp>
        explicit
        __shared_count(std::auto_ptr<_Tp>&& __r)
        : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
        { __r.release(); }



      template<typename _Tp, typename _Del>
        explicit
        __shared_count(std::unique_ptr<_Tp, _Del>&& __r)
        : _M_pi(_S_create_from_up(std::move(__r)))
        { __r.release(); }


      explicit
      __shared_count(const __weak_count<_Lp>& __r);

      ~__shared_count()
      {
        if (_M_pi != 0)
          _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r)
      : _M_pi(__r._M_pi)
      {
        if (_M_pi != 0)
          _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r)
      {
        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
        if (__tmp != _M_pi)
          {
            if (__tmp != 0)
              __tmp->_M_add_ref_copy();
            if (_M_pi != 0)
              _M_pi->_M_release();
            _M_pi = __tmp;
          }
        return *this;
      }

      void
      _M_swap(__shared_count& __r)
      {
        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
        __r._M_pi = _M_pi;
        _M_pi = __tmp;
      }

      long
      _M_get_use_count() const
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }

      bool
      _M_less(const __shared_count& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b)
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      template<typename _Tp, typename _Del>
        static _Sp_counted_base<_Lp>*
        _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,
          typename std::enable_if<!std::is_reference<_Del>::value>::type* = 0)
        {
          return new _Sp_counted_deleter<_Tp*, _Del, std::allocator<_Tp>,
            _Lp>(__r.get(), __r.get_deleter());
        }

      template<typename _Tp, typename _Del>
        static _Sp_counted_base<_Lp>*
        _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,
          typename std::enable_if<std::is_reference<_Del>::value>::type* = 0)
        {
          typedef typename std::remove_reference<_Del>::type _Del1;
          typedef std::reference_wrapper<_Del1> _Del2;
          return new _Sp_counted_deleter<_Tp*, _Del2, std::allocator<_Tp>,
            _Lp>(__r.get(), std::ref(__r.get_deleter()));
        }

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      __weak_count()
      : _M_pi(0)
      { }

      __weak_count(const __shared_count<_Lp>& __r)
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count<_Lp>& __r)
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }

      ~__weak_count()
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
      }

      __weak_count<_Lp>&
      operator=(const __shared_count<_Lp>& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count<_Lp>&
      operator=(const __weak_count<_Lp>& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      void
      _M_swap(__weak_count<_Lp>& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b)
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != 0)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    class enable_shared_from_this;




  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&,
         const __enable_shared_from_this<_Tp1,
         _Lp>*, const _Tp2*);


  template<typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<>&,
         const enable_shared_from_this<_Tp1>*,
         const _Tp2*);

  template<_Lock_policy _Lp>
    inline void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...)
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
    public:
      typedef _Tp element_type;




      __shared_ptr()
      : _M_ptr(0), _M_refcount()
      { }






      template<typename _Tp1>
        explicit
        __shared_ptr(_Tp1* __p)
 : _M_ptr(__p), _M_refcount(__p)
        {
  

   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }
# 588 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
      template<typename _Tp1, typename _Deleter>
        __shared_ptr(_Tp1* __p, _Deleter __d)
        : _M_ptr(__p), _M_refcount(__p, __d)
        {
  

   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }
# 612 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
      template<typename _Tp1, typename _Deleter, typename _Alloc>
        __shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)
 : _M_ptr(__p), _M_refcount(__p, __d, __a)
        {
  

   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }
# 636 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
      template<typename _Tp1>
        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p)
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
        { }
# 649 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
      template<typename _Tp1>
        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
        { }





      __shared_ptr(__shared_ptr&& __r)
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
        _M_refcount._M_swap(__r._M_refcount);
        __r._M_ptr = 0;
      }





      template<typename _Tp1>
        __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r)
 : _M_ptr(__r._M_ptr), _M_refcount()
        {
         
          _M_refcount._M_swap(__r._M_refcount);
          __r._M_ptr = 0;
        }
# 685 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
      template<typename _Tp1>
        explicit
        __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
        {
  


   _M_ptr = __r._M_ptr;
 }

      template<typename _Tp1, typename _Del>
        explicit
        __shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;




      template<typename _Tp1, typename _Del>
        explicit
        __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
        {
  
   _Tp1* __tmp = __r.get();
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
 }





      template<typename _Tp1>
        explicit
        __shared_ptr(std::auto_ptr<_Tp1>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
        {
  

   _Tp1* __tmp = __r.get();
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
 }


      template<typename _Tp1>
        __shared_ptr&
        operator=(const __shared_ptr<_Tp1, _Lp>& __r)
        {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


      template<typename _Tp1>
        __shared_ptr&
        operator=(std::auto_ptr<_Tp1>&& __r)
        {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }


      __shared_ptr&
      operator=(__shared_ptr&& __r)
      {
        __shared_ptr(std::move(__r)).swap(*this);
        return *this;
      }

      template<class _Tp1>
        __shared_ptr&
        operator=(__shared_ptr<_Tp1, _Lp>&& __r)
        {
          __shared_ptr(std::move(__r)).swap(*this);
          return *this;
        }

      template<typename _Tp1, typename _Del>
        __shared_ptr&
        operator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;

      template<typename _Tp1, typename _Del>
        __shared_ptr&
        operator=(std::unique_ptr<_Tp1, _Del>&& __r)
        {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
        }

      void
      reset()
      { __shared_ptr().swap(*this); }

      template<typename _Tp1>
        void
        reset(_Tp1* __p)
        {

   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Tp1, typename _Deleter>
        void
        reset(_Tp1* __p, _Deleter __d)
        { __shared_ptr(__p, __d).swap(*this); }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
        void
        reset(_Tp1* __p, _Deleter __d, const _Alloc& __a)
        { __shared_ptr(__p, __d, __a).swap(*this); }


      typename std::add_lvalue_reference<_Tp>::type
      operator*() const
      {
 ;
 return *_M_ptr;
      }

      _Tp*
      operator->() const
      {
 ;
 return _M_ptr;
      }

      _Tp*
      get() const
      { return _M_ptr; }


    private:
      typedef _Tp* __shared_ptr::*__unspecified_bool_type;

    public:
      operator __unspecified_bool_type() const
      { return _M_ptr == 0 ? 0 : &__shared_ptr::_M_ptr; }

      bool
      unique() const
      { return _M_refcount._M_unique(); }

      long
      use_count() const
      { return _M_refcount._M_get_use_count(); }

      void
      swap(__shared_ptr<_Tp, _Lp>&& __other)
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }

      template<typename _Tp1>
        bool
        owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const
        { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
        bool
        owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const
        { return _M_refcount._M_less(__rhs._M_refcount); }

    protected:

      template<typename _Alloc, typename... _Args>
        __shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)
        : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
    std::forward<_Args>(__args)...)
        {


          void* __p = _M_refcount._M_get_deleter(typeid(__tag));
          _M_ptr = static_cast<_Tp*>(__p);
   __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);
        }

      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
               typename... _Args>
        friend __shared_ptr<_Tp1, _Lp1>
        __allocate_shared(_Alloc __a, _Args&&... __args);

    private:
      void*
      _M_get_deleter(const std::type_info& __ti) const
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
        friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);

      _Tp* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };


  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b)
    { return __a.get() == __b.get(); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b)
    { return __a.get() != __b.get(); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b)
    { return __a.get() < __b.get(); }

  template<typename _Sp>
    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
    {
      bool
      operator()(const _Sp& __lhs, const _Sp& __rhs) const
      {
        return std::less<typename _Sp::element_type*>()(__lhs.get(),
            __rhs.get());
      }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a,
        const __shared_ptr<_Tp, _Lp>& __b)
    { return __a.get() > __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a,
        const __shared_ptr<_Tp, _Lp>& __b)
    { return __a.get() >= __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a,
        const __shared_ptr<_Tp, _Lp>& __b)
    { return __a.get() <= __b.get(); }


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)
    { __a.swap(__b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>&& __a, __shared_ptr<_Tp, _Lp>& __b)
    { __a.swap(__b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>&& __b)
    { __a.swap(__b); }







  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)
    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)
    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
        return __shared_ptr<_Tp, _Lp>(__r, __p);
      return __shared_ptr<_Tp, _Lp>();
    }


  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }


  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p)
    { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }


  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
    public:
      typedef _Tp element_type;

      __weak_ptr()
      : _M_ptr(0), _M_refcount()
      { }
# 1034 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
      template<typename _Tp1>
        __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
        {
  
   _M_ptr = __r.lock().get();
 }

      template<typename _Tp1>
        __weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r)
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
        { }

      template<typename _Tp1>
        __weak_ptr&
        operator=(const __weak_ptr<_Tp1, _Lp>& __r)
        {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Tp1>
        __weak_ptr&
        operator=(const __shared_ptr<_Tp1, _Lp>& __r)
        {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const
      {


 if (expired())
   return __shared_ptr<element_type, _Lp>();

 try
   {
     return __shared_ptr<element_type, _Lp>(*this);
   }
 catch(const bad_weak_ptr&)
   {



     return __shared_ptr<element_type, _Lp>();
   }







      }

      long
      use_count() const
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
        bool
        owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const
        { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
        bool
        owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const
        { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset()
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s)
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }


      template<typename _Tp1>
        bool operator<(const __weak_ptr<_Tp1, _Lp>&) const = delete;
      template<typename _Tp1>
        bool operator<=(const __weak_ptr<_Tp1, _Lp>&) const = delete;
      template<typename _Tp1>
        bool operator>(const __weak_ptr<_Tp1, _Lp>&) const = delete;
      template<typename _Tp1>
        bool operator>=(const __weak_ptr<_Tp1, _Lp>&) const = delete;

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount)
      {
 _M_ptr = __ptr;
 _M_refcount = __refcount;
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      _Tp* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)
    { __a.swap(__b); }


  template<typename _Tp> struct owner_less;

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }
      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const
      { return __lhs.owner_before(__rhs); }
      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    {
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      __enable_shared_from_this() { }

      __enable_shared_from_this(const __enable_shared_from_this&) { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&)
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
        void
        _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const
        { _M_weak_this._M_assign(__p, __n); }

      template<typename _Tp1>
        friend void
        __enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,
      const __enable_shared_from_this* __pe,
      const _Tp1* __px)
        {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };







  template<typename _Tp>
    class shared_ptr
    : public __shared_ptr<_Tp>
    {
    public:
      shared_ptr()
      : __shared_ptr<_Tp>() { }

      template<typename _Tp1>
        explicit
        shared_ptr(_Tp1* __p)
 : __shared_ptr<_Tp>(__p) { }

      template<typename _Tp1, typename _Deleter>
        shared_ptr(_Tp1* __p, _Deleter __d)
 : __shared_ptr<_Tp>(__p, __d) { }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
        shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)
 : __shared_ptr<_Tp>(__p, __d, __a) { }


      template<typename _Tp1>
        shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p)
 : __shared_ptr<_Tp>(__r, __p) { }

      template<typename _Tp1>
        shared_ptr(const shared_ptr<_Tp1>& __r)
 : __shared_ptr<_Tp>(__r) { }

      shared_ptr(shared_ptr&& __r)
      : __shared_ptr<_Tp>(std::move(__r)) { }

      template<typename _Tp1>
        shared_ptr(shared_ptr<_Tp1>&& __r)
        : __shared_ptr<_Tp>(std::move(__r)) { }

      template<typename _Tp1>
        explicit
        shared_ptr(const weak_ptr<_Tp1>& __r)
 : __shared_ptr<_Tp>(__r) { }


      template<typename _Tp1>
        explicit
        shared_ptr(std::auto_ptr<_Tp1>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }


      template<typename _Tp1, typename _Del>
        explicit
        shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;

      template<typename _Tp1, typename _Del>
        explicit
        shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }

      template<typename _Tp1>
        shared_ptr&
        operator=(const shared_ptr<_Tp1>& __r)
        {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


      template<typename _Tp1>
        shared_ptr&
        operator=(std::auto_ptr<_Tp1>&& __r)
        {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }


      shared_ptr&
      operator=(shared_ptr&& __r)
      {
        this->__shared_ptr<_Tp>::operator=(std::move(__r));
        return *this;
      }

      template<class _Tp1>
        shared_ptr&
        operator=(shared_ptr<_Tp1>&& __r)
        {
          this->__shared_ptr<_Tp>::operator=(std::move(__r));
          return *this;
        }

      template<typename _Tp1, typename _Del>
        shared_ptr&
        operator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;

      template<typename _Tp1, typename _Del>
        shared_ptr&
        operator=(std::unique_ptr<_Tp1, _Del>&& __r)
        {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
        shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)
        : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
        { }

      template<typename _Tp1, typename _Alloc, typename... _Args>
        friend shared_ptr<_Tp1>
        allocate_shared(_Alloc __a, _Args&&... __args);
    };


  template<typename _Tp1, typename _Tp2>
    inline bool
    operator==(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)
    { return __a.get() == __b.get(); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator!=(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)
    { return __a.get() != __b.get(); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)
    { return __a.get() < __b.get(); }

  template<typename _Tp>
    struct less<shared_ptr<_Tp>>
    : public _Sp_less<shared_ptr<_Tp>>
    { };


  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b)
    { __a.swap(__b); }

  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>&& __a, shared_ptr<_Tp>& __b)
    { __a.swap(__b); }

  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>&& __b)
    { __a.swap(__b); }


  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Tp1>& __r)
    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Tp1>& __r)
    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
        return shared_ptr<_Tp>(__r, __p);
      return shared_ptr<_Tp>();
    }







  template<typename _Tp>
    class weak_ptr
    : public __weak_ptr<_Tp>
    {
    public:
      weak_ptr()
      : __weak_ptr<_Tp>() { }

      template<typename _Tp1>
        weak_ptr(const weak_ptr<_Tp1>& __r)
 : __weak_ptr<_Tp>(__r) { }

      template<typename _Tp1>
        weak_ptr(const shared_ptr<_Tp1>& __r)
 : __weak_ptr<_Tp>(__r) { }

      template<typename _Tp1>
        weak_ptr&
        operator=(const weak_ptr<_Tp1>& __r)
        {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Tp1>
        weak_ptr&
        operator=(const shared_ptr<_Tp1>& __r)
        {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      shared_ptr<_Tp>
      lock() const
      {

 if (this->expired())
   return shared_ptr<_Tp>();

 try
   {
     return shared_ptr<_Tp>(*this);
   }
 catch(const bad_weak_ptr&)
   {
     return shared_ptr<_Tp>();
   }




      }


      template<typename _Tp1>
        bool operator<(const weak_ptr<_Tp1>&) const = delete;
      template<typename _Tp1>
        bool operator<=(const weak_ptr<_Tp1>&) const = delete;
      template<typename _Tp1>
        bool operator>(const weak_ptr<_Tp1>&) const = delete;
      template<typename _Tp1>
        bool operator>=(const weak_ptr<_Tp1>&) const = delete;
    };


  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b)
    { __a.swap(__b); }


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };

  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      enable_shared_from_this() { }

      enable_shared_from_this(const enable_shared_from_this&) { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&)
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
        void
        _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const
        { _M_weak_this._M_assign(__p, __n); }

      template<typename _Tp1>
        friend void
        __enable_shared_from_this_helper(const __shared_count<>& __pn,
      const enable_shared_from_this* __pe,
      const _Tp1* __px)
        {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }

      mutable weak_ptr<_Tp> _M_weak_this;
    };

  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(_Alloc __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(),
          std::forward<_Alloc>(__a), std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return __allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
              std::forward<_Args>(__args)...);
    }
# 1564 "/usr/include/c++/4.4/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(_Alloc __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_make_shared_tag(), std::forward<_Alloc>(__a),
              std::forward<_Args>(__args)...);
    }







  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
              std::forward<_Args>(__args)...);
    }



}
# 84 "/usr/include/c++/4.4/memory" 2 3
# 28 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/c++/4.4/string" 1 3 4
# 38 "/usr/include/c++/4.4/string" 3 4
       
# 39 "/usr/include/c++/4.4/string" 3



# 1 "/usr/include/c++/4.4/bits/char_traits.h" 1 3
# 39 "/usr/include/c++/4.4/bits/char_traits.h" 3
       
# 40 "/usr/include/c++/4.4/bits/char_traits.h" 3



# 1 "/usr/include/c++/4.4/cwchar" 1 3
# 41 "/usr/include/c++/4.4/cwchar" 3
       
# 42 "/usr/include/c++/4.4/cwchar" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/c++/4.4/cwchar" 2 3
# 44 "/usr/include/c++/4.4/bits/char_traits.h" 2 3
# 52 "/usr/include/c++/4.4/bits/char_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 64 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 89 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 230 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}




# 1 "/usr/include/c++/4.4/cstdint" 1 3
# 32 "/usr/include/c++/4.4/cstdint" 3
       
# 33 "/usr/include/c++/4.4/cstdint" 3
# 72 "/usr/include/c++/4.4/cstdint" 3
# 1 "/usr/include/c++/4.4/tr1_impl/cstdint" 1 3
# 32 "/usr/include/c++/4.4/tr1_impl/cstdint" 3
namespace std
{


  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;


}
# 73 "/usr/include/c++/4.4/cstdint" 2 3
# 380 "/usr/include/c++/4.4/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

}
# 43 "/usr/include/c++/4.4/string" 2 3


# 1 "/usr/include/c++/4.4/bits/localefwd.h" 1 3
# 39 "/usr/include/c++/4.4/bits/localefwd.h" 3
       
# 40 "/usr/include/c++/4.4/bits/localefwd.h" 3


# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 1 3
# 40 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 3
       
# 41 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.4/clocale" 1 3
# 41 "/usr/include/c++/4.4/clocale" 3
       
# 42 "/usr/include/c++/4.4/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 45 "/usr/include/c++/4.4/clocale" 2 3
# 53 "/usr/include/c++/4.4/clocale" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 43 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  extern "C" __typeof(uselocale) __uselocale;

}


namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 85 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }

}
# 43 "/usr/include/c++/4.4/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/4.4/cctype" 1 3
# 41 "/usr/include/c++/4.4/cctype" 3
       
# 42 "/usr/include/c++/4.4/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4
extern "C" {
# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/usr/include/ctype.h" 3 4
}
# 45 "/usr/include/c++/4.4/cctype" 2 3
# 64 "/usr/include/c++/4.4/cctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 93 "/usr/include/c++/4.4/cctype" 3
# 1 "/usr/include/c++/4.4/tr1_impl/cctype" 1 3
# 34 "/usr/include/c++/4.4/tr1_impl/cctype" 3
namespace std
{


  using ::isblank;


}
# 94 "/usr/include/c++/4.4/cctype" 2 3
# 45 "/usr/include/c++/4.4/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

}
# 46 "/usr/include/c++/4.4/string" 2 3
# 1 "/usr/include/c++/4.4/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/4.4/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/4.4/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.4/cxxabi-forced.h" 1 3
# 29 "/usr/include/c++/4.4/cxxabi-forced.h" 3
#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();
    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/4.4/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 47 "/usr/include/c++/4.4/string" 2 3






# 1 "/usr/include/c++/4.4/bits/basic_string.h" 1 3
# 39 "/usr/include/c++/4.4/bits/basic_string.h" 3
       
# 40 "/usr/include/c++/4.4/bits/basic_string.h" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 103 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 140 "/usr/include/c++/4.4/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 165 "/usr/include/c++/4.4/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 464 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());







      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
# 495 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 528 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }






      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign (__l.begin(), __l.end());
 return *this;
      }







      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 652 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 665 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 694 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 722 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 739 "/usr/include/c++/4.4/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 760 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 779 "/usr/include/c++/4.4/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.end()); }







      basic_string&
      append(const basic_string& __str);
# 850 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 882 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.end()); }
# 904 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 943 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 959 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 971 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 987 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 999 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.end()); }
# 1027 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1042 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1054 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      { this->insert(__p, __l.begin(), __l.end()); }
# 1070 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1092 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1115 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1133 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1156 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1173 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1197 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1213 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {
 ;

 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1233 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1252 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1274 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1298 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1317 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1340 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1358 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1376 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;

 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1397 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1418 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;

 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1440 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;

   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;

 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1510 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct(static_cast<size_type>(__beg), __end, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1591 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1601 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1611 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1643 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1656 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1670 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1687 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1700 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1715 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1728 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1745 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1758 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1773 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1786 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1805 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1819 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1834 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1847 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1866 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1880 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1895 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1909 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1926 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1939 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1955 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1968 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1985 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 2000 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2018 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2048 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2072 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2090 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2113 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2138 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2159 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2230 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2276 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2313 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2350 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2387 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2424 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2461 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2478 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2496 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2519 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2536 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}




# 1 "/usr/include/c++/4.4/ext/string_conversions.h" 1 3
# 28 "/usr/include/c++/4.4/ext/string_conversions.h" 3
       
# 29 "/usr/include/c++/4.4/ext/string_conversions.h" 3



# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 33 "/usr/include/c++/4.4/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.4/cstdlib" 1 3
# 41 "/usr/include/c++/4.4/cstdlib" 3
       
# 42 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstdlib" 2 3
# 68 "/usr/include/c++/4.4/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;





typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 72 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 141 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 201 "/usr/include/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 35 "/usr/include/sys/select.h" 2 3 4
# 46 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();
# 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;
# 248 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 273 "/usr/include/sys/types.h" 3 4
}
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 498 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw ();






extern int clearenv (void) throw ();
# 604 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 618 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 640 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64") __attribute__ ((__nonnull__ (1))) ;






extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 658 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 672 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 729 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 802 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 890 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 958 "/usr/include/stdlib.h" 3 4
}
# 69 "/usr/include/c++/4.4/cstdlib" 2 3
# 100 "/usr/include/c++/4.4/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 157 "/usr/include/c++/4.4/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 190 "/usr/include/c++/4.4/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std __attribute__ ((__visibility__ ("default"))) {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 232 "/usr/include/c++/4.4/cstdlib" 3
# 1 "/usr/include/c++/4.4/tr1_impl/cstdlib" 1 3
# 32 "/usr/include/c++/4.4/tr1_impl/cstdlib" 3
namespace std
{






  using std::lldiv_t;


  using std::llabs;
  using std::lldiv;


  using std::atoll;
  using std::strtoll;
  using std::strtoull;

  using std::strtof;
  using std::strtold;


  using std::abs;

  using std::div;





}
# 233 "/usr/include/c++/4.4/cstdlib" 2 3
# 34 "/usr/include/c++/4.4/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.4/cwchar" 1 3
# 41 "/usr/include/c++/4.4/cwchar" 3
       
# 42 "/usr/include/c++/4.4/cwchar" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/c++/4.4/cwchar" 2 3
# 35 "/usr/include/c++/4.4/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.4/cstdio" 1 3
# 41 "/usr/include/c++/4.4/cstdio" 3
       
# 42 "/usr/include/c++/4.4/cstdio" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstdio" 2 3
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stdarg.h" 1 3 4
# 54 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 490 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 552 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 89 "/usr/include/stdio.h" 3 4




typedef _G_fpos64_t fpos_t;



typedef _G_fpos64_t fpos64_t;
# 141 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 142 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();



# 175 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") ;






extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 229 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);




# 260 "/usr/include/stdio.h" 3 4
extern FILE *fopen (__const char *__restrict __filename, __const char *__restrict __modes) __asm__ ("" "fopen64")

  ;
extern FILE *freopen (__const char *__restrict __filename, __const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


  ;







extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
# 394 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 445 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 504 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 532 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 543 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 576 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 622 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 638 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 699 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 710 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 754 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64");


extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");








# 779 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64");

extern int fsetpos (FILE *__stream, __const fpos_t *__pos) __asm__ ("" "fsetpos64");









extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 827 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 846 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 916 "/usr/include/stdio.h" 3 4
}
# 46 "/usr/include/c++/4.4/cstdio" 2 3
# 93 "/usr/include/c++/4.4/cstdio" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 150 "/usr/include/c++/4.4/cstdio" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 165 "/usr/include/c++/4.4/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 197 "/usr/include/c++/4.4/cstdio" 3
# 1 "/usr/include/c++/4.4/tr1_impl/cstdio" 1 3
# 30 "/usr/include/c++/4.4/tr1_impl/cstdio" 3
namespace std
{



  using std::snprintf;
  using std::vsnprintf;

  using std::vfscanf;
  using std::vscanf;
  using std::vsscanf;



}
# 198 "/usr/include/c++/4.4/cstdio" 2 3
# 36 "/usr/include/c++/4.4/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.4/cerrno" 1 3
# 41 "/usr/include/c++/4.4/cerrno" 3
       
# 42 "/usr/include/c++/4.4/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4
extern "C" {



# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 43 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 44 "/usr/include/c++/4.4/cerrno" 2 3
# 37 "/usr/include/c++/4.4/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;
      (*__errno_location ()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }

}
# 2560 "/usr/include/c++/4.4/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }


  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }


  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }


}
# 54 "/usr/include/c++/4.4/string" 2 3


# 1 "/usr/include/c++/4.4/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/4.4/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__gnu_cxx::__is_null_pointer(__beg)
        && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
       ;





       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 578 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 57 "/usr/include/c++/4.4/string" 2 3
# 29 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/c++/4.4/vector" 1 3 4
# 59 "/usr/include/c++/4.4/vector" 3 4
       
# 60 "/usr/include/c++/4.4/vector" 3





# 1 "/usr/include/c++/4.4/bits/stl_vector.h" 1 3
# 65 "/usr/include/c++/4.4/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }


      _Vector_base(_Vector_base&& __x)
      : _M_impl(__x._M_get_Tp_allocator())
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = 0;
 __x._M_impl._M_finish = 0;
 __x._M_impl._M_end_of_storage = 0;
      }


      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 169 "/usr/include/c++/4.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 226 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 241 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 257 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector(vector&& __x)
      : _Base(std::forward<_Base>(__x)) { }
# 271 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 296 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 324 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 335 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x)
      {

 this->clear();
 this->swap(__x);
 return *this;
      }
# 355 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 373 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 389 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 410 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(begin()); }




      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 551 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }





      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 594 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 609 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 624 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 649 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 667 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 713 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 732 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 763 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 783 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
# 799 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 814 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 831 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      insert(iterator __position, initializer_list<value_type> __l)
      { this->insert(__position, __l.begin(), __l.end()); }
# 849 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 867 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 892 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 913 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 925 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void

      swap(vector&& __x)



      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 984 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1048 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1088 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1166 "/usr/include/c++/4.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1183 "/usr/include/c++/4.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>&& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>&& __y)
    { __x.swap(__y); }


}
# 66 "/usr/include/c++/4.4/vector" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_bvector.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x)
      : _M_impl(__x._M_get_Bit_allocator())
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = 0;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std __attribute__ ((__visibility__ ("default"))) {
# 473 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x)
    : _Base(std::forward<_Base>(__x)) { }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }


    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x)
    {

      this->clear();
      this->swap(__x);
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }


    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const
    { return const_reverse_iterator(begin()); }


    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void

    swap(vector&& __x)



    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }


    void insert(iterator __p, initializer_list<bool> __l)
    { this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 67 "/usr/include/c++/4.4/vector" 2 3


# 1 "/usr/include/c++/4.4/bits/vector.tcc" 1 3
# 60 "/usr/include/c++/4.4/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   std::make_move_iterator(this->_M_impl._M_start),
   std::make_move_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish,
        std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__position, std::move(__x_copy));
     }
   else

     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::move(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     this->_M_impl.construct(this->_M_impl._M_finish,
        std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(__position, std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      std::move(*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);





   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       this->_M_impl.construct(__new_start + __elems_before,

          std::forward<_Args>(__args)...);



       __new_finish = 0;

       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;

       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;

    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

}
# 70 "/usr/include/c++/4.4/vector" 2 3
# 30 "/usr/include/cocaine/common.hpp" 2 3 4




# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 68 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 35 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/boost/make_shared.hpp" 1 3 4
# 15 "/usr/include/boost/make_shared.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/make_shared.hpp" 1 3 4
# 15 "/usr/include/boost/smart_ptr/make_shared.hpp" 3 4
# 1 "/usr/include/boost/config.hpp" 1 3 4
# 26 "/usr/include/boost/config.hpp" 3 4
# 1 "/usr/include/boost/config/user.hpp" 1 3 4
# 27 "/usr/include/boost/config.hpp" 2 3 4




# 1 "/usr/include/boost/config/select_compiler_config.hpp" 1 3 4
# 32 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/compiler/gcc.hpp" 1 3 4
# 36 "/usr/include/boost/config.hpp" 2 3 4




# 1 "/usr/include/boost/config/select_stdlib_config.hpp" 1 3 4
# 17 "/usr/include/boost/config/select_stdlib_config.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 18 "/usr/include/boost/config/select_stdlib_config.hpp" 2 3 4
# 33 "/usr/include/boost/config/select_stdlib_config.hpp" 3 4
# 1 "/usr/include/boost/config/no_tr1/utility.hpp" 1 3 4
# 34 "/usr/include/boost/config/select_stdlib_config.hpp" 2 3 4
# 41 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/stdlib/libstdcpp3.hpp" 1 3 4
# 45 "/usr/include/boost/config.hpp" 2 3 4




# 1 "/usr/include/boost/config/select_platform_config.hpp" 1 3 4
# 50 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/platform/linux.hpp" 1 3 4
# 14 "/usr/include/boost/config/platform/linux.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstdlib" 1 3 4
# 41 "/usr/include/c++/4.4/cstdlib" 3 4
       
# 42 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstdlib" 2 3
# 15 "/usr/include/boost/config/platform/linux.hpp" 2 3 4
# 70 "/usr/include/boost/config/platform/linux.hpp" 3 4
# 1 "/usr/include/boost/config/posix_features.hpp" 1 3 4
# 71 "/usr/include/boost/config/platform/linux.hpp" 2 3 4
# 54 "/usr/include/boost/config.hpp" 2 3 4



# 1 "/usr/include/boost/config/suffix.hpp" 1 3 4
# 468 "/usr/include/boost/config/suffix.hpp" 3 4
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}
# 58 "/usr/include/boost/config.hpp" 2 3 4
# 16 "/usr/include/boost/smart_ptr/make_shared.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 1 3 4
# 27 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
# 1 "/usr/include/boost/config/no_tr1/memory.hpp" 1 3 4
# 28 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4

# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 30 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/checked_delete.hpp" 1 3 4
# 24 "/usr/include/boost/checked_delete.hpp" 3 4
namespace boost
{



template<class T> inline void checked_delete(T * x)
{

    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}

template<class T> inline void checked_array_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}

template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {

        boost::checked_delete(x);
    }
};

template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;

    void operator()(T * x) const
    {
        boost::checked_array_delete(x);
    }
};

}
# 31 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/throw_exception.hpp" 1 3 4
# 23 "/usr/include/boost/throw_exception.hpp" 3 4
# 1 "/usr/include/boost/exception/detail/attribute_noreturn.hpp" 1 3 4
# 24 "/usr/include/boost/throw_exception.hpp" 2 3 4
# 1 "/usr/include/boost/detail/workaround.hpp" 1 3 4
# 25 "/usr/include/boost/throw_exception.hpp" 2 3 4
# 36 "/usr/include/boost/throw_exception.hpp" 3 4
# 1 "/usr/include/boost/exception/exception.hpp" 1 3 4
# 9 "/usr/include/boost/exception/exception.hpp" 3 4
namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:

            refcount_ptr():
                px_(0)
                {
                }

            ~refcount_ptr()
                {
                release();
                }

            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }

            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }

            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }

            T *
            get() const
                {
                return px_;
                }

            private:

            T * px_;

            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }

            void
            release()
                {
                if( px_ )
                    px_->release();
                }
            };
        }



    template <class Tag,class T>
    class error_info;

    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;

    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };

    template <class E,class Tag,class T>
    E const & operator<<( E const &, error_info<Tag,T> const & );

    class exception;

    template <class>
    class shared_ptr;

    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;

        struct
        error_info_container
            {
            virtual char const * diagnostic_information() const = 0;
            virtual shared_ptr<error_info_base const> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base const> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual void release() const = 0;

            protected:

            virtual
            ~error_info_container() throw()
                {
                }
            };

        template <class>
        struct get_info;

        template <>
        struct get_info<throw_function>;

        template <>
        struct get_info<throw_file>;

        template <>
        struct get_info<throw_line>;

        char const * get_diagnostic_information( exception const & );
        }

    class
    exception
        {
        protected:

        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
# 199 "/usr/include/boost/exception/exception.hpp" 3 4
        virtual ~exception() throw()

            = 0

            ;

        private:

        template <class E>
        friend
        E const &
        operator<<( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }

        template <class E>
        friend
        E const &
        operator<<( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }

        template <class E>
        friend
        E const &
        operator<<( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }

        friend char const * exception_detail::get_diagnostic_information( exception const & );

        template <class E,class Tag,class T>
        friend E const & operator<<( E const &, error_info<Tag,T> const & );

        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;

        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };

    inline
    exception::
    ~exception() throw()
        {
        }



    namespace
    exception_detail
        {
        template <class T>
        struct
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }

            ~error_info_injector() throw()
                {
                }
            };

        struct large_size { char c[256]; };
        large_size dispatch( exception * );

        struct small_size { };
        small_size dispatch( void * );

        template <class,int>
        struct enable_error_info_helper;

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };

        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };

        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(dispatch((T*)0))>::type type;
            };
        }

    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }



    namespace
    exception_detail
        {
        class
        clone_base
            {
            public:

            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;

            virtual
            ~clone_base() throw()
                {
                }
            };

        inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            *a = *b;
            }

        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }

        template <class T>
        class
        clone_impl:
            public T,
            public clone_base
            {
            public:

            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }

            ~clone_impl() throw()
                {
                }

            private:

            clone_base const *
            clone() const
                {
                return new clone_impl(*this);
                }

            void
            rethrow() const
                {
                throw*this;
                }
            };
        }

    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }
    }
# 37 "/usr/include/boost/throw_exception.hpp" 2 3 4
# 1 "/usr/include/boost/current_function.hpp" 1 3 4
# 22 "/usr/include/boost/current_function.hpp" 3 4
namespace boost
{

namespace detail
{

inline void current_function_helper()
{
# 61 "/usr/include/boost/current_function.hpp" 3 4
}

}

}
# 38 "/usr/include/boost/throw_exception.hpp" 2 3 4
# 46 "/usr/include/boost/throw_exception.hpp" 3 4
namespace boost
{







inline void throw_exception_assert_compatibility( std::exception const & ) { }

template<class E> __attribute__((noreturn)) inline void throw_exception( E const & e )
{


    throw_exception_assert_compatibility(e);


    throw enable_current_exception(enable_error_info(e));



}



}
# 32 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 1 3 4
# 28 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/bad_weak_ptr.hpp" 1 3 4
# 26 "/usr/include/boost/smart_ptr/bad_weak_ptr.hpp" 3 4
namespace boost
{
# 39 "/usr/include/boost/smart_ptr/bad_weak_ptr.hpp" 3 4
class bad_weak_ptr: public std::exception
{
public:

    virtual char const * what() const throw()
    {
        return "tr1::bad_weak_ptr";
    }
};





}
# 29 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 1 3 4
# 21 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_has_sync.hpp" 1 3 4
# 22 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2 3 4
# 36 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 1 3 4
# 27 "/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 3 4
# 1 "/usr/include/boost/detail/sp_typeinfo.hpp" 1 3 4
# 59 "/usr/include/boost/detail/sp_typeinfo.hpp" 3 4
namespace boost
{

namespace detail
{







typedef std::type_info sp_typeinfo;



}

}
# 28 "/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp" 2 3 4

namespace boost
{

namespace detail
{

inline int atomic_exchange_and_add( int * pw, int dv )
{




    int r;

    __asm__ __volatile__
    (
        "lock\n\t"
        "xadd %1, %0":
        "=m"( *pw ), "=r"( r ):
        "m"( *pw ), "1"( dv ):
        "memory", "cc"
    );

    return r;
}

inline void atomic_increment( int * pw )
{


    __asm__
    (
        "lock\n\t"
        "incl %0":
        "=m"( *pw ):
        "m"( *pw ):
        "cc"
    );
}

inline int atomic_conditional_increment( int * pw )
{




    int rv, tmp;

    __asm__
    (
        "movl %0, %%eax\n\t"
        "0:\n\t"
        "test %%eax, %%eax\n\t"
        "je 1f\n\t"
        "movl %%eax, %2\n\t"
        "incl %2\n\t"
        "lock\n\t"
        "cmpxchgl %2, %0\n\t"
        "jne 0b\n\t"
        "1:":
        "=m"( *pw ), "=&a"( rv ), "=&r"( tmp ):
        "m"( *pw ):
        "cc"
    );

    return rv;
}

class sp_counted_base
{
private:

    sp_counted_base( sp_counted_base const & );
    sp_counted_base & operator= ( sp_counted_base const & );

    int use_count_;
    int weak_count_;

public:

    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
    {
    }

    virtual ~sp_counted_base()
    {
    }




    virtual void dispose() = 0;



    virtual void destroy()
    {
        delete this;
    }

    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;

    void add_ref_copy()
    {
        atomic_increment( &use_count_ );
    }

    bool add_ref_lock()
    {
        return atomic_conditional_increment( &use_count_ ) != 0;
    }

    void release()
    {
        if( atomic_exchange_and_add( &use_count_, -1 ) == 1 )
        {
            dispose();
            weak_release();
        }
    }

    void weak_add_ref()
    {
        atomic_increment( &weak_count_ );
    }

    void weak_release()
    {
        if( atomic_exchange_and_add( &weak_count_, -1 ) == 1 )
        {
            destroy();
        }
    }

    long use_count() const
    {
        return static_cast<int const volatile &>( use_count_ );
    }
};

}

}
# 37 "/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp" 2 3 4
# 30 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 2 3 4
# 1 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 1 3 4
# 38 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 39 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 2 3 4

namespace boost
{
# 50 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
namespace detail
{

template<class X> class sp_counted_impl_p: public sp_counted_base
{
private:

    X * px_;

    sp_counted_impl_p( sp_counted_impl_p const & );
    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );

    typedef sp_counted_impl_p<X> this_type;

public:

    explicit sp_counted_impl_p( X * px ): px_( px )
    {



    }

    virtual void dispose()
    {



        boost::checked_delete( px_ );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & )
    {
        return 0;
    }
# 113 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
};
# 122 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
template<class P, class D> class sp_counted_impl_pd: public sp_counted_base
{
private:

    P ptr;
    D del;

    sp_counted_impl_pd( sp_counted_impl_pd const & );
    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );

    typedef sp_counted_impl_pd<P, D> this_type;

public:



    sp_counted_impl_pd( P p, D d ): ptr(p), del(d)
    {
    }

    virtual void dispose()
    {
        del( ptr );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( del ): 0;
    }
# 179 "/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp" 3 4
};

template<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base
{
private:

    P p_;
    D d_;
    A a_;

    sp_counted_impl_pda( sp_counted_impl_pda const & );
    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );

    typedef sp_counted_impl_pda<P, D, A> this_type;

public:



    sp_counted_impl_pda( P p, D d, A a ): p_( p ), d_( d ), a_( a )
    {
    }

    virtual void dispose()
    {
        d_( p_ );
    }

    virtual void destroy()
    {
        typedef typename A::template rebind< this_type >::other A2;

        A2 a2( a_ );

        this->~this_type();
        a2.deallocate( this, 1 );
    }

    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( d_ ): 0;
    }
};





}

}
# 31 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 2 3 4
# 40 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
namespace boost
{

namespace detail
{
# 53 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
struct sp_nothrow_tag {};

class weak_count;

class shared_count
{
private:

    sp_counted_base * pi_;





    friend class weak_count;

public:

    shared_count(): pi_(0)



    {
    }

    template<class Y> explicit shared_count( Y * p ): pi_( 0 )



    {


        try
        {
            pi_ = new sp_counted_impl_p<Y>( p );
        }
        catch(...)
        {
            boost::checked_delete( p );
            throw;
        }
# 106 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }




    template<class P, class D> shared_count( P p, D d ): pi_(0)




    {





        try
        {
            pi_ = new sp_counted_impl_pd<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
# 143 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }

    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )



    {
        typedef sp_counted_impl_pda<P, D, A> impl_type;
        typedef typename A::template rebind< impl_type >::other A2;

        A2 a2( a );



        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
        }
        catch(...)
        {
            d( p );

            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }

            throw;
        }
# 189 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
    }





    template<class Y>
    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )



    {
# 210 "/usr/include/boost/smart_ptr/detail/shared_count.hpp" 3 4
        r.release();
    }



    ~shared_count()
    {
        if( pi_ != 0 ) pi_->release();



    }

    shared_count(shared_count const & r): pi_(r.pi_)



    {
        if( pi_ != 0 ) pi_->add_ref_copy();
    }



    shared_count(shared_count && r): pi_(r.pi_)



    {
        r.pi_ = 0;
    }



    explicit shared_count(weak_count const & r);
    shared_count( weak_count const & r, sp_nothrow_tag );

    shared_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if( tmp != 0 ) tmp->add_ref_copy();
            if( pi_ != 0 ) pi_->release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(shared_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool unique() const
    {
        return use_count() == 1;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(shared_count const & a, shared_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(shared_count const & a, shared_count const & b)
    {
        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
    }

    void * get_deleter( sp_typeinfo const & ti ) const
    {
        return pi_? pi_->get_deleter( ti ): 0;
    }
};


class weak_count
{
private:

    sp_counted_base * pi_;





    friend class shared_count;

public:

    weak_count(): pi_(0)



    {
    }

    weak_count(shared_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }

    weak_count(weak_count const & r): pi_(r.pi_)



    {
        if(pi_ != 0) pi_->weak_add_ref();
    }





    weak_count(weak_count && r): pi_(r.pi_)



    {
        r.pi_ = 0;
    }



    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();



    }

    weak_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    weak_count & operator= (weak_count const & r)
    {
        sp_counted_base * tmp = r.pi_;

        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }

        return *this;
    }

    void swap(weak_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }

    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }

    bool empty() const
    {
        return pi_ == 0;
    }

    friend inline bool operator==(weak_count const & a, weak_count const & b)
    {
        return a.pi_ == b.pi_;
    }

    friend inline bool operator<(weak_count const & a, weak_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};

inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )



{
    if( pi_ == 0 || !pi_->add_ref_lock() )
    {
        boost::throw_exception( boost::bad_weak_ptr() );
    }
}

inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )



{
    if( pi_ != 0 && !pi_->add_ref_lock() )
    {
        pi_ = 0;
    }
}

}

}
# 33 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4

# 1 "/usr/include/boost/smart_ptr/detail/sp_convertible.hpp" 1 3 4
# 34 "/usr/include/boost/smart_ptr/detail/sp_convertible.hpp" 3 4
namespace boost
{

namespace detail
{

template< class Y, class T > struct sp_convertible
{
    typedef char (&yes) [1];
    typedef char (&no) [2];

    static yes f( T* );
    static no f( ... );

    enum _vt { value = sizeof( f( static_cast<Y*>(0) ) ) == sizeof(yes) };
};

struct sp_empty
{
};

template< bool > struct sp_enable_if_convertible_impl;

template<> struct sp_enable_if_convertible_impl<true>
{
    typedef sp_empty type;
};

template<> struct sp_enable_if_convertible_impl<false>
{
};

template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
{
};

}

}
# 35 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4


# 1 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 1 3 4
# 25 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/spinlock.hpp" 1 3 4
# 38 "/usr/include/boost/smart_ptr/detail/spinlock.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/spinlock_sync.hpp" 1 3 4
# 18 "/usr/include/boost/smart_ptr/detail/spinlock_sync.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/detail/yield_k.hpp" 1 3 4
# 91 "/usr/include/boost/smart_ptr/detail/yield_k.hpp" 3 4
namespace boost
{

namespace detail
{

inline void yield( unsigned k )
{
    if( k < 4 )
    {
    }

    else if( k < 16 )
    {
        __asm__ __volatile__( "rep; nop" : : : "memory" );
    }

    else if( k < 32 || k & 1 )
    {
        sched_yield();
    }
    else
    {

        struct timespec rqtp = { 0, 0 };




        rqtp.tv_sec = 0;
        rqtp.tv_nsec = 1000;

        nanosleep( &rqtp, 0 );
    }
}

}

}
# 19 "/usr/include/boost/smart_ptr/detail/spinlock_sync.hpp" 2 3 4





namespace boost
{

namespace detail
{

class spinlock
{
public:

    int v_;

public:

    bool try_lock()
    {
        int r = __sync_lock_test_and_set( &v_, 1 );
        return r == 0;
    }

    void lock()
    {
        for( unsigned k = 0; !try_lock(); ++k )
        {
            boost::detail::yield( k );
        }
    }

    void unlock()
    {
        __sync_lock_release( &v_ );
    }

public:

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( spinlock & sp ): sp_( sp )
        {
            sp.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

}
}
# 39 "/usr/include/boost/smart_ptr/detail/spinlock.hpp" 2 3 4
# 26 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 27 "/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp" 2 3 4

namespace boost
{

namespace detail
{

template< int I > class spinlock_pool
{
private:

    static spinlock pool_[ 41 ];

public:

    static spinlock & spinlock_for( void const * pv )
    {
        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;
        return pool_[ i ];
    }

    class scoped_lock
    {
    private:

        spinlock & sp_;

        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );

    public:

        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
        {
            sp_.lock();
        }

        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};

template< int I > spinlock spinlock_pool< I >::pool_[ 41 ] =
{
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}
};

}
}
# 38 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 1 "/usr/include/boost/memory_order.hpp" 1 3 4
# 21 "/usr/include/boost/memory_order.hpp" 3 4
namespace boost
{

enum memory_order
{
    memory_order_relaxed = 0,
    memory_order_acquire = 1,
    memory_order_release = 2,
    memory_order_acq_rel = 3,
    memory_order_seq_cst = 7
};

}
# 39 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4


# 1 "/usr/include/c++/4.4/algorithm" 1 3 4
# 59 "/usr/include/c++/4.4/algorithm" 3 4
       
# 60 "/usr/include/c++/4.4/algorithm" 3


# 1 "/usr/include/c++/4.4/bits/stl_algo.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_algo.h" 3
# 1 "/usr/include/c++/4.4/cstdlib" 1 3
# 41 "/usr/include/c++/4.4/cstdlib" 3
       
# 42 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstdlib" 2 3
# 61 "/usr/include/c++/4.4/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.4/bits/algorithmfwd.h" 1 3
# 33 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
       
# 34 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3






namespace std __attribute__ ((__visibility__ ("default"))) {
# 189 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);
# 246 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 527 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&)[_Nm], _Tp (&)[_Nm]);

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);
# 630 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter, _Generator&);

  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

}
# 62 "/usr/include/c++/4.4/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_heap.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 152 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 201 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value));
    }
# 274 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 348 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;

      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
# 371 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 411 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 450 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
# 479 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 508 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;

      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last));
    }
# 534 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;

      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last),
         __comp);
    }
# 556 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 569 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }


}
# 63 "/usr/include/c++/4.4/bits/stl_algo.h" 2 3






namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 117 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     

      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }



  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;

   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 2:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 1:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 338 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 423 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 661 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 707 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 742 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 759 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 776 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 791 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last, __pred,
    std::__iterator_category(__first));
    }
# 815 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
# 833 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 886 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 923 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 962 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }


  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      for (; __n > 0; --__n)
 {
   *__result = *__first;
   ++__first;
   ++__result;
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 1020 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 1048 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }
# 1098 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
# 1141 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
# 1181 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 1221 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {

     

     


      ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = std::move(*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1449 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1476 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = std::__gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = std::move(*__first);
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = std::move(*(__p - __l));
        __p -= __l;
      }

    *__p = std::move(*(__p + __k));
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = std::move(*(__p + __k));
        __p += __k;
      }
    *__p = std::move(*(__p - __l));
    __p -= __l;
  }
     }

   *__p = std::move(__tmp);
   ++__first;
 }
    }
# 1669 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1703 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }




  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }


  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1861 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1943 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     
      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2009 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     
     

     

     

     

      ;
      ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }


  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2418 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2469 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2518 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2569 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2624 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
     
      ;
      ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2686 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     

     

      ;

      ;


      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2747 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     
      ;
      ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2780 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;


     
     

      ;

      ;


      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 3128 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     
      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3183 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;


     

     

      ;
      ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
        __first + __step_size,
        __first + __two_step,
        __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size,
       __first + __step_size, __last,
       __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
       __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3468 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3517 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3572 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3629 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3685 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3742 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3802 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3839 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3870 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3884 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }
# 3898 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (*__next < *__first)
   return __next;
      return __next;
    }
# 3927 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (__comp(*__next, *__first))
   return __next;
      return __next;
    }
# 3956 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _Tp>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3975 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                       : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3994 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min, __max;
      if (*__next < *__first)
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (*__first < *__min)
  __min = __first;
       else if (!(*__first < *__max))
  __max = __first;
       break;
     }

   if (*__next < *__first)
     {
       if (*__next < *__min)
  __min = __next;
       if (!(*__first < *__max))
  __max = __first;
     }
   else
     {
       if (*__first < *__min)
  __min = __first;
       if (!(*__next < *__max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 4070 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;

      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min, __max;
      if (__comp(*__next, *__first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(*__first, *__min))
  __min = __first;
       else if (!__comp(*__first, *__max))
  __max = __first;
       break;
     }

   if (__comp(*__next, *__first))
     {
       if (__comp(*__next, *__min))
  __min = __next;
       if (!__comp(*__first, *__max))
  __max = __first;
     }
   else
     {
       if (__comp(*__first, *__min))
  __min = __first;
       if (!__comp(*__next, *__max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }


  template<typename _Tp>
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }


}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 4192 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 4213 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 4237 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 4266 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4305 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4337 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4369 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4401 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4426 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4466 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4537 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4611 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4647 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4689 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4725 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4758 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4790 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4822 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4850 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 4886 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4925 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4957 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 4985 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 5017 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 5051 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 5090 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 5128 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 5167 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 5205 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     
      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 5241 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;


     

     

      ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 5282 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5345 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5405 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     
      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5447 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;


     

     


      ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5493 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5560 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5627 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5684 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5742 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5803 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5861 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     
     
      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 5927 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;


     
     
     

     

     

     

      ;
      ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5984 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 6012 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 6040 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 6068 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }

}
# 63 "/usr/include/c++/4.4/algorithm" 2 3
# 42 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4
# 58 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
namespace boost
{

template<class T> class shared_ptr;
template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;
template<class T> class enable_shared_from_this2;

namespace detail
{

struct static_cast_tag {};
struct const_cast_tag {};
struct dynamic_cast_tag {};
struct polymorphic_cast_tag {};

template<class T> struct shared_ptr_traits
{
    typedef T & reference;
};

template<> struct shared_ptr_traits<void>
{
    typedef void reference;
};



template<> struct shared_ptr_traits<void const>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void volatile>
{
    typedef void reference;
};

template<> struct shared_ptr_traits<void const volatile>
{
    typedef void reference;
};





template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}

template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_this2< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}
# 136 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
inline void sp_enable_shared_from_this( ... )
{
}







template< class T, class R > struct sp_enable_if_auto_ptr
{
};

template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
{
    typedef R type;
};



}
# 168 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class T> class shared_ptr
{
private:


    typedef shared_ptr<T> this_type;

public:

    typedef T element_type;
    typedef T value_type;
    typedef T * pointer;
    typedef typename boost::detail::shared_ptr_traits<T>::reference reference;

    shared_ptr(): px(0), pn()
    {
    }

    template<class Y>
    explicit shared_ptr( Y * p ): px( p ), pn( p )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }







    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }



    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }



    template<class Y>
    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn)
    {

        px = r.px;
    }

    template<class Y>
    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )
    {
        if( !pn.empty() )
        {
            px = r.px;
        }
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> const & r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : px( r.px ), pn( r.pn )
    {
    }


    template< class Y >
    shared_ptr( shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn )
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
    {
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            pn = boost::detail::shared_count();
        }
    }

    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            boost::throw_exception(std::bad_cast());
        }
    }



    template<class Y>
    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
    {
        Y * tmp = r.get();
        pn = boost::detail::shared_count(r);
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }



    template<class Ap>
    explicit shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
    {
        typename Ap::element_type * tmp = r.get();
        pn = boost::detail::shared_count( r );
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }
# 303 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
    shared_ptr & operator=( shared_ptr const & r )
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r)
    {
        this_type(r).swap(*this);
        return *this;
    }





    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> & r )
    {
        this_type(r).swap(*this);
        return *this;
    }



    template<class Ap>
    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )
    {
        this_type( r ).swap( *this );
        return *this;
    }
# 347 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
    shared_ptr( shared_ptr && r ): px( r.px ), pn()
    {
        pn.swap( r.pn );
        r.px = 0;
    }

    template<class Y>


    shared_ptr( shared_ptr<Y> && r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : px( r.px ), pn()
    {
        pn.swap( r.pn );
        r.px = 0;
    }

    shared_ptr & operator=( shared_ptr && r )
    {
        this_type( std::move( r ) ).swap( *this );
        return *this;
    }

    template<class Y>
    shared_ptr & operator=( shared_ptr<Y> && r )
    {
        this_type( std::move( r ) ).swap( *this );
        return *this;
    }



    void reset()
    {
        this_type().swap(*this);
    }

    template<class Y> void reset(Y * p)
    {
        ((p == 0 || p != px) ? static_cast<void> (0) : __assert_fail ("p == 0 || p != px", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 391, __PRETTY_FUNCTION__));
        this_type(p).swap(*this);
    }

    template<class Y, class D> void reset( Y * p, D d )
    {
        this_type( p, d ).swap( *this );
    }

    template<class Y, class D, class A> void reset( Y * p, D d, A a )
    {
        this_type( p, d, a ).swap( *this );
    }

    template<class Y> void reset( shared_ptr<Y> const & r, T * p )
    {
        this_type( r, p ).swap( *this );
    }

    reference operator* () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 412, __PRETTY_FUNCTION__));
        return *px;
    }

    T * operator-> () const
    {
        ((px != 0) ? static_cast<void> (0) : __assert_fail ("px != 0", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 418, __PRETTY_FUNCTION__));
        return px;
    }

    T * get() const
    {
        return px;
    }


# 1 "/usr/include/boost/smart_ptr/detail/operator_bool.hpp" 1 3 4
# 43 "/usr/include/boost/smart_ptr/detail/operator_bool.hpp" 3 4
    typedef T * this_type::*unspecified_bool_type;

    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }




    bool operator! () const
    {
        return px == 0;
    }
# 429 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 2 3 4

    bool unique() const
    {
        return pn.unique();
    }

    long use_count() const
    {
        return pn.use_count();
    }

    void swap(shared_ptr<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }

    void * _internal_get_deleter( detail::sp_typeinfo const & ti ) const
    {
        return pn.get_deleter( ti );
    }

    bool _internal_equiv( shared_ptr const & r ) const
    {
        return px == r.px && pn == r.pn;
    }






private:

    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;




    T * px;
    boost::detail::shared_count pn;

};

template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() == b.get();
}

template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() != b.get();
}
# 500 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a._internal_less(b);
}

template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
{
    a.swap(b);
}

template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::const_cast_tag());
}

template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}



template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
}

template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
{
    ((dynamic_cast<T *>(r.get()) == r.get()) ? static_cast<void> (0) : __assert_fail ("dynamic_cast<T *>(r.get()) == r.get()", "/usr/include/boost/smart_ptr/shared_ptr.hpp", 544, __PRETTY_FUNCTION__));
    return shared_static_cast<T>(r);
}



template<class T> inline T * get_pointer(shared_ptr<T> const & p)
{
    return p.get();
}
# 577 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)

{
    os << p.get();
    return os;
}
# 607 "/usr/include/boost/smart_ptr/shared_ptr.hpp" 3 4
template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
{
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
}







template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * )
{
    return false;
}

template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    return *p;
}

template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order )
{
    return atomic_load( p );
}

template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    p->swap( r );
}

template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    atomic_store( p, r );
}

template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();
    p->swap( r );
    sp.unlock();

    return r;
}

template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    return atomic_exchange( p, r );
}

template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );

    sp.lock();

    if( p->_internal_equiv( *v ) )
    {
        p->swap( w );

        sp.unlock();

        return true;
    }
    else
    {
        shared_ptr<T> tmp( *p );

        sp.unlock();

        tmp.swap( *v );
        return false;
    }
}

template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order , memory_order )
{
    return atomic_compare_exchange( p, v, w );
}



}
# 17 "/usr/include/boost/smart_ptr/make_shared.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/type_with_alignment.hpp" 1 3 4
# 11 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
# 1 "/usr/include/boost/mpl/if.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/if.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/static_cast.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/static_cast.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/workaround.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/static_cast.hpp" 2 3 4
# 18 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/integral.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/config/integral.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/msvc.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/config/integral.hpp" 2 3 4
# 19 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/eti.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 2 3 4
# 73 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
# 87 "/usr/include/boost/mpl/aux_/value_wknd.hpp" 3 4
}}}
# 18 "/usr/include/boost/mpl/if.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/na_spec.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/na_spec.hpp" 3 4
# 1 "/usr/include/boost/mpl/lambda_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/lambda_fwd.hpp" 3 4
# 1 "/usr/include/boost/mpl/void_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/void_fwd.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/adl.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/config/adl.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/intel.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/config/adl.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/gcc.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/aux_/config/adl.hpp" 2 3 4
# 18 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 2 3 4
# 33 "/usr/include/boost/mpl/aux_/adl_barrier.hpp" 3 4
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
# 18 "/usr/include/boost/mpl/void_fwd.hpp" 2 3 4

namespace mpl_ {

struct void_;

}
namespace boost { namespace mpl { using ::mpl_::void_; } }
# 18 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/na.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/na.hpp" 3 4
# 1 "/usr/include/boost/mpl/bool.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/bool.hpp" 3 4
# 1 "/usr/include/boost/mpl/bool_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/bool_fwd.hpp" 3 4
namespace mpl_ {

template< bool C_ > struct bool_;


typedef bool_<true> true_;
typedef bool_<false> false_;

}

namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
# 18 "/usr/include/boost/mpl/bool.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/integral_c_tag.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/integral_c_tag.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/static_constant.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/integral_c_tag.hpp" 2 3 4

namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
# 19 "/usr/include/boost/mpl/bool.hpp" 2 3 4


namespace mpl_ {

template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};


template< bool C_ >
bool const bool_<C_>::value;


}
# 18 "/usr/include/boost/mpl/aux_/na.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/na_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/na_fwd.hpp" 3 4
namespace mpl_ {


struct na
{
    typedef na type;
    enum { value = 0 };
};

}
namespace boost { namespace mpl { using ::mpl_::na; } }
# 19 "/usr/include/boost/mpl/aux_/na.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/config/ctps.hpp" 1 3 4
# 21 "/usr/include/boost/mpl/aux_/na.hpp" 2 3 4

namespace boost { namespace mpl {

template< typename T >
struct is_na
    : false_
{



};

template<>
struct is_na<na>
    : true_
{



};

template< typename T >
struct is_not_na
    : true_
{



};

template<>
struct is_not_na<na>
    : false_
{



};


template< typename T, typename U > struct if_na
{
    typedef T type;
};

template< typename U > struct if_na<na,U>
{
    typedef U type;
};
# 93 "/usr/include/boost/mpl/aux_/na.hpp" 3 4
}}
# 19 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/lambda.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/config/lambda.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/ttp.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/config/lambda.hpp" 2 3 4
# 20 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/int.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/int.hpp" 3 4
# 1 "/usr/include/boost/mpl/int_fwd.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/int_fwd.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/nttp_decl.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/nttp_decl.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/nttp.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/nttp_decl.hpp" 2 3 4
# 19 "/usr/include/boost/mpl/int_fwd.hpp" 2 3 4

namespace mpl_ {

template< int N > struct int_;

}
namespace boost { namespace mpl { using ::mpl_::int_; } }
# 18 "/usr/include/boost/mpl/int.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/cat.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/cat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/config/config.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/cat.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 2 3 4
# 40 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
namespace mpl_ {

template< int N >
struct int_
{
    static const int value = N;





    typedef int_ type;

    typedef int value_type;
    typedef integral_c_tag tag;
# 72 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;






    operator int() const { return static_cast<int>(this->value); }
};


template< int N >
int const mpl_::int_< N >::value;


}
# 21 "/usr/include/boost/mpl/int.hpp" 2 3 4
# 24 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/lambda_arity_param.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/template_arity_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/template_arity_fwd.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

template< typename F > struct template_arity;

}}}
# 26 "/usr/include/boost/mpl/lambda_fwd.hpp" 2 3 4

namespace boost { namespace mpl {

template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >


    >
struct lambda;

}}
# 19 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/aux_/arity.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/arity.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/dtp.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/arity.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/preprocessor.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 45 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/comma_if.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/comma_if.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/if.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/control/if.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/iif.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/control/if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/bool.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/control/if.hpp" 2 3 4
# 19 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/facilities/empty.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/punctuation/comma.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/punctuation/comma_if.hpp" 2 3 4
# 16 "/usr/include/boost/preprocessor/comma_if.hpp" 2 3 4
# 46 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repeat.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/repeat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/debug/error.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/eat.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/repetition/repeat.hpp" 2 3 4
# 16 "/usr/include/boost/preprocessor/repeat.hpp" 2 3 4
# 47 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/inc.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/inc.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/inc.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/inc.hpp" 2 3 4
# 48 "/usr/include/boost/mpl/aux_/preprocessor/params.hpp" 2 3 4
# 27 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessor/enum.hpp" 1 3 4
# 28 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3 4
# 1 "/usr/include/boost/mpl/limits/arity.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4




# 1 "/usr/include/boost/preprocessor/logical/and.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/logical/and.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/logical/bitand.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/logical/and.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/identity.hpp" 1 3 4
# 15 "/usr/include/boost/preprocessor/identity.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/facilities/identity.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/identity.hpp" 2 3 4
# 24 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/empty.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 66 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/dec.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4


# 1 "/usr/include/boost/preprocessor/control/while.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/control/while.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_left.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/fold_left.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/while.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4

# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4
# 41 "/usr/include/boost/preprocessor/list/fold_left.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/expr_iif.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3 4

# 1 "/usr/include/boost/preprocessor/list/adt.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/adt.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/is_binary.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/detail/is_binary.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/check.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/detail/is_binary.hpp" 2 3 4
# 19 "/usr/include/boost/preprocessor/list/adt.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/logical/compl.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/list/adt.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/list/detail/fold_left.hpp" 2 3 4
# 42 "/usr/include/boost/preprocessor/list/fold_left.hpp" 2 3 4
# 22 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/fold_right.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/list/fold_right.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 21 "/usr/include/boost/preprocessor/list/fold_right.hpp" 2 3 4
# 37 "/usr/include/boost/preprocessor/list/fold_right.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/list/detail/fold_right.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/list/detail/fold_right.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/list/reverse.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/list/detail/fold_right.hpp" 2 3 4
# 38 "/usr/include/boost/preprocessor/list/fold_right.hpp" 2 3 4
# 23 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 48 "/usr/include/boost/preprocessor/control/while.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/detail/while.hpp" 1 3 4
# 49 "/usr/include/boost/preprocessor/control/while.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/elem.hpp" 1 3 4
# 22 "/usr/include/boost/preprocessor/arithmetic/add.hpp" 2 3 4
# 67 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/sub.hpp" 1 3 4
# 68 "/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp" 2 3 4
# 29 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4






# 1 "/usr/include/boost/mpl/aux_/config/overload_resolution.hpp" 1 3 4
# 36 "/usr/include/boost/mpl/aux_/na_spec.hpp" 2 3 4
# 20 "/usr/include/boost/mpl/if.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/lambda_support.hpp" 1 3 4
# 21 "/usr/include/boost/mpl/if.hpp" 2 3 4




namespace boost { namespace mpl {



template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};

template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};



template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:

    typedef if_c<



          static_cast<bool>(T1::value)

        , T2
        , T3
        > almost_type_;

 public:
    typedef typename almost_type_::type type;

   
};
# 131 "/usr/include/boost/mpl/if.hpp" 3 4
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }

}}
# 12 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/repetition/for.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/repetition/for.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/repetition/for.hpp" 2 3 4
# 42 "/usr/include/boost/preprocessor/repetition/for.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/repetition/detail/for.hpp" 1 3 4
# 43 "/usr/include/boost/preprocessor/repetition/for.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4

# 1 "/usr/include/boost/preprocessor/tuple/rem.hpp" 1 3 4
# 23 "/usr/include/boost/preprocessor/list/for_each_i.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/tuple/to_list.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4

# 1 "/usr/include/boost/preprocessor/list/transform.hpp" 1 3 4
# 16 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/list/append.hpp" 1 3 4
# 17 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/alignment_of.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 14 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4

# 1 "/usr/include/boost/type_traits/intrinsics.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/intrinsics.hpp" 3 4
# 1 "/usr/include/boost/type_traits/config.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 131 "/usr/include/boost/type_traits/intrinsics.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_same.hpp" 1 3 4
# 31 "/usr/include/boost/type_traits/is_same.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/integral_constant.hpp" 1 3 4
# 11 "/usr/include/boost/type_traits/integral_constant.hpp" 3 4
# 1 "/usr/include/boost/mpl/integral_c.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/integral_c.hpp" 3 4
# 1 "/usr/include/boost/mpl/integral_c_fwd.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/integral_c_fwd.hpp" 3 4
namespace mpl_ {





template< typename T, T N > struct integral_c;


}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
# 18 "/usr/include/boost/mpl/integral_c.hpp" 2 3 4
# 32 "/usr/include/boost/mpl/integral_c.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3 4
# 40 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
namespace mpl_ {

template< typename T, T N >
struct integral_c
{
    static const T value = N;





    typedef integral_c type;

    typedef T value_type;
    typedef integral_c_tag tag;
# 72 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;






    operator T() const { return static_cast<T>(this->value); }
};


template< typename T, T N >
T const integral_c< T, N >::value;


}
# 33 "/usr/include/boost/mpl/integral_c.hpp" 2 3 4




namespace mpl_ {

template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
# 12 "/usr/include/boost/type_traits/integral_constant.hpp" 2 3 4

namespace boost{




template <class T, T val>

struct integral_constant : public mpl::integral_c<T, val>
{
   typedef integral_constant<T,val> type;
};

template<> struct integral_constant<bool,true> : public mpl::true_
{







   typedef integral_constant<bool,true> type;
};
template<> struct integral_constant<bool,false> : public mpl::false_
{







   typedef integral_constant<bool,false> type;
};

typedef integral_constant<bool,true> true_type;
typedef integral_constant<bool,false> false_type;

}
# 16 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 32 "/usr/include/boost/type_traits/is_same.hpp" 2 3 4

namespace boost {



template< typename T, typename U > struct is_same : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_same< T,T > : ::boost::integral_constant<bool,true> { };
# 98 "/usr/include/boost/type_traits/is_same.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 101 "/usr/include/boost/type_traits/is_same.hpp" 2 3 4
# 132 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_reference.hpp" 1 3 4
# 32 "/usr/include/boost/type_traits/is_reference.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 33 "/usr/include/boost/type_traits/is_reference.hpp" 2 3 4

namespace boost {





template< typename T > struct is_reference : ::boost::integral_constant<bool,false> { };
template< typename T > struct is_reference< T& > : ::boost::integral_constant<bool,true> { };
# 113 "/usr/include/boost/type_traits/is_reference.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 116 "/usr/include/boost/type_traits/is_reference.hpp" 2 3 4
# 133 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_volatile.hpp" 1 3 4
# 28 "/usr/include/boost/type_traits/is_volatile.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/cv_traits_impl.hpp" 1 3 4
# 23 "/usr/include/boost/type_traits/detail/cv_traits_impl.hpp" 3 4
namespace boost {
namespace detail {







template <typename T> struct cv_traits_imp {};

template <typename T>
struct cv_traits_imp<T*>
{
    static const bool is_const = false;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const T*>
{
    static const bool is_const = true;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<volatile T*>
{
    static const bool is_const = false;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};

template <typename T>
struct cv_traits_imp<const volatile T*>
{
    static const bool is_const = true;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
# 92 "/usr/include/boost/type_traits/detail/cv_traits_impl.hpp" 3 4
}
}
# 29 "/usr/include/boost/type_traits/is_volatile.hpp" 2 3 4
# 40 "/usr/include/boost/type_traits/is_volatile.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 41 "/usr/include/boost/type_traits/is_volatile.hpp" 2 3 4

namespace boost {
# 52 "/usr/include/boost/type_traits/is_volatile.hpp" 3 4
   template< typename T > struct is_volatile : ::boost::integral_constant<bool,::boost::detail::cv_traits_imp<T*>::is_volatile> { };

template< typename T > struct is_volatile< T& > : ::boost::integral_constant<bool,false> { };
# 129 "/usr/include/boost/type_traits/is_volatile.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 132 "/usr/include/boost/type_traits/is_volatile.hpp" 2 3 4
# 134 "/usr/include/boost/type_traits/intrinsics.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4

# 1 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/size_t.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/size_t.hpp" 3 4
# 1 "/usr/include/boost/mpl/size_t_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/size_t_fwd.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 20 "/usr/include/boost/mpl/size_t_fwd.hpp" 2 3 4

namespace mpl_ {

template< std::size_t N > struct size_t;

}
namespace boost { namespace mpl { using ::mpl_::size_t; } }
# 18 "/usr/include/boost/mpl/size_t.hpp" 2 3 4





# 1 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3 4
# 40 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
namespace mpl_ {

template< std::size_t N >
struct size_t
{
    static const std::size_t value = N;





    typedef size_t type;

    typedef std::size_t value_type;
    typedef integral_c_tag tag;
# 72 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
    typedef mpl_::size_t< static_cast<std::size_t>((value + 1)) > next;
    typedef mpl_::size_t< static_cast<std::size_t>((value - 1)) > prior;






    operator std::size_t() const { return static_cast<std::size_t>(this->value); }
};


template< std::size_t N >
std::size_t const mpl_::size_t< N >::value;


}
# 24 "/usr/include/boost/mpl/size_t.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3 4

# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 20 "/usr/include/boost/type_traits/detail/size_t_trait_def.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4
# 27 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
namespace boost {

template <typename T> struct alignment_of;


namespace detail {





template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};




template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};


template< typename T >
struct alignment_of_impl
{
# 83 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
   static const std::size_t value = __alignof__(T);

};

}

template< typename T > struct alignment_of : ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> { };




template <typename T>
struct alignment_of<T&>
    : alignment_of<T*>
{
};
# 109 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
template<> struct alignment_of<void> : ::boost::integral_constant<std::size_t,0> { };

template<> struct alignment_of<void const> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void volatile> : ::boost::integral_constant<std::size_t,0> { };
template<> struct alignment_of<void const volatile> : ::boost::integral_constant<std::size_t,0> { };


}
# 125 "/usr/include/boost/type_traits/alignment_of.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/size_t_trait_undef.hpp" 1 3 4
# 126 "/usr/include/boost/type_traits/alignment_of.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_pod.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/is_pod.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_void.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/is_void.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/is_void.hpp" 2 3 4

namespace boost {





template< typename T > struct is_void : ::boost::integral_constant<bool,false> { };
template<> struct is_void< void > : ::boost::integral_constant<bool,true> { };


template<> struct is_void< void const > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_void< void const volatile > : ::boost::integral_constant<bool,true> { };




}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 37 "/usr/include/boost/type_traits/is_void.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_scalar.hpp" 1 3 4
# 12 "/usr/include/boost/type_traits/is_scalar.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_arithmetic.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/is_arithmetic.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_integral.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/is_integral.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/is_integral.hpp" 2 3 4

namespace boost {







template< typename T > struct is_integral : ::boost::integral_constant<bool,false> { };

template<> struct is_integral< unsigned char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< unsigned long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< unsigned long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< signed char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed char const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed short > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed short const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed int > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed int const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< signed long > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< signed long const volatile > : ::boost::integral_constant<bool,true> { };

template<> struct is_integral< bool > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< bool const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< char > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< char const volatile > : ::boost::integral_constant<bool,true> { };





template<> struct is_integral< wchar_t > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< wchar_t const volatile > : ::boost::integral_constant<bool,true> { };
# 65 "/usr/include/boost/type_traits/is_integral.hpp" 3 4
template<> struct is_integral< ::boost::ulong_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::ulong_long_type const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_integral< ::boost::long_long_type > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_integral< ::boost::long_long_type const volatile > : ::boost::integral_constant<bool,true> { };







}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 77 "/usr/include/boost/type_traits/is_integral.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_float.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/is_float.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_float.hpp" 2 3 4

namespace boost {


template< typename T > struct is_float : ::boost::integral_constant<bool,false> { };
template<> struct is_float< float > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< float const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< double const volatile > : ::boost::integral_constant<bool,true> { };
template<> struct is_float< long double > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double volatile > : ::boost::integral_constant<bool,true> { }; template<> struct is_float< long double const volatile > : ::boost::integral_constant<bool,true> { };

}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 26 "/usr/include/boost/type_traits/is_float.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_or.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/detail/ice_or.hpp" 3 4
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
struct ice_or;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_or
{
    static const bool value = true;
};

template <>
struct ice_or<false, false, false, false, false, false, false>
{
    static const bool value = false;
};

}
}
# 16 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4




# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 21 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4

namespace boost {


namespace detail {

template< typename T >
struct is_arithmetic_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value >::value);




};

}






template< typename T > struct is_arithmetic : ::boost::integral_constant<bool,::boost::detail::is_arithmetic_impl<T>::value> { };


}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 50 "/usr/include/boost/type_traits/is_arithmetic.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_enum.hpp" 1 3 4
# 32 "/usr/include/boost/type_traits/is_enum.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 33 "/usr/include/boost/type_traits/is_enum.hpp" 2 3 4

namespace boost {
# 181 "/usr/include/boost/type_traits/is_enum.hpp" 3 4
template< typename T > struct is_enum : ::boost::integral_constant<bool,__is_enum(T)> { };



}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 188 "/usr/include/boost/type_traits/is_enum.hpp" 2 3 4
# 14 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/is_pointer.hpp" 1 3 4
# 24 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_member_pointer.hpp" 1 3 4
# 28 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 1 3 4
# 24 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 1 3 4
# 25 "/usr/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3 4
namespace boost {
namespace type_traits {

template <typename T>
struct is_mem_fun_pointer_impl
{
    static const bool value = false;
};





template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) > { static const bool value = true; };



template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { static const bool value = true; };


template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { static const bool value = true; };

template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { static const bool value = true; };



template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { static const bool value = true; };


template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { static const bool value = true; };



template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { static const bool value = true; };


template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { static const bool value = true; };

template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { static const bool value = true; };
# 776 "/usr/include/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp" 3 4
}
}
# 25 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/remove_cv.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/remove_cv.hpp" 3 4
# 1 "/usr/include/boost/type_traits/broken_compiler_spec.hpp" 1 3 4
# 95 "/usr/include/boost/type_traits/broken_compiler_spec.hpp" 3 4















# 15 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4




# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 20 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4






# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 27 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4

namespace boost {




template< typename T > struct remove_cv { typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type; };
template< typename T > struct remove_cv<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_cv<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T volatile[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T const volatile[N]> { typedef T type[N]; };
# 57 "/usr/include/boost/type_traits/remove_cv.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 60 "/usr/include/boost/type_traits/remove_cv.hpp" 2 3 4
# 26 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4
# 36 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 37 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4

namespace boost {





template< typename T > struct is_member_function_pointer : ::boost::integral_constant<bool,::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value> { };
# 132 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 135 "/usr/include/boost/type_traits/is_member_function_pointer.hpp" 2 3 4
# 29 "/usr/include/boost/type_traits/is_member_pointer.hpp" 2 3 4
# 39 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 40 "/usr/include/boost/type_traits/is_member_pointer.hpp" 2 3 4

namespace boost {
# 50 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
template< typename T > struct is_member_pointer : ::boost::integral_constant<bool,::boost::is_member_function_pointer<T>::value> { };
template< typename T, typename U > struct is_member_pointer< U T::* > : ::boost::integral_constant<bool,true> { };


template< typename T, typename U > struct is_member_pointer< U T::*const > : ::boost::integral_constant<bool,true> { };
template< typename T, typename U > struct is_member_pointer< U T::*volatile > : ::boost::integral_constant<bool,true> { };
template< typename T, typename U > struct is_member_pointer< U T::*const volatile > : ::boost::integral_constant<bool,true> { };
# 112 "/usr/include/boost/type_traits/is_member_pointer.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 115 "/usr/include/boost/type_traits/is_member_pointer.hpp" 2 3 4
# 25 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_and.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/ice_and.hpp" 3 4
namespace boost {
namespace type_traits {

template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
struct ice_and;

template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_and
{
    static const bool value = false;
};

template <>
struct ice_and<true, true, true, true, true, true, true>
{
    static const bool value = true;
};

}
}
# 26 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_not.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/detail/ice_not.hpp" 3 4
namespace boost {
namespace type_traits {

template <bool b>
struct ice_not
{
    static const bool value = true;
};

template <>
struct ice_not<true>
{
    static const bool value = false;
};

}
}
# 27 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4
# 41 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 42 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4

namespace boost {





namespace detail {

template< typename T > struct is_pointer_helper
{
    static const bool value = false;
};
# 63 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
template< typename T > struct is_pointer_helper<T*> { static const bool value = true; };



template< typename T >
struct is_pointer_impl
{
# 80 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
    static const bool value = (::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value , ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value >::value);
# 89 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
};

}

template< typename T > struct is_pointer : ::boost::integral_constant<bool,::boost::detail::is_pointer_impl<T>::value> { };
# 158 "/usr/include/boost/type_traits/is_pointer.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 161 "/usr/include/boost/type_traits/is_pointer.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4





# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 21 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4

namespace boost {

namespace detail {

template <typename T>
struct is_scalar_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value >::value);






};



template <> struct is_scalar_impl<void>{ static const bool value = false; };

template <> struct is_scalar_impl<void const>{ static const bool value = false; };
template <> struct is_scalar_impl<void volatile>{ static const bool value = false; };
template <> struct is_scalar_impl<void const volatile>{ static const bool value = false; };


}

template< typename T > struct is_scalar : ::boost::integral_constant<bool,::boost::detail::is_scalar_impl<T>::value> { };

}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 54 "/usr/include/boost/type_traits/is_scalar.hpp" 2 3 4
# 15 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4



# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 19 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4

namespace boost {


template< typename T > struct is_POD;

namespace detail {



template <typename T> struct is_pod_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, __is_pod(T) >::value);






};


template <typename T, std::size_t sz>
struct is_pod_impl<T[sz]>
    : is_pod_impl<T>
{
};
# 118 "/usr/include/boost/type_traits/is_pod.hpp" 3 4
template<> struct is_pod_impl< void > { static const bool value = (true); };


template<> struct is_pod_impl< void const > { static const bool value = (true); };
template<> struct is_pod_impl< void volatile > { static const bool value = (true); };
template<> struct is_pod_impl< void const volatile > { static const bool value = (true); };


}

template< typename T > struct is_POD : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };
template< typename T > struct is_pod : ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { };

}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 134 "/usr/include/boost/type_traits/is_pod.hpp" 2 3 4
# 19 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 1 "/usr/include/boost/static_assert.hpp" 1 3 4
# 20 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4



# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 24 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4

# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 26 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4






namespace boost {



namespace detail {

class alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();
# 101 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
template <bool found, std::size_t target, class TestType>
struct lower_alignment_helper
{
    typedef char type;
    enum { value = true };
};

template <std::size_t target, class TestType>
struct lower_alignment_helper<false,target,TestType>
{
    enum { value = (alignment_of<TestType>::value == target) };
    typedef typename mpl::if_c<value, TestType, char>::type type;
};
# 127 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
template <typename T>
struct has_one_T
{
  T data;
};

template <std::size_t target>
union lower_alignment
{
    enum { found0 = false };

    typename lower_alignment_helper< found0,target,char >::type t0; enum { found1 = lower_alignment_helper<found0,target,char >::value }; typename lower_alignment_helper< found1,target,short >::type t1; enum { found2 = lower_alignment_helper<found1,target,short >::value }; typename lower_alignment_helper< found2,target,int >::type t2; enum { found3 = lower_alignment_helper<found2,target,int >::value }; typename lower_alignment_helper< found3,target,long >::type t3; enum { found4 = lower_alignment_helper<found3,target,long >::value }; typename lower_alignment_helper< found4,target,::boost::long_long_type >::type t4; enum { found5 = lower_alignment_helper<found4,target,::boost::long_long_type >::value }; typename lower_alignment_helper< found5,target,float >::type t5; enum { found6 = lower_alignment_helper<found5,target,float >::value }; typename lower_alignment_helper< found6,target,double >::type t6; enum { found7 = lower_alignment_helper<found6,target,double >::value }; typename lower_alignment_helper< found7,target,long double >::type t7; enum { found8 = lower_alignment_helper<found7,target,long double >::value }; typename lower_alignment_helper< found8,target,void* >::type t8; enum { found9 = lower_alignment_helper<found8,target,void* >::value }; typename lower_alignment_helper< found9,target,function_ptr >::type t9; enum { found10 = lower_alignment_helper<found9,target,function_ptr >::value }; typename lower_alignment_helper< found10,target,member_ptr >::type t10; enum { found11 = lower_alignment_helper<found10,target,member_ptr >::value }; typename lower_alignment_helper< found11,target,member_function_ptr >::type t11; enum { found12 = lower_alignment_helper<found11,target,member_function_ptr >::value }; typename lower_alignment_helper< found12,target,boost::detail::has_one_T< char > >::type t12; enum { found13 = lower_alignment_helper<found12,target,boost::detail::has_one_T< char > >::value }; typename lower_alignment_helper< found13,target,boost::detail::has_one_T< short > >::type t13; enum { found14 = lower_alignment_helper<found13,target,boost::detail::has_one_T< short > >::value }; typename lower_alignment_helper< found14,target,boost::detail::has_one_T< int > >::type t14; enum { found15 = lower_alignment_helper<found14,target,boost::detail::has_one_T< int > >::value }; typename lower_alignment_helper< found15,target,boost::detail::has_one_T< long > >::type t15; enum { found16 = lower_alignment_helper<found15,target,boost::detail::has_one_T< long > >::value }; typename lower_alignment_helper< found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::type t16; enum { found17 = lower_alignment_helper<found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::value }; typename lower_alignment_helper< found17,target,boost::detail::has_one_T< float > >::type t17; enum { found18 = lower_alignment_helper<found17,target,boost::detail::has_one_T< float > >::value }; typename lower_alignment_helper< found18,target,boost::detail::has_one_T< double > >::type t18; enum { found19 = lower_alignment_helper<found18,target,boost::detail::has_one_T< double > >::value }; typename lower_alignment_helper< found19,target,boost::detail::has_one_T< long double > >::type t19; enum { found20 = lower_alignment_helper<found19,target,boost::detail::has_one_T< long double > >::value }; typename lower_alignment_helper< found20,target,boost::detail::has_one_T< void* > >::type t20; enum { found21 = lower_alignment_helper<found20,target,boost::detail::has_one_T< void* > >::value }; typename lower_alignment_helper< found21,target,boost::detail::has_one_T< function_ptr > >::type t21; enum { found22 = lower_alignment_helper<found21,target,boost::detail::has_one_T< function_ptr > >::value }; typename lower_alignment_helper< found22,target,boost::detail::has_one_T< member_ptr > >::type t22; enum { found23 = lower_alignment_helper<found22,target,boost::detail::has_one_T< member_ptr > >::value }; typename lower_alignment_helper< found23,target,boost::detail::has_one_T< member_function_ptr > >::type t23; enum { found24 = lower_alignment_helper<found23,target,boost::detail::has_one_T< member_function_ptr > >::value };




};

union max_align
{
    char t0; short t1; int t2; long t3; ::boost::long_long_type t4; float t5; double t6; long double t7; void* t8; function_ptr t9; member_ptr t10; member_function_ptr t11; boost::detail::has_one_T< char > t12; boost::detail::has_one_T< short > t13; boost::detail::has_one_T< int > t14; boost::detail::has_one_T< long > t15; boost::detail::has_one_T< ::boost::long_long_type > t16; boost::detail::has_one_T< float > t17; boost::detail::has_one_T< double > t18; boost::detail::has_one_T< long double > t19; boost::detail::has_one_T< void* > t20; boost::detail::has_one_T< function_ptr > t21; boost::detail::has_one_T< member_ptr > t22; boost::detail::has_one_T< member_function_ptr > t23;




};
# 161 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
template<std::size_t TAlign, std::size_t Align>
struct is_aligned
{
    static const bool value = (TAlign >= Align) & (TAlign % Align == 0);


};
# 180 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
}


template<std::size_t Align>
struct is_pod< ::boost::detail::lower_alignment<Align> >
{
        static const std::size_t value = true;
};




namespace detail{

template <std::size_t Align>
class type_with_alignment_imp
{
    typedef ::boost::detail::lower_alignment<Align> t1;
    typedef typename mpl::if_c<
          ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value
        , t1
        , ::boost::detail::max_align
        >::type align_t;

    static const std::size_t found = alignment_of<align_t>::value;

    static_assert(found >= Align, "found >= Align");
    static_assert(found % Align == 0, "found % Align == 0");

 public:
    typedef align_t type;
};

}

template <std::size_t Align>
class type_with_alignment
  : public ::boost::detail::type_with_alignment_imp<Align>
{
};


namespace align {
struct __attribute__((__aligned__(2))) a2 {};
struct __attribute__((__aligned__(4))) a4 {};
struct __attribute__((__aligned__(8))) a8 {};
struct __attribute__((__aligned__(16))) a16 {};
struct __attribute__((__aligned__(32))) a32 {};
}

template<> class type_with_alignment<1> { public: typedef char type; };
template<> class type_with_alignment<2> { public: typedef align::a2 type; };
template<> class type_with_alignment<4> { public: typedef align::a4 type; };
template<> class type_with_alignment<8> { public: typedef align::a8 type; };
template<> class type_with_alignment<16> { public: typedef align::a16 type; };
template<> class type_with_alignment<32> { public: typedef align::a32 type; };

namespace detail {
template<> struct is_pod_impl< ::boost::align::a2 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a4 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a8 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a16 > { static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a32 > { static const bool value = (true); };
}
# 383 "/usr/include/boost/type_traits/type_with_alignment.hpp" 3 4
}





# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 390 "/usr/include/boost/type_traits/type_with_alignment.hpp" 2 3 4
# 18 "/usr/include/boost/smart_ptr/make_shared.hpp" 2 3 4

# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 20 "/usr/include/boost/smart_ptr/make_shared.hpp" 2 3 4


namespace boost
{

namespace detail
{

template< std::size_t N, std::size_t A > struct sp_aligned_storage
{
    union type
    {
        char data_[ N ];
        typename boost::type_with_alignment< A >::type align_;
    };
};

template< class T > class sp_ms_deleter
{
private:

    typedef typename sp_aligned_storage< sizeof( T ), ::boost::alignment_of< T >::value >::type storage_type;

    bool initialized_;
    storage_type storage_;

private:

    void destroy()
    {
        if( initialized_ )
        {
            reinterpret_cast< T* >( storage_.data_ )->~T();
            initialized_ = false;
        }
    }

public:

    sp_ms_deleter(): initialized_( false )
    {
    }


    sp_ms_deleter( sp_ms_deleter const & ): initialized_( false )
    {
    }

    ~sp_ms_deleter()
    {
        destroy();
    }

    void operator()( T * )
    {
        destroy();
    }

    void * address()
    {
        return storage_.data_;
    }

    void set_initialized()
    {
        initialized_ = true;
    }
};

template< class T > T forward( T t )
{
    return t;
}

}





template< class T > boost::shared_ptr< T > make_shared()
{
    boost::shared_ptr< T > pt( static_cast< T* >( 0 ), detail::sp_ms_deleter< T >() );

    detail::sp_ms_deleter< T > * pd = boost::get_deleter< detail::sp_ms_deleter< T > >( pt );

    void * pv = pd->address();

    ::new( pv ) T();
    pd->set_initialized();

    T * pt2 = static_cast< T* >( pv );

    boost::detail::sp_enable_shared_from_this( &pt, pt2, pt2 );
    return boost::shared_ptr< T >( pt, pt2 );
}

template< class T, class A > boost::shared_ptr< T > allocate_shared( A const & a )
{
    boost::shared_ptr< T > pt( static_cast< T* >( 0 ), detail::sp_ms_deleter< T >(), a );

    detail::sp_ms_deleter< T > * pd = boost::get_deleter< detail::sp_ms_deleter< T > >( pt );

    void * pv = pd->address();

    ::new( pv ) T();
    pd->set_initialized();

    T * pt2 = static_cast< T* >( pv );

    boost::detail::sp_enable_shared_from_this( &pt, pt2, pt2 );
    return boost::shared_ptr< T >( pt, pt2 );
}





template< class T, class... Args > boost::shared_ptr< T > make_shared( Args && ... args )
{
    boost::shared_ptr< T > pt( static_cast< T* >( 0 ), detail::sp_ms_deleter< T >() );

    detail::sp_ms_deleter< T > * pd = boost::get_deleter< detail::sp_ms_deleter< T > >( pt );

    void * pv = pd->address();

    ::new( pv ) T( detail::forward<Args>( args )... );
    pd->set_initialized();

    T * pt2 = static_cast< T* >( pv );

    boost::detail::sp_enable_shared_from_this( &pt, pt2, pt2 );
    return boost::shared_ptr< T >( pt, pt2 );
}

template< class T, class A, class... Args > boost::shared_ptr< T > allocate_shared( A const & a, Args && ... args )
{
    boost::shared_ptr< T > pt( static_cast< T* >( 0 ), detail::sp_ms_deleter< T >(), a );

    detail::sp_ms_deleter< T > * pd = boost::get_deleter< detail::sp_ms_deleter< T > >( pt );

    void * pv = pd->address();

    ::new( pv ) T( detail::forward<Args>( args )... );
    pd->set_initialized();

    T * pt2 = static_cast< T* >( pv );

    boost::detail::sp_enable_shared_from_this( &pt, pt2, pt2 );
    return boost::shared_ptr< T >( pt, pt2 );
}
# 502 "/usr/include/boost/smart_ptr/make_shared.hpp" 3 4
}
# 16 "/usr/include/boost/make_shared.hpp" 2 3 4
# 36 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/boost/noncopyable.hpp" 1 3 4
# 12 "/usr/include/boost/noncopyable.hpp" 3 4
namespace boost {






namespace noncopyable_
{
  class noncopyable
  {
   protected:
      noncopyable() {}
      ~noncopyable() {}
   private:
      noncopyable( const noncopyable& );
      const noncopyable& operator=( const noncopyable& );
  };
}

typedef noncopyable_::noncopyable noncopyable;

}
# 37 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/boost/shared_ptr.hpp" 1 3 4
# 38 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/boost/version.hpp" 1 3 4
# 39 "/usr/include/cocaine/common.hpp" 2 3 4


# 1 "/usr/include/boost/unordered_map.hpp" 1 3 4
# 16 "/usr/include/boost/unordered_map.hpp" 3 4
# 1 "/usr/include/boost/unordered/unordered_map.hpp" 1 3 4
# 16 "/usr/include/boost/unordered/unordered_map.hpp" 3 4
# 1 "/usr/include/boost/unordered/unordered_map_fwd.hpp" 1 3 4
# 16 "/usr/include/boost/unordered/unordered_map_fwd.hpp" 3 4
# 1 "/usr/include/boost/functional/hash_fwd.hpp" 1 3 4





# 1 "/usr/include/boost/functional/hash/hash_fwd.hpp" 1 3 4
# 18 "/usr/include/boost/functional/hash/hash_fwd.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 19 "/usr/include/boost/functional/hash/hash_fwd.hpp" 2 3 4


namespace boost
{
    template <class T> struct hash;




    template <class T> void hash_combine(std::size_t& seed, T const& v);


    template <class It> std::size_t hash_range(It, It);
    template <class It> void hash_range(std::size_t&, It, It);





}
# 7 "/usr/include/boost/functional/hash_fwd.hpp" 2 3 4
# 17 "/usr/include/boost/unordered/unordered_map_fwd.hpp" 2 3 4

namespace boost
{
    template <class Key,
        class T,
        class Hash = hash<Key>,
        class Pred = std::equal_to<Key>,
        class Alloc = std::allocator<std::pair<const Key, T> > >
    class unordered_map;
    template <class K, class T, class H, class P, class A>
    bool operator==(unordered_map<K, T, H, P, A> const&,
        unordered_map<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    bool operator!=(unordered_map<K, T, H, P, A> const&,
        unordered_map<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    void swap(unordered_map<K, T, H, P, A>&,
            unordered_map<K, T, H, P, A>&);

    template <class Key,
        class T,
        class Hash = hash<Key>,
        class Pred = std::equal_to<Key>,
        class Alloc = std::allocator<std::pair<const Key, T> > >
    class unordered_multimap;
    template <class K, class T, class H, class P, class A>
    bool operator==(unordered_multimap<K, T, H, P, A> const&,
        unordered_multimap<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    bool operator!=(unordered_multimap<K, T, H, P, A> const&,
        unordered_multimap<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    void swap(unordered_multimap<K, T, H, P, A>&,
            unordered_multimap<K, T, H, P, A>&);
}
# 17 "/usr/include/boost/unordered/unordered_map.hpp" 2 3 4
# 1 "/usr/include/boost/functional/hash.hpp" 1 3 4





# 1 "/usr/include/boost/functional/hash/hash.hpp" 1 3 4
# 15 "/usr/include/boost/functional/hash/hash.hpp" 3 4
# 1 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 1 3 4
# 14 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 3 4
# 1 "/usr/include/boost/functional/hash/detail/float_functions.hpp" 1 3 4
# 10 "/usr/include/boost/functional/hash/detail/float_functions.hpp" 3 4
# 1 "/usr/include/boost/config/no_tr1/cmath.hpp" 1 3 4
# 21 "/usr/include/boost/config/no_tr1/cmath.hpp" 3 4
# 1 "/usr/include/c++/4.4/cmath" 1 3 4
# 41 "/usr/include/c++/4.4/cmath" 3 4
       
# 42 "/usr/include/c++/4.4/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 26 "/usr/include/bits/mathdef.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/mathdef.h" 2 3 4




typedef float float_t;
typedef double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 145 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 146 "/usr/include/math.h" 2 3 4
# 161 "/usr/include/math.h" 3 4
extern int signgam;
# 202 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 295 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 318 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 476 "/usr/include/math.h" 3 4
}
# 47 "/usr/include/c++/4.4/cmath" 2 3
# 77 "/usr/include/c++/4.4/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Tp>
    _Tp __cmath_power(_Tp, unsigned int);

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 381 "/usr/include/c++/4.4/cmath" 3
  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }

}
# 492 "/usr/include/c++/4.4/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
      FP_SUBNORMAL, FP_ZERO, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }

}





# 1 "/usr/include/c++/4.4/bits/cmath.tcc" 1 3
# 35 "/usr/include/c++/4.4/bits/cmath.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : _Tp(1);

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }

}
# 610 "/usr/include/c++/4.4/cmath" 2 3
# 623 "/usr/include/c++/4.4/cmath" 3
# 1 "/usr/include/c++/4.4/tr1_impl/cmath" 1 3
# 140 "/usr/include/c++/4.4/tr1_impl/cmath" 3
namespace std
{





  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;







  using std::signbit;

  using std::fpclassify;

  using std::isfinite;
  using std::isinf;
  using std::isnan;
  using std::isnormal;

  using std::isgreater;
  using std::isgreaterequal;
  using std::isless;
  using std::islessequal;
  using std::islessgreater;
  using std::isunordered;






  using std::acos;

  inline float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  inline long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    acosh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return acosh(__type(__x));
    }

  using std::asin;

  inline float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  inline long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    asinh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return asinh(__type(__x));
    }

  using std::atan;
  using std::atan2;

  inline float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  inline long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    atanh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return atanh(__type(__x));
    }

  inline float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  inline long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    cbrt(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return cbrt(__type(__x));
    }

  using std::ceil;

  inline float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  inline long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  using std::cos;
  using std::cosh;

  inline float
  erf(float __x)
  { return __builtin_erff(__x); }

  inline long double
  erf(long double __x)
  { return __builtin_erfl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    erf(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return erf(__type(__x));
    }

  inline float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  inline long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    erfc(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return erfc(__type(__x));
    }

  using std::exp;

  inline float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  inline long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    exp2(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return exp2(__type(__x));
    }

  inline float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  inline long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expm1(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return expm1(__type(__x));
    }

  using std::fabs;

  inline float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  inline long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  using std::floor;

  inline float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  inline long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }

  inline float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  inline long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  inline float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  inline long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  using std::fmod;
  using std::frexp;

  inline float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  inline long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  inline int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  inline int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }

  template<typename _Tp>
    inline int
    ilogb(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return ilogb(__type(__x));
    }

  using std::ldexp;

  inline float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  inline long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    lgamma(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lgamma(__type(__x));
    }

  inline long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  inline long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }

  template<typename _Tp>
    inline long long
    llrint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return llrint(__type(__x));
    }

  inline long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  inline long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }

  template<typename _Tp>
    inline long long
    llround(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return llround(__type(__x));
    }

  using std::log;
  using std::log10;

  inline float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  inline long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    log1p(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return log1p(__type(__x));
    }


  inline float
  log2(float __x)
  { return __builtin_log2f(__x); }

  inline long double
  log2(long double __x)
  { return __builtin_log2l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    log2(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return log2(__type(__x));
    }

  inline float
  logb(float __x)
  { return __builtin_logbf(__x); }

  inline long double
  logb(long double __x)
  { return __builtin_logbl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    logb(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return logb(__type(__x));
    }

  inline long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  inline long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }

  template<typename _Tp>
    inline long
    lrint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lrint(__type(__x));
    }

  inline long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  inline long
  lround(long double __x)
  { return __builtin_lroundl(__x); }

  template<typename _Tp>
    inline long
    lround(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lround(__type(__x));
    }

  inline float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  inline long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    nearbyint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return nearbyint(__type(__x));
    }

  inline float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  inline long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  inline float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  inline long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    nexttoward(_Tp __x, long double __y)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return nexttoward(__type(__x), __y);
    }





  inline float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  inline long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  inline float
  rint(float __x)
  { return __builtin_rintf(__x); }

  inline long double
  rint(long double __x)
  { return __builtin_rintl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    rint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return rint(__type(__x));
    }

  inline float
  round(float __x)
  { return __builtin_roundf(__x); }

  inline long double
  round(long double __x)
  { return __builtin_roundl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    round(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return round(__type(__x));
    }

  inline float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  inline long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    scalbln(_Tp __x, long __ex)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return scalbln(__type(__x), __ex);
    }

  inline float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  inline long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    scalbn(_Tp __x, int __ex)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return scalbn(__type(__x), __ex);
    }

  using std::sin;
  using std::sinh;
  using std::sqrt;
  using std::tan;
  using std::tanh;

  inline float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  inline long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    tgamma(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return tgamma(__type(__x));
    }

  inline float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  inline long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    trunc(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return trunc(__type(__x));
    }




}
# 624 "/usr/include/c++/4.4/cmath" 2 3
# 22 "/usr/include/boost/config/no_tr1/cmath.hpp" 2 3 4
# 11 "/usr/include/boost/functional/hash/detail/float_functions.hpp" 2 3 4
# 23 "/usr/include/boost/functional/hash/detail/float_functions.hpp" 3 4
namespace boost {
    namespace hash_detail {



        struct not_found {



            inline operator float() const { return 0; }
            inline operator long double() const { return 0; }
        };



        template <typename T> struct is;
        template <> struct is<float> { char x[10]; };
        template <> struct is<double> { char x[20]; };
        template <> struct is<long double> { char x[30]; };
        template <> struct is<boost::hash_detail::not_found> { char x[40]; };



        template <typename T> is<T> float_type(T);





        template <typename Float> struct call_ldexp
        {
            typedef double float_type;

            inline double operator()(double a, int b) const
            {
                using namespace std;
                return ldexp(a, b);
            }
        };





        template <typename Float> struct call_frexp
        {
            typedef double float_type;

            inline double operator()(double a, int* b) const
            {
                using namespace std;
                return frexp(a, b);
            }
        };
    }
}
# 87 "/usr/include/boost/functional/hash/detail/float_functions.hpp" 3 4
namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS {
    template <class Float> boost::hash_detail::not_found ldexp(Float, int);
    template <class Float> boost::hash_detail::not_found frexp(Float, int*);
}
# 188 "/usr/include/boost/functional/hash/detail/float_functions.hpp" 3 4
namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS { template <class Float> boost::hash_detail::not_found ldexpf(Float, int); } namespace boost { namespace hash_detail { namespace ldexpf_detect { using namespace std; using namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS; struct check { static float x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(ldexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_ldexpf : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexpf(a, b); } }; template <bool x> struct call_cpp_ldexpf : call_c99_ldexpf< ::boost::hash_detail::ldexpf_detect::check::c99 > {}; template <> struct call_cpp_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<float> : call_cpp_ldexpf< ::boost::hash_detail::ldexpf_detect::check::cpp > {}; } }





namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS { template <class Float> boost::hash_detail::not_found ldexpl(Float, int); } namespace boost { namespace hash_detail { namespace ldexpl_detect { using namespace std; using namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS; struct check { static long double x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(ldexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_ldexpl : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexpl(a, b); } }; template <bool x> struct call_cpp_ldexpl : call_c99_ldexpl< ::boost::hash_detail::ldexpl_detect::check::c99 > {}; template <> struct call_cpp_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<long double> : call_cpp_ldexpl< ::boost::hash_detail::ldexpl_detect::check::cpp > {}; } }





namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS { template <class Float> boost::hash_detail::not_found frexpf(Float, int*); } namespace boost { namespace hash_detail { namespace frexpf_detect { using namespace std; using namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS; struct check { static float x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(frexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_frexpf : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexpf(a, b); } }; template <bool x> struct call_cpp_frexpf : call_c99_frexpf< ::boost::hash_detail::frexpf_detect::check::c99 > {}; template <> struct call_cpp_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<float> : call_cpp_frexpf< ::boost::hash_detail::frexpf_detect::check::cpp > {}; } }





namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS { template <class Float> boost::hash_detail::not_found frexpl(Float, int*); } namespace boost { namespace hash_detail { namespace frexpl_detect { using namespace std; using namespace BOOST_HASH_DETECT_FLOAT_FUNCTIONS; struct check { static long double x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(frexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_frexpl : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexpl(a, b); } }; template <bool x> struct call_cpp_frexpl : call_c99_frexpl< ::boost::hash_detail::frexpl_detect::check::c99 > {}; template <> struct call_cpp_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<long double> : call_cpp_frexpl< ::boost::hash_detail::frexpl_detect::check::cpp > {}; } }






namespace boost
{
    namespace hash_detail
    {
        template <typename Float1, typename Float2>
        struct select_hash_type_impl {
            typedef double type;
        };

        template <>
        struct select_hash_type_impl<float, float> {
            typedef float type;
        };

        template <>
        struct select_hash_type_impl<long double, long double> {
            typedef long double type;
        };







        template <typename Float>
        struct select_hash_type : select_hash_type_impl<
                typename call_ldexp<Float>::float_type,
                typename call_frexp<Float>::float_type
            > {};
    }
}
# 15 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 2 3 4
# 1 "/usr/include/boost/functional/hash/detail/limits.hpp" 1 3 4
# 16 "/usr/include/boost/functional/hash/detail/limits.hpp" 3 4
# 1 "/usr/include/boost/limits.hpp" 1 3 4
# 19 "/usr/include/boost/limits.hpp" 3 4
# 1 "/usr/include/c++/4.4/limits" 1 3 4
# 41 "/usr/include/c++/4.4/limits" 3 4
       
# 42 "/usr/include/c++/4.4/limits" 3
# 146 "/usr/include/c++/4.4/limits" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 188 "/usr/include/c++/4.4/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;



    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 277 "/usr/include/c++/4.4/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };





  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static const bool is_specialized = true;

      static char16_t min() throw()
      { return (((char16_t)(-1) < 0) ? (char16_t)1 << (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) : (char16_t)0); }
      static char16_t max() throw()
      { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static const int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static const int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char16_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char16_t epsilon() throw()
      { return 0; }
      static char16_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char16_t infinity() throw()
      { return char16_t(); }
      static char16_t quiet_NaN() throw()
      { return char16_t(); }
      static char16_t signaling_NaN() throw()
      { return char16_t(); }
      static char16_t denorm_min() throw()
      { return char16_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static const bool is_specialized = true;

      static char32_t min() throw()
      { return (((char32_t)(-1) < 0) ? (char32_t)1 << (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) : (char32_t)0); }
      static char32_t max() throw()
      { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static const int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static const int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char32_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char32_t epsilon() throw()
      { return 0; }
      static char32_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char32_t infinity() throw()
      { return char32_t(); }
      static char32_t quiet_NaN() throw()
      { return char32_t(); }
      static char32_t signaling_NaN() throw()
      { return char32_t(); }
      static char32_t denorm_min() throw()
      { return char32_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -9223372036854775807L - 1; }
      static long max() throw()
      { return 9223372036854775807L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 9223372036854775807L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 20 "/usr/include/boost/limits.hpp" 2 3 4
# 17 "/usr/include/boost/functional/hash/detail/limits.hpp" 2 3 4
# 26 "/usr/include/boost/functional/hash/detail/limits.hpp" 3 4
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        struct limits : std::numeric_limits<T> {};
# 58 "/usr/include/boost/functional/hash/detail/limits.hpp" 3 4
    }
}
# 16 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 2 3 4
# 1 "/usr/include/boost/integer/static_log2.hpp" 1 3 4
# 21 "/usr/include/boost/integer/static_log2.hpp" 3 4
namespace boost {

 namespace detail {

     namespace static_log2_impl {
# 44 "/usr/include/boost/integer/static_log2.hpp" 3 4
     typedef unsigned long argument_type;
     typedef int result_type;


     template <result_type n>
     struct choose_initial_n {

         static const bool c = (argument_type(1) << n << n) != 0;
         static const result_type value = !c*n + choose_initial_n<2*c*n>::value;




     };

     template <>
     struct choose_initial_n<0> {
         static const result_type value = 0;
     };




     const result_type n_zero = 16;
     const result_type initial_n = choose_initial_n<n_zero>::value;
# 85 "/usr/include/boost/integer/static_log2.hpp" 3 4
     template <argument_type x, result_type n = initial_n>
     struct static_log2_impl {

         static const bool c = (x >> n) > 0;
         static const result_type value = c*n + (static_log2_impl< (x>>c*n), n/2 >::value);




     };

     template <>
     struct static_log2_impl<1, 0> {
        static const result_type value = 0;
     };

     }
 }







 typedef detail::static_log2_impl::argument_type static_log2_argument_type;
 typedef detail::static_log2_impl::result_type static_log2_result_type;


 template <static_log2_argument_type x>
 struct static_log2 {

     static const static_log2_result_type value = detail::static_log2_impl::static_log2_impl<x>::value;




 };


 template <>
 struct static_log2<0> { };

}
# 17 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 2 3 4
# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 85 "/usr/include/boost/cstdint.hpp" 3 4
namespace boost
{

  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;

  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;

  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;



  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;



  using ::intmax_t;
  using ::uintmax_t;

}
# 18 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 2 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 19 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 2 3 4
# 30 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 3 4
# 1 "/usr/include/boost/functional/hash/detail/hash_float_generic.hpp" 1 3 4
# 27 "/usr/include/boost/functional/hash/detail/hash_float_generic.hpp" 3 4
namespace boost
{
    namespace hash_detail
    {
        inline void hash_float_combine(std::size_t& seed, std::size_t value)
        {
            seed ^= value + (seed<<6) + (seed>>2);
        }

        template <class T>
        inline std::size_t float_hash_impl2(T v)
        {
            boost::hash_detail::call_frexp<T> frexp;
            boost::hash_detail::call_ldexp<T> ldexp;

            int exp = 0;

            v = frexp(v, &exp);



            if(v < 0) {
                v = -v;
                exp += limits<T>::max_exponent -
                    limits<T>::min_exponent;
            }



            v -= T(0.5);
            v = ldexp(v, limits<std::size_t>::digits + 1);
            std::size_t seed = static_cast<std::size_t>(v);
            v -= seed;


            std::size_t const length
                = (limits<T>::digits *
                        boost::static_log2<limits<T>::radix>::value - 1)
                / limits<std::size_t>::digits;

            for(std::size_t i = 0; i != length; ++i)
            {
                v = ldexp(v, limits<std::size_t>::digits);
                std::size_t part = static_cast<std::size_t>(v);
                v -= part;
                hash_float_combine(seed, part);
            }

            hash_float_combine(seed, exp);

            return seed;
        }

        template <class T>
        inline std::size_t float_hash_impl(T v)
        {
            typedef typename select_hash_type<T>::type type;
            return float_hash_impl2(static_cast<type>(v));
        }
    }
}
# 31 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 2 3 4
# 57 "/usr/include/boost/functional/hash/detail/hash_float.hpp" 3 4
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        inline std::size_t float_hash_value(T v)
        {
            using namespace std;
            switch (fpclassify(v)) {
            case FP_ZERO:
                return 0;
            case FP_INFINITE:
                return (std::size_t)(v > 0 ? -1 : -2);
            case FP_NAN:
                return (std::size_t)(-3);
            case FP_NORMAL:
            case FP_SUBNORMAL:
                return float_hash_impl(v);
            default:
                ((0) ? static_cast<void> (0) : __assert_fail ("0", "/usr/include/boost/functional/hash/detail/hash_float.hpp", 76, __PRETTY_FUNCTION__));
                return 0;
            }
        }
    }
}
# 16 "/usr/include/boost/functional/hash/hash.hpp" 2 3 4
# 29 "/usr/include/boost/functional/hash/hash.hpp" 3 4
namespace boost
{
    std::size_t hash_value(bool);
    std::size_t hash_value(char);
    std::size_t hash_value(unsigned char);
    std::size_t hash_value(signed char);
    std::size_t hash_value(short);
    std::size_t hash_value(unsigned short);
    std::size_t hash_value(int);
    std::size_t hash_value(unsigned int);
    std::size_t hash_value(long);
    std::size_t hash_value(unsigned long);


    std::size_t hash_value(wchar_t);



    std::size_t hash_value(boost::long_long_type);
    std::size_t hash_value(boost::ulong_long_type);



    template <class T> std::size_t hash_value(T* const&);





    template< class T, unsigned N >
    std::size_t hash_value(const T (&x)[N]);

    template< class T, unsigned N >
    std::size_t hash_value(T (&x)[N]);


    std::size_t hash_value(float v);
    std::size_t hash_value(double v);
    std::size_t hash_value(long double v);

    template <class Ch, class A>
    std::size_t hash_value(std::basic_string<Ch, std::char_traits<Ch>, A> const&);



    namespace hash_detail
    {
        template <class T>
        inline std::size_t hash_value_signed(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;
             T positive = val < 0 ? -1 - val : val;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (positive >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }

        template <class T>
        inline std::size_t hash_value_unsigned(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;

             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;

             std::size_t seed = 0;


             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (val >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);

             return seed;
        }
    }

    inline std::size_t hash_value(bool v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(signed char v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(short v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned short v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(int v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned int v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(long v)
    {
        return static_cast<std::size_t>(v);
    }

    inline std::size_t hash_value(unsigned long v)
    {
        return static_cast<std::size_t>(v);
    }


    inline std::size_t hash_value(wchar_t v)
    {
        return static_cast<std::size_t>(v);
    }



    inline std::size_t hash_value(boost::long_long_type v)
    {
        return hash_detail::hash_value_signed(v);
    }

    inline std::size_t hash_value(boost::ulong_long_type v)
    {
        return hash_detail::hash_value_unsigned(v);
    }




    template <class T> std::size_t hash_value(T* const& v)



    {
        std::size_t x = static_cast<std::size_t>(
           reinterpret_cast<std::ptrdiff_t>(v));

        return x + (x >> 3);
    }





    template <class T>
    inline void hash_combine(std::size_t& seed, T const& v)

    {
        boost::hash<T> hasher;
        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }

    template <class It>
    inline std::size_t hash_range(It first, It last)
    {
        std::size_t seed = 0;

        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }

        return seed;
    }

    template <class It>
    inline void hash_range(std::size_t& seed, It first, It last)
    {
        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }
    }
# 261 "/usr/include/boost/functional/hash/hash.hpp" 3 4
    template< class T, unsigned N >
    inline std::size_t hash_value(const T (&x)[N])
    {
        return hash_range(x, x + N);
    }

    template< class T, unsigned N >
    inline std::size_t hash_value(T (&x)[N])
    {
        return hash_range(x, x + N);
    }


    template <class Ch, class A>
    inline std::size_t hash_value(std::basic_string<Ch, std::char_traits<Ch>, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    inline std::size_t hash_value(float v)
    {
        return boost::hash_detail::float_hash_value(v);
    }

    inline std::size_t hash_value(double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }

    inline std::size_t hash_value(long double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }
# 371 "/usr/include/boost/functional/hash/hash.hpp" 3 4
    template <> struct hash<bool> : public std::unary_function<bool, std::size_t> { std::size_t operator()(bool v) const { return boost::hash_value(v); } };
    template <> struct hash<char> : public std::unary_function<char, std::size_t> { std::size_t operator()(char v) const { return boost::hash_value(v); } };
    template <> struct hash<signed char> : public std::unary_function<signed char, std::size_t> { std::size_t operator()(signed char v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned char> : public std::unary_function<unsigned char, std::size_t> { std::size_t operator()(unsigned char v) const { return boost::hash_value(v); } };

    template <> struct hash<wchar_t> : public std::unary_function<wchar_t, std::size_t> { std::size_t operator()(wchar_t v) const { return boost::hash_value(v); } };

    template <> struct hash<short> : public std::unary_function<short, std::size_t> { std::size_t operator()(short v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned short> : public std::unary_function<unsigned short, std::size_t> { std::size_t operator()(unsigned short v) const { return boost::hash_value(v); } };
    template <> struct hash<int> : public std::unary_function<int, std::size_t> { std::size_t operator()(int v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned int> : public std::unary_function<unsigned int, std::size_t> { std::size_t operator()(unsigned int v) const { return boost::hash_value(v); } };
    template <> struct hash<long> : public std::unary_function<long, std::size_t> { std::size_t operator()(long v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned long> : public std::unary_function<unsigned long, std::size_t> { std::size_t operator()(unsigned long v) const { return boost::hash_value(v); } };

    template <> struct hash<float> : public std::unary_function<float, std::size_t> { std::size_t operator()(float v) const { return boost::hash_value(v); } };
    template <> struct hash<double> : public std::unary_function<double, std::size_t> { std::size_t operator()(double v) const { return boost::hash_value(v); } };
    template <> struct hash<long double> : public std::unary_function<long double, std::size_t> { std::size_t operator()(long double v) const { return boost::hash_value(v); } };

    template <> struct hash<std::string> : public std::unary_function<std::string, std::size_t> { std::size_t operator()(std::string const& v) const { return boost::hash_value(v); } };

    template <> struct hash<std::wstring> : public std::unary_function<std::wstring, std::size_t> { std::size_t operator()(std::wstring const& v) const { return boost::hash_value(v); } };



    template <> struct hash<boost::long_long_type> : public std::unary_function<boost::long_long_type, std::size_t> { std::size_t operator()(boost::long_long_type v) const { return boost::hash_value(v); } };
    template <> struct hash<boost::ulong_long_type> : public std::unary_function<boost::ulong_long_type, std::size_t> { std::size_t operator()(boost::ulong_long_type v) const { return boost::hash_value(v); } };
# 406 "/usr/include/boost/functional/hash/hash.hpp" 3 4
    template <class T>
    struct hash<T*>
        : public std::unary_function<T*, std::size_t>
    {
        std::size_t operator()(T* v) const
        {

            return boost::hash_value(v);






        }
    };
# 465 "/usr/include/boost/functional/hash/hash.hpp" 3 4
}
# 477 "/usr/include/boost/functional/hash/hash.hpp" 3 4
# 1 "/usr/include/boost/functional/hash/extensions.hpp" 1 3 4
# 16 "/usr/include/boost/functional/hash/extensions.hpp" 3 4
# 1 "/usr/include/boost/functional/hash/hash.hpp" 1 3 4
# 17 "/usr/include/boost/functional/hash/extensions.hpp" 2 3 4
# 1 "/usr/include/boost/detail/container_fwd.hpp" 1 3 4
# 32 "/usr/include/boost/detail/container_fwd.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 33 "/usr/include/boost/detail/container_fwd.hpp" 2 3 4
# 58 "/usr/include/boost/detail/container_fwd.hpp" 3 4
namespace std
{
    template <class T> class allocator;
    template <class charT, class traits, class Allocator> class basic_string;




    template <class charT> struct char_traits;


    template <class T> class complex;
}


namespace std
{

    template <class T, class Allocator> class deque;


    template <class T, class Allocator> class list;
    template <class T, class Allocator> class vector;
    template <class Key, class T, class Compare, class Allocator> class map;
    template <class Key, class T, class Compare, class Allocator>
    class multimap;
    template <class Key, class Compare, class Allocator> class set;
    template <class Key, class Compare, class Allocator> class multiset;


    template <size_t N> class bitset;

    template <class T1, class T2> struct pair;
}
# 18 "/usr/include/boost/functional/hash/extensions.hpp" 2 3 4
# 31 "/usr/include/boost/functional/hash/extensions.hpp" 3 4
namespace boost
{
    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const&);
    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const&);
    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v);
    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v);

    template <class T>
    std::size_t hash_value(std::complex<T> const&);

    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const& v)
    {
        std::size_t seed = 0;
        hash_combine(seed, v.first);
        hash_combine(seed, v.second);
        return seed;
    }

    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }

    template <class T>
    std::size_t hash_value(std::complex<T> const& v)
    {
        boost::hash<T> hasher;
        std::size_t seed = hasher(v.imag());
        seed ^= hasher(v.real()) + (seed<<6) + (seed>>2);
        return seed;
    }
# 170 "/usr/include/boost/functional/hash/extensions.hpp" 3 4
    template <class T> struct hash
        : std::unary_function<T, std::size_t>
    {

        std::size_t operator()(T const& val) const
        {
            return hash_value(val);
        }






    };
# 284 "/usr/include/boost/functional/hash/extensions.hpp" 3 4
}
# 478 "/usr/include/boost/functional/hash/hash.hpp" 2 3 4
# 7 "/usr/include/boost/functional/hash.hpp" 2 3 4
# 18 "/usr/include/boost/unordered/unordered_map.hpp" 2 3 4
# 1 "/usr/include/boost/unordered/detail/hash_table.hpp" 1 3 4
# 15 "/usr/include/boost/unordered/detail/hash_table.hpp" 3 4
# 1 "/usr/include/boost/unordered/detail/config.hpp" 1 3 4
# 16 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4





# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 22 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4



# 1 "/usr/include/c++/4.4/stdexcept" 1 3 4
# 36 "/usr/include/c++/4.4/stdexcept" 3 4
       
# 37 "/usr/include/c++/4.4/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 53 "/usr/include/c++/4.4/stdexcept" 3
  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual
    ~logic_error() throw();



    virtual const char*
    what() const throw();
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual
    ~runtime_error() throw();



    virtual const char*
    what() const throw();
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
  };



}
# 26 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4

# 1 "/usr/include/boost/iterator.hpp" 1 3 4
# 17 "/usr/include/boost/iterator.hpp" 3 4
# 1 "/usr/include/c++/4.4/iterator" 1 3 4
# 58 "/usr/include/c++/4.4/iterator" 3 4
       
# 59 "/usr/include/c++/4.4/iterator" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 62 "/usr/include/c++/4.4/iterator" 2 3



# 1 "/usr/include/c++/4.4/ostream" 1 3
# 38 "/usr/include/c++/4.4/ostream" 3
       
# 39 "/usr/include/c++/4.4/ostream" 3

# 1 "/usr/include/c++/4.4/ios" 1 3
# 37 "/usr/include/c++/4.4/ios" 3
       
# 38 "/usr/include/c++/4.4/ios" 3





# 1 "/usr/include/c++/4.4/bits/ios_base.h" 1 3
# 39 "/usr/include/c++/4.4/bits/ios_base.h" 3
       
# 40 "/usr/include/c++/4.4/bits/ios_base.h" 3



# 1 "/usr/include/c++/4.4/bits/locale_classes.h" 1 3
# 39 "/usr/include/c++/4.4/bits/locale_classes.h" 3
       
# 40 "/usr/include/c++/4.4/bits/locale_classes.h" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 61 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 97 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 116 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale() throw();
# 125 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 135 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 150 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 163 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 175 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 189 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 204 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 223 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 251 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 267 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 302 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 335 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 366 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 426 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 569 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
# 586 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 603 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 630 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 644 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 661 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 680 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 694 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 723 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 739 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 752 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };

}


# 1 "/usr/include/c++/4.4/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/4.4/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/4.4/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }





  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);



}
# 810 "/usr/include/c++/4.4/bits/locale_classes.h" 2 3
# 44 "/usr/include/c++/4.4/bits/ios_base.h" 2 3
# 54 "/usr/include/c++/4.4/bits/ios_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 207 "/usr/include/c++/4.4/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 263 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 338 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 369 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 401 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 427 "/usr/include/c++/4.4/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 444 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 456 "/usr/include/c++/4.4/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:




    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 565 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 581 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 598 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 624 "/usr/include/c++/4.4/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 675 "/usr/include/c++/4.4/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 687 "/usr/include/c++/4.4/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 698 "/usr/include/c++/4.4/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 709 "/usr/include/c++/4.4/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 728 "/usr/include/c++/4.4/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 744 "/usr/include/c++/4.4/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 765 "/usr/include/c++/4.4/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 782 "/usr/include/c++/4.4/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 44 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/streambuf" 1 3
# 37 "/usr/include/c++/4.4/streambuf" 3
       
# 38 "/usr/include/c++/4.4/streambuf" 3
# 46 "/usr/include/c++/4.4/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 113 "/usr/include/c++/4.4/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 179 "/usr/include/c++/4.4/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 203 "/usr/include/c++/4.4/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 220 "/usr/include/c++/4.4/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 233 "/usr/include/c++/4.4/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 260 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 274 "/usr/include/c++/4.4/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 292 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 314 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 333 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 347 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 372 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 399 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 425 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 439 "/usr/include/c++/4.4/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 457 "/usr/include/c++/4.4/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 473 "/usr/include/c++/4.4/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 484 "/usr/include/c++/4.4/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 504 "/usr/include/c++/4.4/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 520 "/usr/include/c++/4.4/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 530 "/usr/include/c++/4.4/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 551 "/usr/include/c++/4.4/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 566 "/usr/include/c++/4.4/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 577 "/usr/include/c++/4.4/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 589 "/usr/include/c++/4.4/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 602 "/usr/include/c++/4.4/streambuf" 3
      virtual int
      sync() { return 0; }
# 624 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 640 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 662 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 675 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 699 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 717 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 742 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 757 "/usr/include/c++/4.4/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}


# 1 "/usr/include/c++/4.4/bits/streambuf.tcc" 1 3
# 38 "/usr/include/c++/4.4/bits/streambuf.tcc" 3
       
# 39 "/usr/include/c++/4.4/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 797 "/usr/include/c++/4.4/streambuf" 2 3
# 45 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/bits/basic_ios.h" 1 3
# 35 "/usr/include/c++/4.4/bits/basic_ios.h" 3
       
# 36 "/usr/include/c++/4.4/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.4/bits/locale_facets.h" 1 3
# 39 "/usr/include/c++/4.4/bits/locale_facets.h" 3
       
# 40 "/usr/include/c++/4.4/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.4/cwctype" 1 3
# 41 "/usr/include/c++/4.4/cwctype" 3
       
# 42 "/usr/include/c++/4.4/cwctype" 3




# 1 "/usr/include/wctype.h" 1 3 4
# 34 "/usr/include/wctype.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/wctype.h" 2 3 4
# 50 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 72 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 172 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 214 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 47 "/usr/include/c++/4.4/cwctype" 2 3
# 76 "/usr/include/c++/4.4/cwctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 118 "/usr/include/c++/4.4/cwctype" 3
# 1 "/usr/include/c++/4.4/tr1_impl/cwctype" 1 3
# 32 "/usr/include/c++/4.4/tr1_impl/cwctype" 3
namespace std
{



  using std::iswblank;



}
# 119 "/usr/include/c++/4.4/cwctype" 2 3
# 42 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.4/cctype" 1 3
# 41 "/usr/include/c++/4.4/cctype" 3
       
# 42 "/usr/include/c++/4.4/cctype" 3
# 43 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_base.h" 1 3
# 37 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };

}
# 44 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 1 3
# 35 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 3
       
# 36 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {
 ;


 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {
 ;



 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

}
# 51 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 64 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 143 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 462 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 495 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 535 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 557 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 581 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 604 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 751 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1021 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1054 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1149 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;


      virtual
      ~ctype();
# 1242 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1261 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1331 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1364 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1406 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1429 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1455 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


}


# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

}
# 1511 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1635 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1672 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1686 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1700 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1713 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1744 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1757 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1770 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1787 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1799 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1812 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1825 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1838 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


# 1907 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1928 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1954 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1990 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2049 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2162 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2227 "/usr/include/c++/4.4/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2244 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2265 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2283 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2325 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2388 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2413 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2461 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}


# 1 "/usr/include/c++/4.4/bits/locale_facets.tcc" 1 3
# 35 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
       
# 36 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(_M_grouping[0]) > 0
    && (_M_grouping[0]
        != __gnu_cxx::__numeric_traits<char>::__max));

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
# 121 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 715 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 951 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1012 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1137 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1174 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);



}
# 2600 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 40 "/usr/include/c++/4.4/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 61 "/usr/include/c++/4.4/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 126 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 137 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 190 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 211 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 246 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 284 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 296 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 336 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 350 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 379 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 399 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 419 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 438 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}


# 1 "/usr/include/c++/4.4/bits/basic_ios.tcc" 1 3
# 34 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3
       
# 35 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 145 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 472 "/usr/include/c++/4.4/bits/basic_ios.h" 2 3
# 46 "/usr/include/c++/4.4/ios" 2 3
# 41 "/usr/include/c++/4.4/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 54 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 81 "/usr/include/c++/4.4/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 164 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 249 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 282 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 310 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 323 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      flush();
# 334 "/usr/include/c++/4.4/ostream" 3
      pos_type
      tellp();
# 345 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 357 "/usr/include/c++/4.4/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 376 "/usr/include/c++/4.4/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 395 "/usr/include/c++/4.4/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 405 "/usr/include/c++/4.4/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 423 "/usr/include/c++/4.4/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 444 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 486 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 536 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}


# 1 "/usr/include/c++/4.4/bits/ostream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/ostream.tcc" 3
       
# 40 "/usr/include/c++/4.4/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 566 "/usr/include/c++/4.4/ostream" 2 3
# 66 "/usr/include/c++/4.4/iterator" 2 3
# 1 "/usr/include/c++/4.4/istream" 1 3
# 38 "/usr/include/c++/4.4/istream" 3
       
# 39 "/usr/include/c++/4.4/istream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 54 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 90 "/usr/include/c++/4.4/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 118 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 237 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 247 "/usr/include/c++/4.4/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 279 "/usr/include/c++/4.4/istream" 3
      int_type
      get();
# 293 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type& __c);
# 320 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 331 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 354 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 364 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 393 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 404 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 428 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 445 "/usr/include/c++/4.4/istream" 3
      int_type
      peek();
# 463 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 482 "/usr/include/c++/4.4/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 498 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      putback(char_type __c);
# 513 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      unget();
# 531 "/usr/include/c++/4.4/istream" 3
      int
      sync();
# 545 "/usr/include/c++/4.4/istream" 3
      pos_type
      tellg();
# 560 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      seekg(pos_type);
# 576 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 631 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 663 "/usr/include/c++/4.4/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 673 "/usr/include/c++/4.4/istream" 3
      operator bool() const
      { return _M_ok; }

    private:
      bool _M_ok;
    };
# 693 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 734 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 762 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 823 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}


# 1 "/usr/include/c++/4.4/bits/istream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/istream.tcc" 3
       
# 40 "/usr/include/c++/4.4/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<short>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<short>::__max)
     __n = short(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<int>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<int>::__max)
     __n = int(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 463 "/usr/include/c++/4.4/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 831 "/usr/include/c++/4.4/istream" 2 3
# 67 "/usr/include/c++/4.4/iterator" 2 3
# 1 "/usr/include/c++/4.4/bits/stream_iterator.h" 1 3
# 33 "/usr/include/c++/4.4/bits/stream_iterator.h" 3
       
# 34 "/usr/include/c++/4.4/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {
 ;


 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {
 ;


 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {
 ;


 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 145 "/usr/include/c++/4.4/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 176 "/usr/include/c++/4.4/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {
 ;


 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };

}
# 68 "/usr/include/c++/4.4/iterator" 2 3
# 18 "/usr/include/boost/iterator.hpp" 2 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 19 "/usr/include/boost/iterator.hpp" 2 3 4


namespace boost
{
# 39 "/usr/include/boost/iterator.hpp" 3 4
  namespace detail {
   template <class Category, class T, class Distance, class Pointer, class Reference>

   struct iterator_base : std::iterator<Category, T, Distance, Pointer, Reference> {};
# 51 "/usr/include/boost/iterator.hpp" 3 4
  }

  template <class Category, class T, class Distance = std::ptrdiff_t,
            class Pointer = T*, class Reference = T&>
  struct iterator : boost::detail::iterator_base<Category, T, Distance, Pointer, Reference> {};

}
# 28 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4
# 1 "/usr/include/boost/iterator/iterator_categories.hpp" 1 3 4
# 10 "/usr/include/boost/iterator/iterator_categories.hpp" 3 4
# 1 "/usr/include/boost/detail/iterator.hpp" 1 3 4
# 77 "/usr/include/boost/detail/iterator.hpp" 3 4
namespace boost { namespace detail {


template <class Iterator>
struct iterator_traits
    : std::iterator_traits<Iterator>
{};
using std::distance;

}}
# 11 "/usr/include/boost/iterator/iterator_categories.hpp" 2 3 4
# 1 "/usr/include/boost/iterator/detail/config_def.hpp" 1 3 4
# 12 "/usr/include/boost/iterator/iterator_categories.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/eval_if.hpp" 1 3 4
# 24 "/usr/include/boost/mpl/eval_if.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if




{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;




   
};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c




{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;




};

template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }

}}
# 16 "/usr/include/boost/iterator/iterator_categories.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/identity.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/identity.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename T = na
    >
struct identity
{
    typedef T type;
   
};

template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;
   
};

template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }

}}
# 17 "/usr/include/boost/iterator/iterator_categories.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/placeholders.hpp" 1 3 4
# 24 "/usr/include/boost/mpl/placeholders.hpp" 3 4
# 1 "/usr/include/boost/mpl/arg.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/arg.hpp" 3 4
# 1 "/usr/include/boost/mpl/arg_fwd.hpp" 1 3 4
# 21 "/usr/include/boost/mpl/arg_fwd.hpp" 3 4
namespace mpl_ {

template< int N > struct arg;

}
namespace boost { namespace mpl { using ::mpl_::arg; } }
# 24 "/usr/include/boost/mpl/arg.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/na_assert.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/aux_/na_assert.hpp" 3 4
# 1 "/usr/include/boost/mpl/assert.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/assert.hpp" 3 4
# 1 "/usr/include/boost/mpl/not.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/not.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/nested_type_wknd.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/aux_/nested_type_wknd.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
# 20 "/usr/include/boost/mpl/not.hpp" 2 3 4



namespace boost { namespace mpl {

namespace aux {

template< long C_ >
struct not_impl
    : bool_<!C_>
{
};

}


template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{
   
};

template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }

}}
# 18 "/usr/include/boost/mpl/assert.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/yes_no.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/yes_no.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/arrays.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/yes_no.hpp" 2 3 4




namespace boost { namespace mpl { namespace aux {

typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];

template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};

template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};


template< long n > struct weighted_tag
{

    typedef char (&type)[n];




};
# 56 "/usr/include/boost/mpl/aux_/yes_no.hpp" 3 4
}}}
# 21 "/usr/include/boost/mpl/assert.hpp" 2 3 4
# 29 "/usr/include/boost/mpl/assert.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/pp_counter.hpp" 1 3 4
# 30 "/usr/include/boost/mpl/assert.hpp" 2 3 4





# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 36 "/usr/include/boost/mpl/assert.hpp" 2 3 4
# 62 "/usr/include/boost/mpl/assert.hpp" 3 4
namespace mpl_ {

struct failed {};
# 75 "/usr/include/boost/mpl/assert.hpp" 3 4
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };

template< bool C >
int assertion_failed( typename assert<C>::type );

template< bool C >
struct assertion
{
    static int failed( assert<false> );
};

template<>
struct assertion<true>
{
    static int failed( void* );
};

struct assert_
{

    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};

    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
# 123 "/usr/include/boost/mpl/assert.hpp" 3 4
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );

template< assert_::relations r, long x, long y > struct assert_relation {};






template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };

template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};

template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};

template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );

template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );

template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );

template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
# 212 "/usr/include/boost/mpl/assert.hpp" 3 4
}
# 24 "/usr/include/boost/mpl/aux_/na_assert.hpp" 2 3 4
# 26 "/usr/include/boost/mpl/arg.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/arity_spec.hpp" 1 3 4
# 27 "/usr/include/boost/mpl/arg.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/arg_typedef.hpp" 1 3 4
# 28 "/usr/include/boost/mpl/arg.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/aux_/config/use_preprocessed.hpp" 1 3 4
# 32 "/usr/include/boost/mpl/arg.hpp" 2 3 4





# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 16 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/compiler.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4



# 1 "/usr/include/boost/preprocessor/stringize.hpp" 1 3 4
# 21 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 1 3 4
# 13 "/usr/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp" 3 4
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;
   
   

    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};



}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 38 "/usr/include/boost/mpl/arg.hpp" 2 3 4
# 25 "/usr/include/boost/mpl/placeholders.hpp" 2 3 4
# 43 "/usr/include/boost/mpl/placeholders.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 1 3 4
# 13 "/usr/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp" 3 4
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {

using ::mpl_::_;

namespace placeholders {
using mpl_::_;
}

}}



namespace mpl_ {
typedef arg<1> _1;

}
namespace boost { namespace mpl {

using ::mpl_::_1;

namespace placeholders {
using mpl_::_1;
}

}}
namespace mpl_ {
typedef arg<2> _2;

}
namespace boost { namespace mpl {

using ::mpl_::_2;

namespace placeholders {
using mpl_::_2;
}

}}
namespace mpl_ {
typedef arg<3> _3;

}
namespace boost { namespace mpl {

using ::mpl_::_3;

namespace placeholders {
using mpl_::_3;
}

}}
namespace mpl_ {
typedef arg<4> _4;

}
namespace boost { namespace mpl {

using ::mpl_::_4;

namespace placeholders {
using mpl_::_4;
}

}}
namespace mpl_ {
typedef arg<5> _5;

}
namespace boost { namespace mpl {

using ::mpl_::_5;

namespace placeholders {
using mpl_::_5;
}

}}
namespace mpl_ {
typedef arg<6> _6;

}
namespace boost { namespace mpl {

using ::mpl_::_6;

namespace placeholders {
using mpl_::_6;
}

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 44 "/usr/include/boost/mpl/placeholders.hpp" 2 3 4
# 18 "/usr/include/boost/iterator/iterator_categories.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/is_convertible.hpp" 1 3 4
# 17 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/yes_no_type.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/yes_no_type.hpp" 3 4
namespace boost {
namespace type_traits {

typedef char yes_type;
struct no_type
{
   char padding[8];
};

}
}
# 18 "/usr/include/boost/type_traits/is_convertible.hpp" 2 3 4

# 1 "/usr/include/boost/type_traits/is_array.hpp" 1 3 4
# 24 "/usr/include/boost/type_traits/is_array.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 25 "/usr/include/boost/type_traits/is_array.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 28 "/usr/include/boost/type_traits/is_array.hpp" 2 3 4

namespace boost {




template< typename T > struct is_array : ::boost::integral_constant<bool,false> { };

template< typename T, std::size_t N > struct is_array< T[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T volatile[N] > : ::boost::integral_constant<bool,true> { };
template< typename T, std::size_t N > struct is_array< T const volatile[N] > : ::boost::integral_constant<bool,true> { };

template< typename T > struct is_array< T[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T volatile[] > : ::boost::integral_constant<bool,true> { };
template< typename T > struct is_array< T const volatile[] > : ::boost::integral_constant<bool,true> { };
# 87 "/usr/include/boost/type_traits/is_array.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 90 "/usr/include/boost/type_traits/is_array.hpp" 2 3 4
# 20 "/usr/include/boost/type_traits/is_convertible.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/add_reference.hpp" 1 3 4
# 17 "/usr/include/boost/type_traits/add_reference.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/add_reference.hpp" 2 3 4

namespace boost {

namespace detail {
# 55 "/usr/include/boost/type_traits/add_reference.hpp" 3 4
template <typename T>
struct add_reference_impl
{
    typedef T& type;
};


template< typename T > struct add_reference_impl<T&> { typedef T& type; };





template<> struct add_reference_impl<void> { typedef void type; };

template<> struct add_reference_impl<void const> { typedef void const type; };
template<> struct add_reference_impl<void volatile> { typedef void volatile type; };
template<> struct add_reference_impl<void const volatile> { typedef void const volatile type; };


}

template< typename T > struct add_reference { typedef typename boost::detail::add_reference_impl<T>::type type; };







}

# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 88 "/usr/include/boost/type_traits/add_reference.hpp" 2 3 4
# 21 "/usr/include/boost/type_traits/is_convertible.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/ice.hpp" 1 3 4
# 18 "/usr/include/boost/type_traits/ice.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/ice_eq.hpp" 1 3 4
# 13 "/usr/include/boost/type_traits/detail/ice_eq.hpp" 3 4
namespace boost {
namespace type_traits {

template <int b1, int b2>
struct ice_eq
{
    static const bool value = (b1 == b2);
};

template <int b1, int b2>
struct ice_ne
{
    static const bool value = (b1 != b2);
};


template <int b1, int b2> bool const ice_eq<b1,b2>::value;
template <int b1, int b2> bool const ice_ne<b1,b2>::value;


}
}
# 19 "/usr/include/boost/type_traits/ice.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/is_convertible.hpp" 2 3 4



# 1 "/usr/include/boost/type_traits/is_abstract.hpp" 1 3 4
# 62 "/usr/include/boost/type_traits/is_abstract.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 63 "/usr/include/boost/type_traits/is_abstract.hpp" 2 3 4


namespace boost {
namespace detail{


template <class T>
struct is_abstract_imp
{
   static const bool value = __is_abstract(T);
};
# 141 "/usr/include/boost/type_traits/is_abstract.hpp" 3 4
}


template< typename T > struct is_abstract : ::boost::integral_constant<bool,::boost::detail::is_abstract_imp<T>::value> { };




}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 152 "/usr/include/boost/type_traits/is_abstract.hpp" 2 3 4
# 26 "/usr/include/boost/type_traits/is_convertible.hpp" 2 3 4
# 36 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 37 "/usr/include/boost/type_traits/is_convertible.hpp" 2 3 4

namespace boost {
# 52 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
namespace detail {
# 119 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
struct any_conversion
{
    template <typename T> any_conversion(const volatile T&);
    template <typename T> any_conversion(T&);
};

template <typename T> struct checker
{
    static boost::type_traits::no_type _m_check(any_conversion ...);
    static boost::type_traits::yes_type _m_check(T, int);
};

template <typename From, typename To>
struct is_convertible_basic_impl
{
    static From _m_from;
    static bool const value = sizeof( detail::checker<To>::_m_check(_m_from, 0) )
        == sizeof(::boost::type_traits::yes_type);
};
# 291 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
template <typename From, typename To>
struct is_convertible_impl
{
    typedef typename add_reference<From>::type ref_type;
    static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::detail::is_convertible_basic_impl<ref_type,To>::value, ::boost::is_void<To>::value >::value, ::boost::type_traits::ice_not< ::boost::is_array<To>::value >::value >::value);
# 306 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
};


template <bool trivial1, bool trivial2, bool abstract_target>
struct is_convertible_impl_select
{
   template <class From, class To>
   struct rebind
   {
      typedef is_convertible_impl<From, To> type;
   };
};

template <>
struct is_convertible_impl_select<true, true, false>
{
   template <class From, class To>
   struct rebind
   {
      typedef true_type type;
   };
};

template <>
struct is_convertible_impl_select<false, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <>
struct is_convertible_impl_select<true, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};

template <typename From, typename To>
struct is_convertible_impl_dispatch_base
{

   typedef is_convertible_impl_select<
      ::boost::is_arithmetic<From>::value,
      ::boost::is_arithmetic<To>::value,

      ::boost::is_abstract<To>::value



   > selector;



   typedef typename selector::template rebind<From, To> isc_binder;
   typedef typename isc_binder::type type;
};

template <typename From, typename To>
struct is_convertible_impl_dispatch
   : public is_convertible_impl_dispatch_base<From, To>::type
{};
# 394 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
    template<> struct is_convertible_impl< void,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void volatile > { static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const volatile > { static const bool value = (true); };
# 404 "/usr/include/boost/type_traits/is_convertible.hpp" 3 4
template< typename To > struct is_convertible_impl< void,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void > { static const bool value = (true); };

template< typename To > struct is_convertible_impl< void const,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void volatile,To > { static const bool value = (false); };
template< typename To > struct is_convertible_impl< void const volatile,To > { static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void const > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void volatile > { static const bool value = (true); };
template< typename From > struct is_convertible_impl< From,void const volatile > { static const bool value = (true); };



}

template< typename From, typename To > struct is_convertible : ::boost::integral_constant<bool,(::boost::detail::is_convertible_impl_dispatch<From,To>::value)> { };







}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 429 "/usr/include/boost/type_traits/is_convertible.hpp" 2 3 4
# 21 "/usr/include/boost/iterator/iterator_categories.hpp" 2 3 4



namespace boost {





struct no_traversal_tag {};

struct incrementable_traversal_tag
  : no_traversal_tag
{


};

struct single_pass_traversal_tag
  : incrementable_traversal_tag
{


};

struct forward_traversal_tag
  : single_pass_traversal_tag
{


};

struct bidirectional_traversal_tag
  : forward_traversal_tag
{


};

struct random_access_traversal_tag
  : bidirectional_traversal_tag
{


};

namespace detail
{






  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};
# 108 "/usr/include/boost/iterator/iterator_categories.hpp" 3 4
  template <class Traversal>
  struct pure_traversal_tag
    : mpl::eval_if<
          is_convertible<Traversal,random_access_traversal_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Traversal,bidirectional_traversal_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Traversal,forward_traversal_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Traversal,single_pass_traversal_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Traversal,incrementable_traversal_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {
  };
# 142 "/usr/include/boost/iterator/iterator_categories.hpp" 3 4
}





template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::detail::old_category_to_traversal<Cat>
    >
{};


template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename boost::detail::iterator_traits<Iterator>::iterator_category
    >
{};
# 184 "/usr/include/boost/iterator/iterator_categories.hpp" 3 4
}

# 1 "/usr/include/boost/iterator/detail/config_undef.hpp" 1 3 4
# 187 "/usr/include/boost/iterator/iterator_categories.hpp" 2 3 4
# 29 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4

# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 31 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4

# 1 "/usr/include/boost/unordered/detail/allocator_helpers.hpp" 1 3 4
# 26 "/usr/include/boost/unordered/detail/allocator_helpers.hpp" 3 4
namespace boost {
    namespace unordered_detail {





        template <class Alloc, class T>
        struct rebind_wrap
        {
            typedef typename
                Alloc::template rebind<T>::other
                type;
        };



        template <class T>
        inline void reset(T& x) { x = T(); }

        template <class Ptr>
        inline Ptr null_ptr() { return Ptr(); }
# 62 "/usr/include/boost/unordered/detail/allocator_helpers.hpp" 3 4
        template <class Allocator> struct allocator_value_type
        {
            typedef typename Allocator::value_type type;
        };

        template <class Allocator> struct allocator_pointer
        {
            typedef typename Allocator::pointer type;
        };

        template <class Allocator> struct allocator_const_pointer
        {
            typedef typename Allocator::const_pointer type;
        };

        template <class Allocator> struct allocator_reference
        {
            typedef typename Allocator::reference type;
        };

        template <class Allocator> struct allocator_const_reference
        {
            typedef typename Allocator::const_reference type;
        };
# 121 "/usr/include/boost/unordered/detail/allocator_helpers.hpp" 3 4
        template <class Allocator>
        struct allocator_constructor
        {
            typedef typename allocator_value_type<Allocator>::type value_type;
            typedef typename allocator_pointer<Allocator>::type pointer;

            Allocator& alloc_;
            pointer ptr_;
            bool constructed_;

            allocator_constructor(Allocator& a)
                : alloc_(a), ptr_(), constructed_(false)
            {



            }

            ~allocator_constructor() {
                if(ptr_) {
                    if(constructed_) alloc_.destroy(ptr_);
                    alloc_.deallocate(ptr_, 1);
                }
            }

            template <class V>
            void construct(V const& v) {
                ((!ptr_ && !constructed_) ? static_cast<void> (0) : __assert_fail ("!ptr_ && !constructed_", "/usr/include/boost/unordered/detail/allocator_helpers.hpp", 148, __PRETTY_FUNCTION__));
                ptr_ = alloc_.allocate(1);
                alloc_.construct(ptr_, value_type(v));
                constructed_ = true;
            }

            void construct(value_type const& v) {
                ((!ptr_ && !constructed_) ? static_cast<void> (0) : __assert_fail ("!ptr_ && !constructed_", "/usr/include/boost/unordered/detail/allocator_helpers.hpp", 155, __PRETTY_FUNCTION__));
                ptr_ = alloc_.allocate(1);
                alloc_.construct(ptr_, v);
                constructed_ = true;
            }

            pointer get() const
            {
                return ptr_;
            }


            pointer release()
            {
                pointer p = ptr_;
                constructed_ = false;
                unordered_detail::reset(ptr_);
                return p;
            }
        };

        template <class Allocator>
        struct allocator_array_constructor
        {
            typedef typename allocator_pointer<Allocator>::type pointer;

            Allocator& alloc_;
            pointer ptr_;
            pointer constructed_;
            std::size_t length_;

            allocator_array_constructor(Allocator& a)
                : alloc_(a), ptr_(), constructed_(), length_(0)
            {




            }

            ~allocator_array_constructor() {
                if (ptr_) {
                    for(pointer p = ptr_; p != constructed_; ++p)
                        alloc_.destroy(p);

                    alloc_.deallocate(ptr_, length_);
                }
            }

            template <class V>
            void construct(V const& v, std::size_t l)
            {
                ((!ptr_) ? static_cast<void> (0) : __assert_fail ("!ptr_", "/usr/include/boost/unordered/detail/allocator_helpers.hpp", 207, __PRETTY_FUNCTION__));
                length_ = l;
                ptr_ = alloc_.allocate(length_);
                pointer end = ptr_ + static_cast<std::ptrdiff_t>(length_);
                for(constructed_ = ptr_; constructed_ != end; ++constructed_)
                    alloc_.construct(constructed_, v);
            }

            pointer get() const
            {
                return ptr_;
            }

            pointer release()
            {
                pointer p(ptr_);
                unordered_detail::reset(ptr_);
                return p;
            }
        private:
            allocator_array_constructor(allocator_array_constructor const&);
            allocator_array_constructor& operator=(allocator_array_constructor const&);
        };
    }
}
# 33 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4

# 1 "/usr/include/boost/type_traits/aligned_storage.hpp" 1 3 4
# 11 "/usr/include/boost/type_traits/aligned_storage.hpp" 3 4
# 1 "/usr/include/boost/aligned_storage.hpp" 1 3 4
# 16 "/usr/include/boost/aligned_storage.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 17 "/usr/include/boost/aligned_storage.hpp" 2 3 4
# 27 "/usr/include/boost/aligned_storage.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 28 "/usr/include/boost/aligned_storage.hpp" 2 3 4

namespace boost {

namespace detail { namespace aligned_storage {

static const std::size_t alignment_of_max_align = ::boost::alignment_of<max_align>::value;







template <
      std::size_t size_
    , std::size_t alignment_
>
struct aligned_storage_imp
{
    union data_t
    {
        char buf[size_];

        typename mpl::eval_if_c<
              alignment_ == std::size_t(-1)
            , mpl::identity<detail::max_align>
            , type_with_alignment<alignment_>
            >::type align_;
    } data_;
    void* address() const { return const_cast<aligned_storage_imp*>(this); }
};

template< std::size_t alignment_ >
struct aligned_storage_imp<0u,alignment_>
{

    void* address() const { return 0; }
};

}}

template <
      std::size_t size_
    , std::size_t alignment_ = std::size_t(-1)
>
class aligned_storage :

   private



   detail::aligned_storage::aligned_storage_imp<size_, alignment_>
{

public:

    typedef detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;

    static const std::size_t size = size_;



    static const std::size_t alignment = ( alignment_ == std::size_t(-1) ? ::boost::detail::aligned_storage::alignment_of_max_align : alignment_ );
# 104 "/usr/include/boost/aligned_storage.hpp" 3 4
private:

    aligned_storage(const aligned_storage&);
    aligned_storage& operator=(const aligned_storage&);
# 118 "/usr/include/boost/aligned_storage.hpp" 3 4
public:

    aligned_storage()
    {
    }

    ~aligned_storage()
    {
    }

public:

    void* address()
    {
        return static_cast<type*>(this)->address();
    }



    const void* address() const
    {
        return static_cast<const type*>(this)->address();
    }







};
# 168 "/usr/include/boost/aligned_storage.hpp" 3 4
template <std::size_t size_, std::size_t alignment_>
struct is_pod<boost::detail::aligned_storage::aligned_storage_imp<size_,alignment_> >
   : ::boost::integral_constant<bool,true>
{
   
};



}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 180 "/usr/include/boost/aligned_storage.hpp" 2 3 4
# 12 "/usr/include/boost/type_traits/aligned_storage.hpp" 2 3 4
# 35 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4

# 1 "/usr/include/boost/type_traits/remove_reference.hpp" 1 3 4
# 21 "/usr/include/boost/type_traits/remove_reference.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/remove_reference.hpp" 2 3 4

namespace boost {



template< typename T > struct remove_reference { typedef T type; };
template< typename T > struct remove_reference<T&> { typedef T type; };
# 46 "/usr/include/boost/type_traits/remove_reference.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 49 "/usr/include/boost/type_traits/remove_reference.hpp" 2 3 4
# 37 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/remove_const.hpp" 1 3 4
# 20 "/usr/include/boost/type_traits/remove_const.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 21 "/usr/include/boost/type_traits/remove_const.hpp" 2 3 4






# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 28 "/usr/include/boost/type_traits/remove_const.hpp" 2 3 4

namespace boost {



namespace detail {

template <typename T, bool is_vol>
struct remove_const_helper
{
    typedef T type;
};

template <typename T>
struct remove_const_helper<T, true>
{
    typedef T volatile type;
};


template <typename T>
struct remove_const_impl
{
    typedef typename remove_const_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_volatile<T>::value
        >::type type;
};

}



template< typename T > struct remove_const { typedef typename boost::detail::remove_const_impl<T>::type type; };
template< typename T > struct remove_const<T&> { typedef T& type; };

template< typename T, std::size_t N > struct remove_const<T const[N]> { typedef T type[N]; };
template< typename T, std::size_t N > struct remove_const<T const volatile[N]> { typedef T volatile type[N]; };
# 74 "/usr/include/boost/type_traits/remove_const.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 77 "/usr/include/boost/type_traits/remove_const.hpp" 2 3 4
# 38 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/and.hpp" 1 3 4
# 42 "/usr/include/boost/mpl/and.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp" 3 4
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};

template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_

    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }





}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 43 "/usr/include/boost/mpl/and.hpp" 2 3 4
# 40 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/or.hpp" 1 3 4
# 43 "/usr/include/boost/mpl/or.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/or.hpp" 3 4
namespace boost { namespace mpl {

namespace aux {

template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};

template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};

template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};

}

template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_

    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >

{
   




};

template<> struct or_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }





}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 44 "/usr/include/boost/mpl/or.hpp" 2 3 4
# 41 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4


# 1 "/usr/include/boost/utility/swap.hpp" 1 3 4
# 25 "/usr/include/boost/utility/swap.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstddef" 1 3 4
# 41 "/usr/include/c++/4.4/cstddef" 3 4
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 26 "/usr/include/boost/utility/swap.hpp" 2 3 4

namespace boost_swap_impl
{
  template<class T>
  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }

  template<class T, std::size_t N>
  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}

namespace boost
{
  template<class T1, class T2>
  void swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}
# 44 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/seq/size.hpp" 1 3 4
# 45 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/seq/enum.hpp" 1 3 4
# 46 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4
# 84 "/usr/include/boost/unordered/detail/hash_table.hpp" 3 4
namespace boost {
    namespace unordered_detail {
        template <class T> struct type_wrapper {};

        static const std::size_t default_initial_bucket_count = 11;
        static const float minimum_max_load_factor = 1e-3f;

        inline std::size_t double_to_size_t(double f)
        {
            return f >= static_cast<double>((std::numeric_limits<std::size_t>::max)()) ?
                (std::numeric_limits<std::size_t>::max)() :
                static_cast<std::size_t>(f);
        }



        template<typename T> struct prime_list_template
        {
            static std::size_t const value[];
            static std::ptrdiff_t const length;
        };
# 115 "/usr/include/boost/unordered/detail/hash_table.hpp" 3 4
        template<typename T>
        std::size_t const prime_list_template<T>::value[] = {
            5ul, 11ul, 17ul, 29ul, 37ul, 53ul, 67ul, 79ul, 97ul, 131ul, 193ul, 257ul, 389ul, 521ul, 769ul, 1031ul, 1543ul, 2053ul, 3079ul, 6151ul, 12289ul, 24593ul, 49157ul, 98317ul, 196613ul, 393241ul, 786433ul, 1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul, 50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul, 1610612741ul, 3221225473ul, 4294967291ul
        };

        template<typename T>
        std::ptrdiff_t const prime_list_template<T>::length
            = 40;



        typedef prime_list_template<std::size_t> prime_list;


        inline std::size_t next_prime(std::size_t n) {
            std::size_t const* const prime_list_begin = prime_list::value;
            std::size_t const* const prime_list_end = prime_list_begin +
                prime_list::length;
            std::size_t const* bound =
                std::lower_bound(prime_list_begin, prime_list_end, n);
            if(bound == prime_list_end)
                bound--;
            return *bound;
        }


        inline std::size_t prev_prime(std::size_t n) {
            std::size_t const* const prime_list_begin = prime_list::value;
            std::size_t const* const prime_list_end = prime_list_begin +
                prime_list::length;
            std::size_t const* bound =
                std::upper_bound(prime_list_begin,prime_list_end, n);
            if(bound != prime_list_begin)
                bound--;
            return *bound;
        }





        struct bucket_manager {
            std::size_t bucket_count_;

            bucket_manager()
                : bucket_count_(0) {}

            explicit bucket_manager(std::size_t n)
                : bucket_count_(next_prime(n)) {}

            std::size_t bucket_count() const {
                return bucket_count_;
            }

            std::size_t bucket_from_hash(std::size_t hashed) const {
                return hashed % bucket_count_;
            }

            std::size_t max_bucket_count(std::size_t max_size) const {
                return prev_prime(max_size);
            }
        };



        template <class Dst1, class Dst2, class Src1, class Src2>
        inline std::pair<Dst1, Dst2> pair_cast(std::pair<Src1, Src2> const& x)
        {
            return std::pair<Dst1, Dst2>(Dst1(x.first), Dst2(x.second));
        }


        using ::std::distance;
# 197 "/usr/include/boost/unordered/detail/hash_table.hpp" 3 4
        struct move_tag {};




        template <typename Hash, typename Pred>
        struct buffered_functions
        {
            typedef Hash hasher;
            typedef Pred key_equal;

            class functions
            {
                std::pair<hasher, key_equal> functions_;

            public:

                functions(hasher const& h, key_equal const& k)
                    : functions_(h, k) {}

                hasher const& hash_function() const
                {
                    return functions_.first;
                }

                key_equal const& key_eq() const
                {
                    return functions_.second;
                }
            };

            typedef functions buffered_functions::*functions_ptr;

            buffered_functions(hasher const& h, key_equal const& k)
                : func1_(h, k), func2_(h, k), func_(&buffered_functions::func1_) {}







            functions_ptr buffer(buffered_functions const& x) {
                functions_ptr ptr = func_ == &buffered_functions::func1_
                    ? &buffered_functions::func2_ : &buffered_functions::func1_;
                this->*ptr = x.current();
                return ptr;
            }

            void set(functions_ptr ptr) {
                ((ptr != func_) ? static_cast<void> (0) : __assert_fail ("ptr != func_", "/usr/include/boost/unordered/detail/hash_table.hpp", 247, __PRETTY_FUNCTION__));
                func_ = ptr;
            }

            functions const& current() const {
                return this->*func_;
            }

        private:
            functions func1_;
            functions func2_;
            functions_ptr func_;
        };





        template <typename T>
        void destroy(T* x) {
            x->~T();
        }

    }
}


# 1 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 1 3 4
# 23 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
namespace boost {
    namespace unordered_detail {






        template <typename Alloc>
        class hash_table_data_equivalent_keys
        {
        public:
            typedef hash_table_data_equivalent_keys data;

            struct node;
            struct bucket;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;

            typedef Alloc value_allocator;

            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, node>::type
                node_allocator;
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, bucket>::type
                bucket_allocator;

            typedef typename allocator_value_type<Alloc>::type value_type;
            typedef typename allocator_pointer<node_allocator>::type node_ptr;
            typedef typename allocator_pointer<bucket_allocator>::type bucket_ptr;
            typedef typename allocator_reference<value_allocator>::type reference;
            typedef typename allocator_reference<bucket_allocator>::type bucket_reference;

            typedef bucket_ptr link_ptr;





            struct bucket
            {
            private:
                bucket& operator=(bucket const&);
            public:
                link_ptr next_;

                bucket() : next_()
                {
                    ;
                }

                bucket(bucket const& x) : next_(x.next_)
                {

                    ((!x.next_) ? static_cast<void> (0) : __assert_fail ("!x.next_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 78, __PRETTY_FUNCTION__));
                }

                bool empty() const
                {
                    return !this->next_;
                }
            };



            struct value_base {
                typename boost::aligned_storage<
                    sizeof(value_type),
                    ::boost::alignment_of<value_type>::value>::type data_;

                void* address() { return this; }
            };





            struct node : value_base, bucket {

            public:
                node() : group_prev_()
                {
                    ;
                }

                link_ptr group_prev_;


                value_type& value() {
                    return *static_cast<value_type*>(this->address());
                }
            };





            struct allocators
            {
                node_allocator node_alloc_;
                bucket_allocator bucket_alloc_;

                allocators(value_allocator const& a)
                    : node_alloc_(a), bucket_alloc_(a)
                {}

                void destroy(link_ptr ptr)
                {
                    node* raw_ptr = static_cast<node*>(&*ptr);
                    boost::unordered_detail::destroy(&raw_ptr->value());
                    node_ptr n(node_alloc_.address(*raw_ptr));
                    node_alloc_.destroy(n);
                    node_alloc_.deallocate(n, 1);
                }

                void swap(allocators& x)
                {
                    boost::swap(node_alloc_, x.node_alloc_);
                    boost::swap(bucket_alloc_, x.bucket_alloc_);
                }

                bool operator==(allocators const& x)
                {
                    return node_alloc_ == x.node_alloc_;
                }
            };





            class node_constructor
            {
                allocators& allocators_;

                node_ptr node_;
                bool node_constructed_;
                bool value_constructed_;

            public:

                node_constructor(allocators& a)
                    : allocators_(a),
                    node_(), node_constructed_(false), value_constructed_(false)
                {
                }

                ~node_constructor()
                {
                    if (node_) {
                        if (value_constructed_) {
                            boost::unordered_detail::destroy(&node_->value());
                        }

                        if (node_constructed_)
                            allocators_.node_alloc_.destroy(node_);
                        allocators_.node_alloc_.deallocate(node_, 1);
                    }
                }

                void construct_preamble()
                {
                    if(!node_) {
                        node_constructed_ = false;
                        value_constructed_ = false;

                        node_ = allocators_.node_alloc_.allocate(1);
                        allocators_.node_alloc_.construct(node_, node());
                        node_constructed_ = true;
                    }
                    else {
                        ((node_constructed_ && value_constructed_) ? static_cast<void> (0) : __assert_fail ("node_constructed_ && value_constructed_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 195, __PRETTY_FUNCTION__));
                        boost::unordered_detail::destroy(&node_->value());
                        value_constructed_ = false;
                    }
                }


                template <typename... Args>
                void construct(Args&&... args)
                {
                    construct_preamble();
                    new(node_->address()) value_type(std::forward<Args>(args)...);
                    value_constructed_ = true;
                }
# 273 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
                template <typename K, typename M>
                void construct_pair(K const& k, M*)
                {
                    construct_preamble();
                    new(node_->address()) value_type(k, M());
                    value_constructed_ = true;
                }

                node_ptr get() const
                {
                    ((node_) ? static_cast<void> (0) : __assert_fail ("node_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 283, __PRETTY_FUNCTION__));
                    return node_;
                }


                link_ptr release()
                {
                    node_ptr p = node_;
                    unordered_detail::reset(node_);
                    return link_ptr(allocators_.bucket_alloc_.address(*p));
                }

            private:
                node_constructor(node_constructor const&);
                node_constructor& operator=(node_constructor const&);
            };




            static inline link_ptr& prev_in_group(link_ptr n) {
                return static_cast<node*>(&*n)->group_prev_;
            }


            static inline link_ptr& next_group(link_ptr n) {
                ((n && n != prev_in_group(n)->next_) ? static_cast<void> (0) : __assert_fail ("n && n != prev_in_group(n)->next_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 309, __PRETTY_FUNCTION__));
                return prev_in_group(n)->next_;
            }
# 320 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            static inline node& get_node(link_ptr p) {
                ((p) ? static_cast<void> (0) : __assert_fail ("p", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 321, __PRETTY_FUNCTION__));
                return *static_cast<node*>(&*p);
            }


            static inline reference get_value(link_ptr p) {
                return get_node(p).value();
            }

            class iterator_base
            {
                typedef hash_table_data_equivalent_keys<Alloc> data;
            public:
                bucket_ptr bucket_;
                link_ptr node_;

                iterator_base()
                    : bucket_(), node_()
                {
                    ;
                    ;
                }

                explicit iterator_base(bucket_ptr b)
                    : bucket_(b), node_(b->next_) {}

                iterator_base(bucket_ptr b, link_ptr n)
                    : bucket_(b), node_(n) {}

                bool operator==(iterator_base const& x) const
                {
                    return node_ == x.node_;
                }

                bool operator!=(iterator_base const& x) const
                {
                    return node_ != x.node_;
                }

                reference operator*() const
                {
                    return get_value(node_);
                }

                void increment()
                {
                    ((bucket_) ? static_cast<void> (0) : __assert_fail ("bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 367, __PRETTY_FUNCTION__));
                    node_ = node_->next_;

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }

                void increment_group()
                {
                    node_ = data::next_group(node_);

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }
            };



            allocators allocators_;
            bucket_ptr buckets_;
            bucket_manager bucket_manager_;
            bucket_ptr cached_begin_bucket_;
            size_type size_;



            hash_table_data_equivalent_keys(size_type n, value_allocator const& a)
              : allocators_(a),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys const& x, size_type n)
              : allocators_(x.allocators_),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys& x, move_tag)
                : allocators_(x.allocators_),
                buckets_(x.buckets_), bucket_manager_(x.bucket_manager_),
                cached_begin_bucket_(x.cached_begin_bucket_), size_(x.size_)
            {
                unordered_detail::reset(x.buckets_);
            }

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys& x,
                    value_allocator const& a, size_type n, move_tag)
                : allocators_(a), buckets_(), bucket_manager_(),
                cached_begin_bucket_(), size_(0)
            {
                if(allocators_ == x.allocators_) {
                    buckets_ = x.buckets_;
                    bucket_manager_ = x.bucket_manager_;
                    cached_begin_bucket_ = x.cached_begin_bucket_;
                    size_ = x.size_;
                    unordered_detail::reset(x.buckets_);
                }
                else {
                    ;
                    bucket_manager_ = bucket_manager(n);
                    create_buckets();
                }
            }


            ~hash_table_data_equivalent_keys()
            {
                delete_buckets();
            }

            void create_buckets() {
                size_type bucket_count = bucket_manager_.bucket_count();



                allocator_array_constructor<bucket_allocator>
                    constructor(allocators_.bucket_alloc_);


                constructor.construct(bucket(), bucket_count + 1);

                cached_begin_bucket_ = constructor.get() + static_cast<difference_type>(bucket_count);


                cached_begin_bucket_->next_ = link_ptr(cached_begin_bucket_);



                buckets_ = constructor.release();
            }


            void delete_buckets()
            {
                if(buckets_) {
                    bucket_ptr begin = cached_begin_bucket_;
                    bucket_ptr end = buckets_end();
                    while(begin != end) {
                        clear_bucket(begin);
                        ++begin;
                    }


                    ++end;
                    for(begin = buckets_; begin != end; ++begin)
                        allocators_.bucket_alloc_.destroy(begin);

                    allocators_.bucket_alloc_.deallocate(buckets_,
                        bucket_manager_.bucket_count() + 1);
                }
            }

        private:

            hash_table_data_equivalent_keys(hash_table_data_equivalent_keys const&);
            hash_table_data_equivalent_keys& operator=(hash_table_data_equivalent_keys const&);

        public:


            void swap(hash_table_data_equivalent_keys& other)
            {
                std::swap(buckets_, other.buckets_);
                std::swap(bucket_manager_, other.bucket_manager_);
                std::swap(cached_begin_bucket_, other.cached_begin_bucket_);
                std::swap(size_, other.size_);
            }


            void move(hash_table_data_equivalent_keys& other)
            {
                delete_buckets();
                buckets_ = other.buckets_;
                unordered_detail::reset(other.buckets_);
                bucket_manager_ = other.bucket_manager_;
                cached_begin_bucket_ = other.cached_begin_bucket_;
                size_ = other.size_;
            }




            size_type bucket_from_hash(size_type hashed) const
            {
                return bucket_manager_.bucket_from_hash(hashed);
            }




            bucket_ptr bucket_ptr_from_hash(size_type hashed) const
            {
                return buckets_ + static_cast<difference_type>(
                    bucket_manager_.bucket_from_hash(hashed));
            }





            bucket_ptr buckets_end() const
            {
                return buckets_ + static_cast<difference_type>(bucket_manager_.bucket_count());
            }

            iterator_base begin() const
            {
                return size_
                    ? iterator_base(cached_begin_bucket_)
                    : end();
            }

            iterator_base end() const
            {
                return iterator_base(buckets_end());
            }

            link_ptr begin(size_type n) const
            {
                return (buckets_ + static_cast<difference_type>(n))->next_;
            }

            link_ptr end(size_type) const
            {
                return unordered_detail::null_ptr<link_ptr>();
            }

            link_ptr begin(bucket_ptr b) const
            {
                return b->next_;
            }




            static inline size_type node_count(link_ptr it)
            {
                size_type count = 0;
                while(it) {
                    ++count;
                    it = it->next_;
                }
                return count;
            }

            static inline size_type node_count(link_ptr it1, link_ptr it2)
            {
                size_type count = 0;
                while(it1 != it2) {
                    ++count;
                    it1 = it1->next_;
                }
                return count;
            }

            size_type bucket_size(size_type n) const
            {
                return node_count(begin(n));
            }


            static inline size_type group_count(link_ptr it)
            {
                return node_count(it, next_group(it));
            }
# 617 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            static link_ptr* get_for_erase(iterator_base r)
            {
                link_ptr n = r.node_;




                link_ptr* it = &prev_in_group(n)->next_;
                if(*it == n) return it;



                it = &r.bucket_->next_;
                while(*it != n) it = &hash_table_data_equivalent_keys::next_group(*it);
                return it;
            }
# 653 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            link_ptr link_node(node_constructor& a, link_ptr pos)
            {
                link_ptr n = a.release();
                node& node_ref = get_node(n);
                node& pos_ref = get_node(pos);
                node_ref.next_ = pos_ref.group_prev_->next_;
                node_ref.group_prev_ = pos_ref.group_prev_;
                pos_ref.group_prev_->next_ = n;
                pos_ref.group_prev_ = n;
                ++size_;
                return n;
            }

            link_ptr link_node_in_bucket(node_constructor& a, bucket_ptr base)
            {
                link_ptr n = a.release();
                node& node_ref = get_node(n);
                node_ref.next_ = base->next_;
                node_ref.group_prev_ = n;
                base->next_ = n;
                ++size_;
                if(base < cached_begin_bucket_) cached_begin_bucket_ = base;
                return n;
            }

            void link_group(link_ptr n, bucket_ptr base, size_type count)
            {
                node& node_ref = get_node(n);
                node& last_ref = get_node(node_ref.group_prev_);
                last_ref.next_ = base->next_;
                base->next_ = n;
                size_ += count;
                if(base < cached_begin_bucket_) cached_begin_bucket_ = base;
            }
# 710 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void unlink_node(iterator_base it)
            {
                link_ptr* pos = get_for_erase(it);
                node* n = &get_node(it.node_);
                link_ptr next = n->next_;

                if(n->group_prev_ == *pos) {


                }
                else if(next && prev_in_group(next) == *pos)
                {


                    prev_in_group(next) = n->group_prev_;
                }
                else {



                    link_ptr it = n->group_prev_;
                    while(prev_in_group(it) != *pos) {
                        it = prev_in_group(it);
                    }
                    prev_in_group(it) = n->group_prev_;
                }
                *pos = next;
                --size_;
            }

            size_type unlink_group(link_ptr* pos)
            {
                size_type count = group_count(*pos);
                size_ -= count;
                *pos = next_group(*pos);
                return count;
            }
# 763 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void unlink_nodes(iterator_base n)
            {
                link_ptr* it = get_for_erase(n);
                split_group(*it);
                unordered_detail::reset(*it);
                size_ -= node_count(n.node_);
            }

            void unlink_nodes(iterator_base begin, iterator_base end)
            {
                ((begin.bucket_ == end.bucket_) ? static_cast<void> (0) : __assert_fail ("begin.bucket_ == end.bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 773, __PRETTY_FUNCTION__));
                size_ -= node_count(begin.node_, end.node_);
                link_ptr* it = get_for_erase(begin);
                split_group(*it, end.node_);
                *it = end.node_;
            }

            void unlink_nodes(bucket_ptr base, iterator_base end)
            {
                ((base == end.bucket_) ? static_cast<void> (0) : __assert_fail ("base == end.bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 782, __PRETTY_FUNCTION__));

                split_group(end.node_);

                link_ptr ptr(base->next_);
                base->next_ = end.node_;

                size_ -= node_count(ptr, end.node_);
            }





            static inline link_ptr split_group(link_ptr split)
            {


                if(prev_in_group(split)->next_ != split)
                    return unordered_detail::null_ptr<link_ptr>();


                link_ptr start = split;
                do {
                    start = prev_in_group(start);
                } while(prev_in_group(start)->next_ == start);

                link_ptr last = prev_in_group(start);
                prev_in_group(start) = prev_in_group(split);
                prev_in_group(split) = last;

                return start;
            }

            static inline void split_group(link_ptr split1, link_ptr split2)
            {
                link_ptr begin1 = split_group(split1);
                link_ptr begin2 = split_group(split2);

                if(begin1 && split1 == begin2) {
                    link_ptr end1 = prev_in_group(begin1);
                    prev_in_group(begin1) = prev_in_group(begin2);
                    prev_in_group(begin2) = end1;
                }
            }
# 843 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void copy_group(link_ptr it, bucket_ptr dst)
            {
                node_constructor a(allocators_);

                link_ptr end = next_group(it);

                a.construct(get_value(it));
                link_ptr n = link_node_in_bucket(a, dst);

                for(it = it->next_; it != end; it = it->next_) {
                    a.construct(get_value(it));
                    link_node(a, n);
                }
            }
# 874 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void delete_to_bucket_end(link_ptr begin)
            {
                while(begin) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }

            void delete_nodes(link_ptr begin, link_ptr end)
            {
                while(begin != end) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }


            void delete_group(link_ptr first_node)
            {
                delete_nodes(first_node, prev_in_group(first_node)->next_);
            }
# 910 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void clear_bucket(bucket_ptr b)
            {
                link_ptr first_node = b->next_;
                unordered_detail::reset(b->next_);
                delete_to_bucket_end(first_node);
            }

            void clear()
            {
                bucket_ptr begin = cached_begin_bucket_;
                bucket_ptr end = buckets_end();

                size_ = 0;
                cached_begin_bucket_ = end;

                while(begin != end) {
                    clear_bucket(begin);
                    ++begin;
                }
            }





            iterator_base erase(iterator_base r)
            {
                ((r != end()) ? static_cast<void> (0) : __assert_fail ("r != end()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 937, __PRETTY_FUNCTION__));
                iterator_base next = r;
                next.increment();
                unlink_node(r);
                allocators_.destroy(r.node_);

                recompute_begin_bucket(r.bucket_, next.bucket_);
                return next;
            }

            iterator_base erase_range(iterator_base r1, iterator_base r2)
            {
                if(r1 != r2)
                {
                    ((r1 != end()) ? static_cast<void> (0) : __assert_fail ("r1 != end()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 951, __PRETTY_FUNCTION__));

                    if (r1.bucket_ == r2.bucket_) {
                        unlink_nodes(r1, r2);
                        delete_nodes(r1.node_, r2.node_);




                        ((!r1.bucket_->empty()) ? static_cast<void> (0) : __assert_fail ("!r1.bucket_->empty()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 960, __PRETTY_FUNCTION__));
                    }
                    else {
                        ((r1.bucket_ < r2.bucket_) ? static_cast<void> (0) : __assert_fail ("r1.bucket_ < r2.bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 963, __PRETTY_FUNCTION__));

                        unlink_nodes(r1);
                        delete_to_bucket_end(r1.node_);

                        bucket_ptr i = r1.bucket_;
                        for(++i; i != r2.bucket_; ++i) {
                            size_ -= node_count(i->next_);
                            clear_bucket(i);
                        }

                        if(r2 != end()) {
                            link_ptr first = r2.bucket_->next_;
                            unlink_nodes(r2.bucket_, r2);
                            delete_nodes(first, r2.node_);
                        }



                        recompute_begin_bucket(r1.bucket_, r2.bucket_);
                    }
                }

                return r2;
            }
# 996 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void recompute_begin_bucket(bucket_ptr b)
            {
                ((!(b < cached_begin_bucket_)) ? static_cast<void> (0) : __assert_fail ("!(b < cached_begin_bucket_)", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 998, __PRETTY_FUNCTION__));

                if(b == cached_begin_bucket_)
                {
                    if (size_ != 0) {
                        while (cached_begin_bucket_->empty())
                            ++cached_begin_bucket_;
                    } else {
                        cached_begin_bucket_ = buckets_end();
                    }
                }
            }





            void recompute_begin_bucket(bucket_ptr b1, bucket_ptr b2)
            {
                ((!(b1 < cached_begin_bucket_) && !(b2 < b1)) ? static_cast<void> (0) : __assert_fail ("!(b1 < cached_begin_bucket_) && !(b2 < b1)", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1017, __PRETTY_FUNCTION__));
                ((b2 == buckets_end() || !b2->empty()) ? static_cast<void> (0) : __assert_fail ("b2 == buckets_end() || !b2->empty()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1018, __PRETTY_FUNCTION__));

                if(b1 == cached_begin_bucket_ && b1->empty())
                    cached_begin_bucket_ = b2;
            }

            size_type erase_group(link_ptr* it, bucket_ptr bucket)
            {
                link_ptr pos = *it;
                size_type count = unlink_group(it);
                delete_group(pos);

                this->recompute_begin_bucket(bucket);

                return count;
            }
        };
# 1050 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
        template <typename ValueType, typename KeyType,
            typename Hash, typename Pred,
            typename Alloc>
        class hash_table_equivalent_keys
        {
            typedef hash_table_data_equivalent_keys<Alloc> data;

            typedef typename data::node_constructor node_constructor;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

        public:

            typedef typename data::value_allocator value_allocator;
            typedef typename data::node_allocator node_allocator;



            typedef KeyType key_type;
            typedef Hash hasher;
            typedef Pred key_equal;
            typedef ValueType value_type;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;



            typedef typename data::iterator_base iterator_base;

        private:


            typedef boost::unordered_detail::buffered_functions<Hash, Pred>
                function_store;
            typedef typename function_store::functions functions;
            typedef typename function_store::functions_ptr
                functions_ptr;

            function_store functions_;
            float mlf_;
            size_type max_load_;

        public:

            data data_;






            hash_table_equivalent_keys(size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                mlf_(1.0f),
                data_(n, a)
            {
                calculate_max_load();
            }
# 1121 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            template <typename I>
            size_type initial_size(I i, I j, size_type n,
                    boost::forward_traversal_tag)
            {

                return (std::max)(static_cast<size_type>(unordered_detail::distance(i, j)) + 1, n);
            }

            template <typename I>
            size_type initial_size(I, I, size_type n,
                    boost::incrementable_traversal_tag)
            {
                return n;
            }

            template <typename I>
            size_type initial_size(I i, I j, size_type n)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                return initial_size(i, j, n, iterator_traversal_tag);
            }

            template <typename I>
            hash_table_equivalent_keys(I i, I j, size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                  mlf_(1.0f),
                  data_(initial_size(i, j, n), a)
            {
                calculate_max_load();


                insert_range(i, j);
            }



            hash_table_equivalent_keys(hash_table_equivalent_keys const& x)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, x.min_buckets_for_size(x.size()))
            {
                calculate_max_load();



                x.copy_buckets_to(data_);
            }



            hash_table_equivalent_keys(hash_table_equivalent_keys const& x,
                    value_allocator const& a)
                : functions_(x.functions_),
                mlf_(x.mlf_),
                data_(x.min_buckets_for_size(x.size()), a)
            {
                calculate_max_load();



                x.copy_buckets_to(data_);
            }



            hash_table_equivalent_keys(hash_table_equivalent_keys& x, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, m)
            {
                calculate_max_load();
            }

            hash_table_equivalent_keys(hash_table_equivalent_keys& x,
                    value_allocator const& a, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, a,
                        x.min_buckets_for_size(x.size()), m)
            {
                calculate_max_load();

                if(x.data_.buckets_) {


                    x.copy_buckets_to(data_);
                }
            }
# 1220 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            hash_table_equivalent_keys& operator=(hash_table_equivalent_keys const& x)
            {
                if(this != &x)
                {
                    data_.clear();
                    functions_.set(functions_.buffer(x.functions_));

                    mlf_ = x.mlf_;
                    calculate_max_load();
                    reserve(x.size());
                    x.copy_buckets_to(data_);
                }

                return *this;
            }
# 1250 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void swap(hash_table_equivalent_keys& x)
            {





                if(this == &x) return;




                functions_ptr new_func_this = functions_.buffer(x.functions_);
                functions_ptr new_func_that = x.functions_.buffer(functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.swap(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    x.copy_buckets_to(new_this);

                    data new_that(x.data_, min_buckets_for_size(data_.size_));
                    copy_buckets_to(new_that);


                    data_.swap(new_this);
                    x.data_.swap(new_that);
                }


                std::swap(mlf_, x.mlf_);

                functions_.set(new_func_this);
                x.functions_.set(new_func_that);

                calculate_max_load();
                x.calculate_max_load();
            }
# 1302 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void move(hash_table_equivalent_keys& x)
            {



                functions_ptr new_func_this = functions_.buffer(x.functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.move(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    x.copy_buckets_to(new_this);


                    data_.move(new_this);
                }


                mlf_ = x.mlf_;
                functions_.set(new_func_this);
                calculate_max_load();
            }




            node_allocator get_allocator() const
            {
                return data_.allocators_.node_alloc_;
            }


            hasher const& hash_function() const
            {
                return functions_.current().hash_function();
            }


            key_equal const& key_eq() const
            {
                return functions_.current().key_eq();
            }


            size_type size() const
            {
                return data_.size_;
            }


            bool empty() const
            {
                return data_.size_ == 0;
            }


            size_type max_size() const
            {
                using namespace std;


                return double_to_size_t(ceil(
                        (double) mlf_ * max_bucket_count())) - 1;
            }


            size_type bucket(key_type const& k) const
            {

                return data_.bucket_from_hash(hash_function()(k));
            }



            bucket_ptr get_bucket(key_type const& k) const
            {
                return data_.buckets_ + static_cast<difference_type>(bucket(k));
            }


            size_type bucket_count() const
            {
                return data_.bucket_manager_.bucket_count();
            }


            size_type max_bucket_count() const
            {

                return prev_prime(data_.allocators_.bucket_alloc_.max_size() - 1);
            }

        private:


            size_type min_buckets_for_size(size_type n) const
            {
                ((mlf_ != 0) ? static_cast<void> (0) : __assert_fail ("mlf_ != 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1403, __PRETTY_FUNCTION__));

                using namespace std;







                return double_to_size_t(floor(n / (double) mlf_)) + 1;
            }


            void calculate_max_load()
            {
                using namespace std;



                max_load_ = double_to_size_t(ceil(
                        (double) mlf_ * data_.bucket_manager_.bucket_count()));
            }


            bool reserve(size_type n)
            {
                bool need_to_reserve = n >= max_load_;

                if (need_to_reserve) rehash_impl(min_buckets_for_size(n));
                ((n < max_load_ || n > max_size()) ? static_cast<void> (0) : __assert_fail ("n < max_load_ || n > max_size()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1433, __PRETTY_FUNCTION__));
                return need_to_reserve;
            }


            bool reserve_for_insert(size_type n)
            {
                bool need_to_reserve = n >= max_load_;

                if (need_to_reserve) {
                    size_type s = size();
                    s = s + (s >> 1);
                    s = s > n ? s : n;
                    rehash_impl(min_buckets_for_size(s));
                }
                ((n < max_load_ || n > max_size()) ? static_cast<void> (0) : __assert_fail ("n < max_load_ || n > max_size()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1448, __PRETTY_FUNCTION__));
                return need_to_reserve;
            }

        public:


            float max_load_factor() const
            {
                return mlf_;
            }


            void max_load_factor(float z)
            {
                ((z > 0) ? static_cast<void> (0) : __assert_fail ("z > 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1463, __PRETTY_FUNCTION__));
                mlf_ = (std::max)(z, minimum_max_load_factor);
                calculate_max_load();
            }


            float load_factor() const
            {
                ((data_.bucket_manager_.bucket_count() != 0) ? static_cast<void> (0) : __assert_fail ("data_.bucket_manager_.bucket_count() != 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1471, __PRETTY_FUNCTION__));
                return static_cast<float>(data_.size_)
                    / static_cast<float>(data_.bucket_manager_.bucket_count());
            }
# 1484 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            struct no_key {
                no_key() {}
                template <class T> no_key(T const&) {}
            };





            static no_key extract_key()
            {
                return no_key();
            }



            static key_type const& extract_key(value_type const& v)
            {
                return extract(v, (type_wrapper<value_type>*)0);
            }

            static key_type const& extract(value_type const& v,
                    type_wrapper<key_type>*)
            {
                return v;
            }

            static key_type const& extract(value_type const& v,
                    void*)
            {
                return v.first;
            }




            template <typename Arg>
            static typename
                boost::mpl::if_<boost::is_same<Arg, key_type>, key_type const&, no_key>::type
                extract_key(Arg const& k)
            {
                return k;
            }




            template <typename First, typename Second>
            static typename
                boost::mpl::if_<
                    boost::mpl::and_<
                        boost::mpl::not_<boost::is_same<key_type, value_type> >,
                        boost::is_same<key_type,
                            typename boost::remove_const<
                                typename boost::remove_reference<First>::type
                            >::type>
                    >,
                    key_type const&, no_key
                >::type extract_key(std::pair<First, Second> const& v)
            {
                return v.first;
            }




            template <typename Arg, typename Arg1, typename... Args>
            static typename
                boost::mpl::if_<
                    boost::mpl::and_<
                        boost::mpl::not_<boost::is_same<value_type, key_type> >,
                        boost::is_same<Arg, key_type>
                    >,
                    key_type const&, no_key
                >::type extract_key(Arg const& k, Arg1 const&, Args const&...)
            {
                return k;
            }
# 1579 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
        public:



            void rehash(size_type n)
            {
                using namespace std;


                size_type min_size = min_buckets_for_size(size());

                rehash_impl(min_size > n ? min_size : n);

                (((float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n) ? static_cast<void> (0) : __assert_fail ("(float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1593, __PRETTY_FUNCTION__));

            }

        private:



            void rehash_impl(size_type n)
            {
                n = next_prime(n);

                if (n == bucket_count())
                    return;

                data new_buckets(data_, n);
                move_buckets_to(new_buckets);
                new_buckets.swap(data_);
                calculate_max_load();
            }






            void move_buckets_to(data& dst)
            {
                ((dst.size_ == 0) ? static_cast<void> (0) : __assert_fail ("dst.size_ == 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1620, __PRETTY_FUNCTION__));


                data& src = this->data_;
                hasher const& hf = this->hash_function();
                bucket_ptr end = src.buckets_end();

                for(; src.cached_begin_bucket_ != end;
                        ++src.cached_begin_bucket_) {
                    bucket_ptr src_bucket = src.cached_begin_bucket_;
                    while(src_bucket->next_) {




                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(src_bucket->next_))));

                        link_ptr n = src_bucket->next_;
                        size_type count = src.unlink_group(&src_bucket->next_);
                        dst.link_group(n, dst_bucket, count);
                    }
                }
            }




            void copy_buckets_to(data& dst) const
            {
                ((dst.size_ == 0) ? static_cast<void> (0) : __assert_fail ("dst.size_ == 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1650, __PRETTY_FUNCTION__));


                data const& src = this->data_;
                hasher const& hf = this->hash_function();
                bucket_ptr end = src.buckets_end();


                for(bucket_ptr i = src.cached_begin_bucket_; i != end; ++i) {

                    for(link_ptr it = src.begin(i);
                            it; it = data::next_group(it)) {

                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(it))));

                        dst.copy_group(it, dst_bucket);
                    }
                }
            }

        public:
# 1687 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            template <class... Args>
            iterator_base emplace(Args&&... args)
            {


                node_constructor a(data_.allocators_);
                a.construct(std::forward<Args>(args)...);

                return emplace_impl(a);
            }






            template <class... Args>
            iterator_base emplace_hint(iterator_base const& it, Args&&... args)
            {


                node_constructor a(data_.allocators_);
                a.construct(std::forward<Args>(args)...);

                return emplace_hint_impl(it, a);
            }
# 1751 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            iterator_base emplace_impl(node_constructor& a)
            {
                key_type const& k = extract_key(a.get()->value());
                size_type hash_value = hash_function()(k);
                bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                link_ptr position = find_iterator(bucket, k);



                if(reserve_for_insert(size() + 1))
                    bucket = data_.bucket_ptr_from_hash(hash_value);



                return iterator_base(bucket,
                    (position) ?
                    data_.link_node(a, position) :
                    data_.link_node_in_bucket(a, bucket)
                );
            }

            iterator_base emplace_hint_impl(iterator_base const& it, node_constructor& a)
            {

                if (it == data_.end() || !equal(extract_key(a.get()->value()), *it)) {


                    return emplace_impl(a);
                }
                else {



                    link_ptr start(it.node_);
                    while(data_.prev_in_group(start)->next_ == start)
                        start = data_.prev_in_group(start);



                    bucket_ptr base = reserve_for_insert(size() + 1) ?
                        get_bucket(extract_key(a.get()->value())) : it.bucket_;



                    return iterator_base(base,
                            data_.link_node(a, start));
                }
            }



        private:



            template <typename I>
            void insert_for_range(I i, I j, forward_traversal_tag)
            {
                size_type distance = unordered_detail::distance(i, j);
                if(distance == 1) {
                    emplace(*i);
                }
                else {

                    reserve_for_insert(size() + distance);
                    node_constructor a(data_.allocators_);

                    for (; i != j; ++i) {
                        a.construct(*i);

                        key_type const& k = extract_key(a.get()->value());
                        bucket_ptr bucket = get_bucket(k);
                        link_ptr position = find_iterator(bucket, k);

                        if(position)
                            data_.link_node(a, position);
                        else
                            data_.link_node_in_bucket(a, bucket);
                    }
                }
            }



            template <typename I>
            void insert_for_range(I i, I j,
                    boost::incrementable_traversal_tag)
            {


                for (; i != j; ++i) emplace(*i);
            }

        public:



            template <typename I>
            void insert_range(I i, I j)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                insert_for_range(i, j, iterator_traversal_tag);
            }
# 2174 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
        public:




            size_type erase_key(key_type const& k)
            {

                bucket_ptr bucket = get_bucket(k);
                link_ptr* it = find_for_erase(bucket, k);


                return *it ? data_.erase_group(it, bucket) : 0;
            }




            size_type count(key_type const& k) const
            {
                link_ptr it = find_iterator(k);
                return it ? data::group_count(it) : 0;
            }




            iterator_base find(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return iterator_base(bucket, it);
                else
                    return data_.end();
            }

            value_type& at(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return data::get_value(it);
                else
                    throw std::out_of_range("Unable to find key in unordered_map.");
            }




            std::pair<iterator_base, iterator_base> equal_range(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);
                if (it) {
                    iterator_base first(iterator_base(bucket, it));
                    iterator_base second(first);
                    second.increment_group();
                    return std::pair<iterator_base, iterator_base>(first, second);
                }
                else {
                    return std::pair<iterator_base, iterator_base>(
                            data_.end(), data_.end());
                }
            }


            bool equal(key_type const& k, value_type const& v) const
            {
                return key_eq()(k, extract_key(v));
            }


            link_ptr find_iterator(key_type const& k) const
            {
                return find_iterator(get_bucket(k), k);
            }


            link_ptr find_iterator(bucket_ptr bucket,
                    key_type const& k) const
            {
                link_ptr it = data_.begin(bucket);
                while (it && !equal(k, data::get_value(it))) {
                    it = data::next_group(it);
                }

                return it;
            }


            link_ptr* find_for_erase(bucket_ptr bucket, key_type const& k) const
            {
                link_ptr* it = &bucket->next_;
                while(*it && !equal(k, data::get_value(*it)))
                    it = &data::next_group(*it);

                return it;
            }
        };






        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_equivalent_keys<A>*,
                typename hash_table_data_equivalent_keys<A>::link_ptr it1,
                typename hash_table_data_equivalent_keys<A>::link_ptr it2,
                KeyType*,
                type_wrapper<KeyType>*)
        {
            typedef hash_table_data_equivalent_keys<A> data;
            return data::group_count(it1) == data::group_count(it2);
        }

        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_equivalent_keys<A>*,
                typename hash_table_data_equivalent_keys<A>::link_ptr it1,
                typename hash_table_data_equivalent_keys<A>::link_ptr it2,
                KeyType*,
                void*)
        {
            typedef hash_table_data_equivalent_keys<A> data;
            typename hash_table_data_equivalent_keys<A>::link_ptr end1 = data::next_group(it1);
            typename hash_table_data_equivalent_keys<A>::link_ptr end2 = data::next_group(it2);

            do {
                if(data::get_value(it1).second != data::get_value(it2).second) return false;
                it1 = it1->next_;
                it2 = it2->next_;
            } while(it1 != end1 && it2 != end2);
            return it1 == end1 && it2 == end2;
        }
# 2338 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
        template <typename V, typename K, typename H, typename P, typename A>
        bool equals(hash_table_equivalent_keys<V, K, H, P, A> const& t1,
                hash_table_equivalent_keys<V, K, H, P, A> const& t2)
        {
            typedef hash_table_data_equivalent_keys<A> data;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

            if(t1.size() != t2.size()) return false;

            for(bucket_ptr i = t1.data_.cached_begin_bucket_,
                    j = t1.data_.buckets_end(); i != j; ++i)
            {
                for(link_ptr it(i->next_); it; it = data::next_group(it))
                {
                    link_ptr other_pos = t2.find_iterator(t2.extract_key(data::get_value(it)));
                    if(!other_pos ||
                        !group_equals((data*)0, it, other_pos, (K*)0, (type_wrapper<V>*)0))
                        return false;
                }
            }

            return true;
        }



        template <typename Alloc> class hash_iterator_equivalent_keys;
        template <typename Alloc> class hash_const_iterator_equivalent_keys;
        template <typename Alloc> class hash_local_iterator_equivalent_keys;
        template <typename Alloc> class hash_const_local_iterator_equivalent_keys;
        class iterator_access;





        template <typename Alloc>
        class hash_local_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_equivalent_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_const_local_iterator_equivalent_keys<Alloc> const_local_iterator;

            friend class hash_const_local_iterator_equivalent_keys<Alloc>;
            ptr ptr_;

        public:
            hash_local_iterator_equivalent_keys() : ptr_() {
                ;
            }
            explicit hash_local_iterator_equivalent_keys(ptr x) : ptr_(x) {}
            typename allocator_reference<Alloc>::type operator*() const
                { return data::get_value(ptr_); }
            value_type* operator->() const { return &data::get_value(ptr_); }
            hash_local_iterator_equivalent_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_local_iterator_equivalent_keys operator++(int) { hash_local_iterator_equivalent_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(hash_local_iterator_equivalent_keys x) const { return ptr_ == x.ptr_; }
            bool operator==(const_local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator!=(hash_local_iterator_equivalent_keys x) const { return ptr_ != x.ptr_; }
            bool operator!=(const_local_iterator x) const { return ptr_ != x.ptr_; }
        };

        template <typename Alloc>
        class hash_const_local_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_equivalent_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_local_iterator_equivalent_keys<Alloc> local_iterator;
            friend class hash_local_iterator_equivalent_keys<Alloc>;
            ptr ptr_;

        public:
            hash_const_local_iterator_equivalent_keys() : ptr_() {
                ;
            }
            explicit hash_const_local_iterator_equivalent_keys(ptr x) : ptr_(x) {}
            hash_const_local_iterator_equivalent_keys(local_iterator x) : ptr_(x.ptr_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return data::get_value(ptr_); }
            value_type const* operator->() const { return &data::get_value(ptr_); }
            hash_const_local_iterator_equivalent_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_const_local_iterator_equivalent_keys operator++(int) { hash_const_local_iterator_equivalent_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator==(hash_const_local_iterator_equivalent_keys x) const { return ptr_ == x.ptr_; }
            bool operator!=(local_iterator x) const { return ptr_ != x.ptr_; }
            bool operator!=(hash_const_local_iterator_equivalent_keys x) const { return ptr_ != x.ptr_; }
        };






        template <typename Alloc>
        class hash_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_equivalent_keys<Alloc>::iterator_base base;
            typedef hash_const_iterator_equivalent_keys<Alloc> const_iterator;
            friend class hash_const_iterator_equivalent_keys<Alloc>;
            base base_;

        public:

            hash_iterator_equivalent_keys() : base_() {}
            explicit hash_iterator_equivalent_keys(base const& x) : base_(x) {}
            typename allocator_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type* operator->() const { return &*base_; }
            hash_iterator_equivalent_keys& operator++() { base_.increment(); return *this; }
            hash_iterator_equivalent_keys operator++(int) { hash_iterator_equivalent_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(hash_iterator_equivalent_keys const& x) const { return base_ == x.base_; }
            bool operator==(const_iterator const& x) const { return base_ == x.base_; }
            bool operator!=(hash_iterator_equivalent_keys const& x) const { return base_ != x.base_; }
            bool operator!=(const_iterator const& x) const { return base_ != x.base_; }
        };

        template <typename Alloc>
        class hash_const_iterator_equivalent_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_equivalent_keys<Alloc>::iterator_base base;
            typedef hash_iterator_equivalent_keys<Alloc> iterator;
            friend class hash_iterator_equivalent_keys<Alloc>;
            friend class iterator_access;
            base base_;

        public:

            hash_const_iterator_equivalent_keys() : base_() {}
            explicit hash_const_iterator_equivalent_keys(base const& x) : base_(x) {}
            hash_const_iterator_equivalent_keys(iterator const& x) : base_(x.base_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type const* operator->() const { return &*base_; }
            hash_const_iterator_equivalent_keys& operator++() { base_.increment(); return *this; }
            hash_const_iterator_equivalent_keys operator++(int) { hash_const_iterator_equivalent_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(iterator const& x) const { return base_ == x.base_; }
            bool operator==(hash_const_iterator_equivalent_keys const& x) const { return base_ == x.base_; }
            bool operator!=(iterator const& x) const { return base_ != x.base_; }
            bool operator!=(hash_const_iterator_equivalent_keys const& x) const { return base_ != x.base_; }
        };
    }
}
# 275 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4



# 1 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 1 3 4
# 23 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
namespace boost {
    namespace unordered_detail {






        template <typename Alloc>
        class hash_table_data_unique_keys
        {
        public:
            typedef hash_table_data_unique_keys data;

            struct node;
            struct bucket;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;

            typedef Alloc value_allocator;

            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, node>::type
                node_allocator;
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, bucket>::type
                bucket_allocator;

            typedef typename allocator_value_type<Alloc>::type value_type;
            typedef typename allocator_pointer<node_allocator>::type node_ptr;
            typedef typename allocator_pointer<bucket_allocator>::type bucket_ptr;
            typedef typename allocator_reference<value_allocator>::type reference;
            typedef typename allocator_reference<bucket_allocator>::type bucket_reference;

            typedef bucket_ptr link_ptr;





            struct bucket
            {
            private:
                bucket& operator=(bucket const&);
            public:
                link_ptr next_;

                bucket() : next_()
                {
                    ;
                }

                bucket(bucket const& x) : next_(x.next_)
                {

                    ((!x.next_) ? static_cast<void> (0) : __assert_fail ("!x.next_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 78, __PRETTY_FUNCTION__));
                }

                bool empty() const
                {
                    return !this->next_;
                }
            };



            struct value_base {
                typename boost::aligned_storage<
                    sizeof(value_type),
                    ::boost::alignment_of<value_type>::value>::type data_;

                void* address() { return this; }
            };





            struct node : value_base, bucket {
# 112 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
                value_type& value() {
                    return *static_cast<value_type*>(this->address());
                }
            };





            struct allocators
            {
                node_allocator node_alloc_;
                bucket_allocator bucket_alloc_;

                allocators(value_allocator const& a)
                    : node_alloc_(a), bucket_alloc_(a)
                {}

                void destroy(link_ptr ptr)
                {
                    node* raw_ptr = static_cast<node*>(&*ptr);
                    boost::unordered_detail::destroy(&raw_ptr->value());
                    node_ptr n(node_alloc_.address(*raw_ptr));
                    node_alloc_.destroy(n);
                    node_alloc_.deallocate(n, 1);
                }

                void swap(allocators& x)
                {
                    boost::swap(node_alloc_, x.node_alloc_);
                    boost::swap(bucket_alloc_, x.bucket_alloc_);
                }

                bool operator==(allocators const& x)
                {
                    return node_alloc_ == x.node_alloc_;
                }
            };





            class node_constructor
            {
                allocators& allocators_;

                node_ptr node_;
                bool node_constructed_;
                bool value_constructed_;

            public:

                node_constructor(allocators& a)
                    : allocators_(a),
                    node_(), node_constructed_(false), value_constructed_(false)
                {
                }

                ~node_constructor()
                {
                    if (node_) {
                        if (value_constructed_) {
                            boost::unordered_detail::destroy(&node_->value());
                        }

                        if (node_constructed_)
                            allocators_.node_alloc_.destroy(node_);
                        allocators_.node_alloc_.deallocate(node_, 1);
                    }
                }

                void construct_preamble()
                {
                    if(!node_) {
                        node_constructed_ = false;
                        value_constructed_ = false;

                        node_ = allocators_.node_alloc_.allocate(1);
                        allocators_.node_alloc_.construct(node_, node());
                        node_constructed_ = true;
                    }
                    else {
                        ((node_constructed_ && value_constructed_) ? static_cast<void> (0) : __assert_fail ("node_constructed_ && value_constructed_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 195, __PRETTY_FUNCTION__));
                        boost::unordered_detail::destroy(&node_->value());
                        value_constructed_ = false;
                    }
                }


                template <typename... Args>
                void construct(Args&&... args)
                {
                    construct_preamble();
                    new(node_->address()) value_type(std::forward<Args>(args)...);
                    value_constructed_ = true;
                }
# 273 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
                template <typename K, typename M>
                void construct_pair(K const& k, M*)
                {
                    construct_preamble();
                    new(node_->address()) value_type(k, M());
                    value_constructed_ = true;
                }

                node_ptr get() const
                {
                    ((node_) ? static_cast<void> (0) : __assert_fail ("node_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 283, __PRETTY_FUNCTION__));
                    return node_;
                }


                link_ptr release()
                {
                    node_ptr p = node_;
                    unordered_detail::reset(node_);
                    return link_ptr(allocators_.bucket_alloc_.address(*p));
                }

            private:
                node_constructor(node_constructor const&);
                node_constructor& operator=(node_constructor const&);
            };
# 313 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            static inline link_ptr& next_group(link_ptr n) {
                ((n) ? static_cast<void> (0) : __assert_fail ("n", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 314, __PRETTY_FUNCTION__));
                return n->next_;
            }



            static inline node& get_node(link_ptr p) {
                ((p) ? static_cast<void> (0) : __assert_fail ("p", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 321, __PRETTY_FUNCTION__));
                return *static_cast<node*>(&*p);
            }


            static inline reference get_value(link_ptr p) {
                return get_node(p).value();
            }

            class iterator_base
            {
                typedef hash_table_data_unique_keys<Alloc> data;
            public:
                bucket_ptr bucket_;
                link_ptr node_;

                iterator_base()
                    : bucket_(), node_()
                {
                    ;
                    ;
                }

                explicit iterator_base(bucket_ptr b)
                    : bucket_(b), node_(b->next_) {}

                iterator_base(bucket_ptr b, link_ptr n)
                    : bucket_(b), node_(n) {}

                bool operator==(iterator_base const& x) const
                {
                    return node_ == x.node_;
                }

                bool operator!=(iterator_base const& x) const
                {
                    return node_ != x.node_;
                }

                reference operator*() const
                {
                    return get_value(node_);
                }

                void increment()
                {
                    ((bucket_) ? static_cast<void> (0) : __assert_fail ("bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 367, __PRETTY_FUNCTION__));
                    node_ = node_->next_;

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }

                void increment_group()
                {
                    node_ = data::next_group(node_);

                    while (!node_) {
                        ++bucket_;
                        node_ = bucket_->next_;
                    }
                }
            };



            allocators allocators_;
            bucket_ptr buckets_;
            bucket_manager bucket_manager_;
            bucket_ptr cached_begin_bucket_;
            size_type size_;



            hash_table_data_unique_keys(size_type n, value_allocator const& a)
              : allocators_(a),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_unique_keys(hash_table_data_unique_keys const& x, size_type n)
              : allocators_(x.allocators_),
                buckets_(), bucket_manager_(n),
                cached_begin_bucket_(), size_(0)
            {
                ;
                create_buckets();
            }

            hash_table_data_unique_keys(hash_table_data_unique_keys& x, move_tag)
                : allocators_(x.allocators_),
                buckets_(x.buckets_), bucket_manager_(x.bucket_manager_),
                cached_begin_bucket_(x.cached_begin_bucket_), size_(x.size_)
            {
                unordered_detail::reset(x.buckets_);
            }

            hash_table_data_unique_keys(hash_table_data_unique_keys& x,
                    value_allocator const& a, size_type n, move_tag)
                : allocators_(a), buckets_(), bucket_manager_(),
                cached_begin_bucket_(), size_(0)
            {
                if(allocators_ == x.allocators_) {
                    buckets_ = x.buckets_;
                    bucket_manager_ = x.bucket_manager_;
                    cached_begin_bucket_ = x.cached_begin_bucket_;
                    size_ = x.size_;
                    unordered_detail::reset(x.buckets_);
                }
                else {
                    ;
                    bucket_manager_ = bucket_manager(n);
                    create_buckets();
                }
            }


            ~hash_table_data_unique_keys()
            {
                delete_buckets();
            }

            void create_buckets() {
                size_type bucket_count = bucket_manager_.bucket_count();



                allocator_array_constructor<bucket_allocator>
                    constructor(allocators_.bucket_alloc_);


                constructor.construct(bucket(), bucket_count + 1);

                cached_begin_bucket_ = constructor.get() + static_cast<difference_type>(bucket_count);


                cached_begin_bucket_->next_ = link_ptr(cached_begin_bucket_);



                buckets_ = constructor.release();
            }


            void delete_buckets()
            {
                if(buckets_) {
                    bucket_ptr begin = cached_begin_bucket_;
                    bucket_ptr end = buckets_end();
                    while(begin != end) {
                        clear_bucket(begin);
                        ++begin;
                    }


                    ++end;
                    for(begin = buckets_; begin != end; ++begin)
                        allocators_.bucket_alloc_.destroy(begin);

                    allocators_.bucket_alloc_.deallocate(buckets_,
                        bucket_manager_.bucket_count() + 1);
                }
            }

        private:

            hash_table_data_unique_keys(hash_table_data_unique_keys const&);
            hash_table_data_unique_keys& operator=(hash_table_data_unique_keys const&);

        public:


            void swap(hash_table_data_unique_keys& other)
            {
                std::swap(buckets_, other.buckets_);
                std::swap(bucket_manager_, other.bucket_manager_);
                std::swap(cached_begin_bucket_, other.cached_begin_bucket_);
                std::swap(size_, other.size_);
            }


            void move(hash_table_data_unique_keys& other)
            {
                delete_buckets();
                buckets_ = other.buckets_;
                unordered_detail::reset(other.buckets_);
                bucket_manager_ = other.bucket_manager_;
                cached_begin_bucket_ = other.cached_begin_bucket_;
                size_ = other.size_;
            }




            size_type bucket_from_hash(size_type hashed) const
            {
                return bucket_manager_.bucket_from_hash(hashed);
            }




            bucket_ptr bucket_ptr_from_hash(size_type hashed) const
            {
                return buckets_ + static_cast<difference_type>(
                    bucket_manager_.bucket_from_hash(hashed));
            }





            bucket_ptr buckets_end() const
            {
                return buckets_ + static_cast<difference_type>(bucket_manager_.bucket_count());
            }

            iterator_base begin() const
            {
                return size_
                    ? iterator_base(cached_begin_bucket_)
                    : end();
            }

            iterator_base end() const
            {
                return iterator_base(buckets_end());
            }

            link_ptr begin(size_type n) const
            {
                return (buckets_ + static_cast<difference_type>(n))->next_;
            }

            link_ptr end(size_type) const
            {
                return unordered_detail::null_ptr<link_ptr>();
            }

            link_ptr begin(bucket_ptr b) const
            {
                return b->next_;
            }




            static inline size_type node_count(link_ptr it)
            {
                size_type count = 0;
                while(it) {
                    ++count;
                    it = it->next_;
                }
                return count;
            }

            static inline size_type node_count(link_ptr it1, link_ptr it2)
            {
                size_type count = 0;
                while(it1 != it2) {
                    ++count;
                    it1 = it1->next_;
                }
                return count;
            }

            size_type bucket_size(size_type n) const
            {
                return node_count(begin(n));
            }







            static inline size_type group_count(link_ptr)
            {
                return 1;
            }
# 634 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            static link_ptr* get_for_erase(iterator_base r)
            {
                link_ptr n = r.node_;
                link_ptr* it = &r.bucket_->next_;
                while(*it != n) it = &(*it)->next_;
                return it;
            }
# 688 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void link_node(link_ptr n, bucket_ptr base)
            {
                n->next_ = base->next_;
                base->next_ = n;
                ++size_;
                if(base < cached_begin_bucket_) cached_begin_bucket_ = base;
            }

            link_ptr link_node_in_bucket(node_constructor& a, bucket_ptr base)
            {
                link_ptr n = a.release();
                link_node(n, base);
                return n;
            }

            void link_group(link_ptr n, bucket_ptr base, size_type)
            {
                link_node(n, base);
            }
# 748 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void unlink_node(iterator_base n)
            {
                link_ptr* pos = get_for_erase(n);
                *pos = (*pos)->next_;
                --size_;
            }

            size_type unlink_group(link_ptr* pos)
            {
                *pos = (*pos)->next_;
                --size_;
                return 1;
            }


            void unlink_nodes(iterator_base n)
            {
                link_ptr* it = get_for_erase(n);
                split_group(*it);
                unordered_detail::reset(*it);
                size_ -= node_count(n.node_);
            }

            void unlink_nodes(iterator_base begin, iterator_base end)
            {
                ((begin.bucket_ == end.bucket_) ? static_cast<void> (0) : __assert_fail ("begin.bucket_ == end.bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 773, __PRETTY_FUNCTION__));
                size_ -= node_count(begin.node_, end.node_);
                link_ptr* it = get_for_erase(begin);
                split_group(*it, end.node_);
                *it = end.node_;
            }

            void unlink_nodes(bucket_ptr base, iterator_base end)
            {
                ((base == end.bucket_) ? static_cast<void> (0) : __assert_fail ("base == end.bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 782, __PRETTY_FUNCTION__));

                split_group(end.node_);

                link_ptr ptr(base->next_);
                base->next_ = end.node_;

                size_ -= node_count(ptr, end.node_);
            }
# 828 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            static inline void split_group(link_ptr)
            {
            }

            static inline void split_group(link_ptr, link_ptr)
            {
            }
# 858 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void copy_group(link_ptr it, bucket_ptr dst)
            {
                node_constructor a(allocators_);

                a.construct(get_value(it));
                link_node_in_bucket(a, dst);
            }
# 874 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void delete_to_bucket_end(link_ptr begin)
            {
                while(begin) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }

            void delete_nodes(link_ptr begin, link_ptr end)
            {
                while(begin != end) {
                    link_ptr node = begin;
                    begin = begin->next_;
                    allocators_.destroy(node);
                }
            }







            void delete_group(link_ptr node)
            {
                allocators_.destroy(node);
            }
# 910 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void clear_bucket(bucket_ptr b)
            {
                link_ptr first_node = b->next_;
                unordered_detail::reset(b->next_);
                delete_to_bucket_end(first_node);
            }

            void clear()
            {
                bucket_ptr begin = cached_begin_bucket_;
                bucket_ptr end = buckets_end();

                size_ = 0;
                cached_begin_bucket_ = end;

                while(begin != end) {
                    clear_bucket(begin);
                    ++begin;
                }
            }





            iterator_base erase(iterator_base r)
            {
                ((r != end()) ? static_cast<void> (0) : __assert_fail ("r != end()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 937, __PRETTY_FUNCTION__));
                iterator_base next = r;
                next.increment();
                unlink_node(r);
                allocators_.destroy(r.node_);

                recompute_begin_bucket(r.bucket_, next.bucket_);
                return next;
            }

            iterator_base erase_range(iterator_base r1, iterator_base r2)
            {
                if(r1 != r2)
                {
                    ((r1 != end()) ? static_cast<void> (0) : __assert_fail ("r1 != end()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 951, __PRETTY_FUNCTION__));

                    if (r1.bucket_ == r2.bucket_) {
                        unlink_nodes(r1, r2);
                        delete_nodes(r1.node_, r2.node_);




                        ((!r1.bucket_->empty()) ? static_cast<void> (0) : __assert_fail ("!r1.bucket_->empty()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 960, __PRETTY_FUNCTION__));
                    }
                    else {
                        ((r1.bucket_ < r2.bucket_) ? static_cast<void> (0) : __assert_fail ("r1.bucket_ < r2.bucket_", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 963, __PRETTY_FUNCTION__));

                        unlink_nodes(r1);
                        delete_to_bucket_end(r1.node_);

                        bucket_ptr i = r1.bucket_;
                        for(++i; i != r2.bucket_; ++i) {
                            size_ -= node_count(i->next_);
                            clear_bucket(i);
                        }

                        if(r2 != end()) {
                            link_ptr first = r2.bucket_->next_;
                            unlink_nodes(r2.bucket_, r2);
                            delete_nodes(first, r2.node_);
                        }



                        recompute_begin_bucket(r1.bucket_, r2.bucket_);
                    }
                }

                return r2;
            }
# 996 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void recompute_begin_bucket(bucket_ptr b)
            {
                ((!(b < cached_begin_bucket_)) ? static_cast<void> (0) : __assert_fail ("!(b < cached_begin_bucket_)", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 998, __PRETTY_FUNCTION__));

                if(b == cached_begin_bucket_)
                {
                    if (size_ != 0) {
                        while (cached_begin_bucket_->empty())
                            ++cached_begin_bucket_;
                    } else {
                        cached_begin_bucket_ = buckets_end();
                    }
                }
            }





            void recompute_begin_bucket(bucket_ptr b1, bucket_ptr b2)
            {
                ((!(b1 < cached_begin_bucket_) && !(b2 < b1)) ? static_cast<void> (0) : __assert_fail ("!(b1 < cached_begin_bucket_) && !(b2 < b1)", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1017, __PRETTY_FUNCTION__));
                ((b2 == buckets_end() || !b2->empty()) ? static_cast<void> (0) : __assert_fail ("b2 == buckets_end() || !b2->empty()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1018, __PRETTY_FUNCTION__));

                if(b1 == cached_begin_bucket_ && b1->empty())
                    cached_begin_bucket_ = b2;
            }

            size_type erase_group(link_ptr* it, bucket_ptr bucket)
            {
                link_ptr pos = *it;
                size_type count = unlink_group(it);
                delete_group(pos);

                this->recompute_begin_bucket(bucket);

                return count;
            }
        };
# 1050 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
        template <typename ValueType, typename KeyType,
            typename Hash, typename Pred,
            typename Alloc>
        class hash_table_unique_keys
        {
            typedef hash_table_data_unique_keys<Alloc> data;

            typedef typename data::node_constructor node_constructor;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

        public:

            typedef typename data::value_allocator value_allocator;
            typedef typename data::node_allocator node_allocator;



            typedef KeyType key_type;
            typedef Hash hasher;
            typedef Pred key_equal;
            typedef ValueType value_type;
            typedef std::size_t size_type;
            typedef std::ptrdiff_t difference_type;



            typedef typename data::iterator_base iterator_base;

        private:


            typedef boost::unordered_detail::buffered_functions<Hash, Pred>
                function_store;
            typedef typename function_store::functions functions;
            typedef typename function_store::functions_ptr
                functions_ptr;

            function_store functions_;
            float mlf_;
            size_type max_load_;

        public:

            data data_;






            hash_table_unique_keys(size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                mlf_(1.0f),
                data_(n, a)
            {
                calculate_max_load();
            }
# 1121 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            template <typename I>
            size_type initial_size(I i, I j, size_type n,
                    boost::forward_traversal_tag)
            {

                return (std::max)(static_cast<size_type>(unordered_detail::distance(i, j)) + 1, n);
            }

            template <typename I>
            size_type initial_size(I, I, size_type n,
                    boost::incrementable_traversal_tag)
            {
                return n;
            }

            template <typename I>
            size_type initial_size(I i, I j, size_type n)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                return initial_size(i, j, n, iterator_traversal_tag);
            }

            template <typename I>
            hash_table_unique_keys(I i, I j, size_type n,
                    hasher const& hf, key_equal const& eq,
                    value_allocator const& a)
                : functions_(hf, eq),
                  mlf_(1.0f),
                  data_(initial_size(i, j, n), a)
            {
                calculate_max_load();


                insert_range(i, j);
            }



            hash_table_unique_keys(hash_table_unique_keys const& x)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, x.min_buckets_for_size(x.size()))
            {
                calculate_max_load();



                x.copy_buckets_to(data_);
            }



            hash_table_unique_keys(hash_table_unique_keys const& x,
                    value_allocator const& a)
                : functions_(x.functions_),
                mlf_(x.mlf_),
                data_(x.min_buckets_for_size(x.size()), a)
            {
                calculate_max_load();



                x.copy_buckets_to(data_);
            }



            hash_table_unique_keys(hash_table_unique_keys& x, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, m)
            {
                calculate_max_load();
            }

            hash_table_unique_keys(hash_table_unique_keys& x,
                    value_allocator const& a, move_tag m)
                : functions_(x.functions_),
                  mlf_(x.mlf_),
                  data_(x.data_, a,
                        x.min_buckets_for_size(x.size()), m)
            {
                calculate_max_load();

                if(x.data_.buckets_) {


                    x.copy_buckets_to(data_);
                }
            }
# 1220 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            hash_table_unique_keys& operator=(hash_table_unique_keys const& x)
            {
                if(this != &x)
                {
                    data_.clear();
                    functions_.set(functions_.buffer(x.functions_));

                    mlf_ = x.mlf_;
                    calculate_max_load();
                    reserve(x.size());
                    x.copy_buckets_to(data_);
                }

                return *this;
            }
# 1250 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void swap(hash_table_unique_keys& x)
            {





                if(this == &x) return;




                functions_ptr new_func_this = functions_.buffer(x.functions_);
                functions_ptr new_func_that = x.functions_.buffer(functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.swap(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    x.copy_buckets_to(new_this);

                    data new_that(x.data_, min_buckets_for_size(data_.size_));
                    copy_buckets_to(new_that);


                    data_.swap(new_this);
                    x.data_.swap(new_that);
                }


                std::swap(mlf_, x.mlf_);

                functions_.set(new_func_this);
                x.functions_.set(new_func_that);

                calculate_max_load();
                x.calculate_max_load();
            }
# 1302 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            void move(hash_table_unique_keys& x)
            {



                functions_ptr new_func_this = functions_.buffer(x.functions_);

                if(data_.allocators_ == x.data_.allocators_) {
                    data_.move(x.data_);
                }
                else {



                    data new_this(data_, x.min_buckets_for_size(x.data_.size_));
                    x.copy_buckets_to(new_this);


                    data_.move(new_this);
                }


                mlf_ = x.mlf_;
                functions_.set(new_func_this);
                calculate_max_load();
            }




            node_allocator get_allocator() const
            {
                return data_.allocators_.node_alloc_;
            }


            hasher const& hash_function() const
            {
                return functions_.current().hash_function();
            }


            key_equal const& key_eq() const
            {
                return functions_.current().key_eq();
            }


            size_type size() const
            {
                return data_.size_;
            }


            bool empty() const
            {
                return data_.size_ == 0;
            }


            size_type max_size() const
            {
                using namespace std;


                return double_to_size_t(ceil(
                        (double) mlf_ * max_bucket_count())) - 1;
            }


            size_type bucket(key_type const& k) const
            {

                return data_.bucket_from_hash(hash_function()(k));
            }



            bucket_ptr get_bucket(key_type const& k) const
            {
                return data_.buckets_ + static_cast<difference_type>(bucket(k));
            }


            size_type bucket_count() const
            {
                return data_.bucket_manager_.bucket_count();
            }


            size_type max_bucket_count() const
            {

                return prev_prime(data_.allocators_.bucket_alloc_.max_size() - 1);
            }

        private:


            size_type min_buckets_for_size(size_type n) const
            {
                ((mlf_ != 0) ? static_cast<void> (0) : __assert_fail ("mlf_ != 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1403, __PRETTY_FUNCTION__));

                using namespace std;







                return double_to_size_t(floor(n / (double) mlf_)) + 1;
            }


            void calculate_max_load()
            {
                using namespace std;



                max_load_ = double_to_size_t(ceil(
                        (double) mlf_ * data_.bucket_manager_.bucket_count()));
            }


            bool reserve(size_type n)
            {
                bool need_to_reserve = n >= max_load_;

                if (need_to_reserve) rehash_impl(min_buckets_for_size(n));
                ((n < max_load_ || n > max_size()) ? static_cast<void> (0) : __assert_fail ("n < max_load_ || n > max_size()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1433, __PRETTY_FUNCTION__));
                return need_to_reserve;
            }


            bool reserve_for_insert(size_type n)
            {
                bool need_to_reserve = n >= max_load_;

                if (need_to_reserve) {
                    size_type s = size();
                    s = s + (s >> 1);
                    s = s > n ? s : n;
                    rehash_impl(min_buckets_for_size(s));
                }
                ((n < max_load_ || n > max_size()) ? static_cast<void> (0) : __assert_fail ("n < max_load_ || n > max_size()", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1448, __PRETTY_FUNCTION__));
                return need_to_reserve;
            }

        public:


            float max_load_factor() const
            {
                return mlf_;
            }


            void max_load_factor(float z)
            {
                ((z > 0) ? static_cast<void> (0) : __assert_fail ("z > 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1463, __PRETTY_FUNCTION__));
                mlf_ = (std::max)(z, minimum_max_load_factor);
                calculate_max_load();
            }


            float load_factor() const
            {
                ((data_.bucket_manager_.bucket_count() != 0) ? static_cast<void> (0) : __assert_fail ("data_.bucket_manager_.bucket_count() != 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1471, __PRETTY_FUNCTION__));
                return static_cast<float>(data_.size_)
                    / static_cast<float>(data_.bucket_manager_.bucket_count());
            }
# 1484 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            struct no_key {
                no_key() {}
                template <class T> no_key(T const&) {}
            };





            static no_key extract_key()
            {
                return no_key();
            }



            static key_type const& extract_key(value_type const& v)
            {
                return extract(v, (type_wrapper<value_type>*)0);
            }

            static key_type const& extract(value_type const& v,
                    type_wrapper<key_type>*)
            {
                return v;
            }

            static key_type const& extract(value_type const& v,
                    void*)
            {
                return v.first;
            }




            template <typename Arg>
            static typename
                boost::mpl::if_<boost::is_same<Arg, key_type>, key_type const&, no_key>::type
                extract_key(Arg const& k)
            {
                return k;
            }




            template <typename First, typename Second>
            static typename
                boost::mpl::if_<
                    boost::mpl::and_<
                        boost::mpl::not_<boost::is_same<key_type, value_type> >,
                        boost::is_same<key_type,
                            typename boost::remove_const<
                                typename boost::remove_reference<First>::type
                            >::type>
                    >,
                    key_type const&, no_key
                >::type extract_key(std::pair<First, Second> const& v)
            {
                return v.first;
            }




            template <typename Arg, typename Arg1, typename... Args>
            static typename
                boost::mpl::if_<
                    boost::mpl::and_<
                        boost::mpl::not_<boost::is_same<value_type, key_type> >,
                        boost::is_same<Arg, key_type>
                    >,
                    key_type const&, no_key
                >::type extract_key(Arg const& k, Arg1 const&, Args const&...)
            {
                return k;
            }
# 1579 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
        public:



            void rehash(size_type n)
            {
                using namespace std;


                size_type min_size = min_buckets_for_size(size());

                rehash_impl(min_size > n ? min_size : n);

                (((float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n) ? static_cast<void> (0) : __assert_fail ("(float) bucket_count() > (float) size() / max_load_factor() && bucket_count() >= n", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1593, __PRETTY_FUNCTION__));

            }

        private:



            void rehash_impl(size_type n)
            {
                n = next_prime(n);

                if (n == bucket_count())
                    return;

                data new_buckets(data_, n);
                move_buckets_to(new_buckets);
                new_buckets.swap(data_);
                calculate_max_load();
            }






            void move_buckets_to(data& dst)
            {
                ((dst.size_ == 0) ? static_cast<void> (0) : __assert_fail ("dst.size_ == 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1620, __PRETTY_FUNCTION__));


                data& src = this->data_;
                hasher const& hf = this->hash_function();
                bucket_ptr end = src.buckets_end();

                for(; src.cached_begin_bucket_ != end;
                        ++src.cached_begin_bucket_) {
                    bucket_ptr src_bucket = src.cached_begin_bucket_;
                    while(src_bucket->next_) {




                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(src_bucket->next_))));

                        link_ptr n = src_bucket->next_;
                        size_type count = src.unlink_group(&src_bucket->next_);
                        dst.link_group(n, dst_bucket, count);
                    }
                }
            }




            void copy_buckets_to(data& dst) const
            {
                ((dst.size_ == 0) ? static_cast<void> (0) : __assert_fail ("dst.size_ == 0", "/usr/include/boost/unordered/detail/hash_table_impl.hpp", 1650, __PRETTY_FUNCTION__));


                data const& src = this->data_;
                hasher const& hf = this->hash_function();
                bucket_ptr end = src.buckets_end();


                for(bucket_ptr i = src.cached_begin_bucket_; i != end; ++i) {

                    for(link_ptr it = src.begin(i);
                            it; it = data::next_group(it)) {

                        bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                                hf(extract_key(data::get_value(it))));

                        dst.copy_group(it, dst_bucket);
                    }
                }
            }

        public:
# 1858 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            value_type& operator[](key_type const& k)
            {
                static_assert(( !boost::is_same<value_type, key_type>::value), "( !boost::is_same<value_type, key_type>::value)");

                typedef typename value_type::second_type mapped_type;

                size_type hash_value = hash_function()(k);
                bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                link_ptr pos = find_iterator(bucket, k);

                if (pos)
                    return data::get_value(pos);
                else
                {




                    node_constructor a(data_.allocators_);
                    a.construct_pair(k, (mapped_type*) 0);



                    if(reserve_for_insert(size() + 1))
                        bucket = data_.bucket_ptr_from_hash(hash_value);



                    return data::get_value(data_.link_node_in_bucket(a, bucket));
                }
            }
# 1897 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            template<typename... Args>
            std::pair<iterator_base, bool> emplace(Args&&... args)
            {
                return emplace_impl(
                    extract_key(std::forward<Args>(args)...),
                    std::forward<Args>(args)...);
            }







            template<typename... Args>
            iterator_base emplace_hint(iterator_base const&, Args&&... args)
            {
                return emplace_impl(
                    extract_key(std::forward<Args>(args)...),
                    std::forward<Args>(args)...).first;
            }

            template<typename... Args>
            std::pair<iterator_base, bool> emplace_impl(key_type const& k, Args&&... args)
            {

                size_type hash_value = hash_function()(k);
                bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                link_ptr pos = find_iterator(bucket, k);

                if (pos) {

                    return std::pair<iterator_base, bool>(
                        iterator_base(bucket, pos), false);

                } else {





                    node_constructor a(data_.allocators_);
                    a.construct(std::forward<Args>(args)...);



                    if(reserve_for_insert(size() + 1))
                        bucket = data_.bucket_ptr_from_hash(hash_value);



                    return std::pair<iterator_base, bool>(iterator_base(bucket,
                        data_.link_node_in_bucket(a, bucket)), true);
                }
            }

            template<typename... Args>
            std::pair<iterator_base, bool> emplace_impl(no_key, Args&&... args)
            {


                node_constructor a(data_.allocators_);
                a.construct(std::forward<Args>(args)...);
                return emplace_impl_with_node(a);
            }
# 2056 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
            std::pair<iterator_base, bool> emplace_impl_with_node(node_constructor& a)
            {

                key_type const& k = extract_key(a.get()->value());
                size_type hash_value = hash_function()(k);
                bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                link_ptr pos = find_iterator(bucket, k);

                if (pos) {

                    return std::pair<iterator_base, bool>(
                        iterator_base(bucket, pos), false);
                } else {


                    if(reserve_for_insert(size() + 1))
                        bucket = data_.bucket_ptr_from_hash(hash_value);



                    return std::pair<iterator_base, bool>(iterator_base(bucket,
                        data_.link_node_in_bucket(a, bucket)), true);
                }
            }



            template <typename I>
            size_type insert_size(I i, I j, boost::forward_traversal_tag)
            {
                return unordered_detail::distance(i, j);
            }

            template <typename I>
            size_type insert_size(I, I, boost::incrementable_traversal_tag)
            {
                return 1;
            }

            template <typename I>
            size_type insert_size(I i, I j)
            {
                typename boost::iterator_traversal<I>::type
                    iterator_traversal_tag;
                return insert_size(i, j, iterator_traversal_tag);
            }



            template <typename InputIterator>
            void insert_range(InputIterator i, InputIterator j)
            {
                if(i != j)
                    return insert_range_impl(extract_key(*i), i, j);
            }

            template <typename InputIterator>
            void insert_range_impl(key_type const&, InputIterator i, InputIterator j)
            {
                node_constructor a(data_.allocators_);

                for (; i != j; ++i) {

                    size_type hash_value = hash_function()(extract_key(*i));
                    bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                    link_ptr pos = find_iterator(bucket, extract_key(*i));

                    if (!pos) {





                        a.construct(*i);



                        if(size() + 1 >= max_load_) {
                            reserve_for_insert(size() + insert_size(i, j));
                            bucket = data_.bucket_ptr_from_hash(hash_value);
                        }


                        data_.link_node_in_bucket(a, bucket);
                    }
                }
            }

            template <typename InputIterator>
            void insert_range_impl(no_key, InputIterator i, InputIterator j)
            {
                node_constructor a(data_.allocators_);

                for (; i != j; ++i) {

                    a.construct(*i);
                    key_type const& k = extract_key(a.get()->value());
                    size_type hash_value = hash_function()(extract_key(k));
                    bucket_ptr bucket = data_.bucket_ptr_from_hash(hash_value);
                    link_ptr pos = find_iterator(bucket, k);

                    if (!pos) {





                        if(size() + 1 >= max_load_) {
                            reserve_for_insert(size() + insert_size(i, j));
                            bucket = data_.bucket_ptr_from_hash(hash_value);
                        }


                        data_.link_node_in_bucket(a, bucket);
                    }
                }
            }

        public:




            size_type erase_key(key_type const& k)
            {

                bucket_ptr bucket = get_bucket(k);
                link_ptr* it = find_for_erase(bucket, k);


                return *it ? data_.erase_group(it, bucket) : 0;
            }




            size_type count(key_type const& k) const
            {
                link_ptr it = find_iterator(k);
                return it ? data::group_count(it) : 0;
            }




            iterator_base find(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return iterator_base(bucket, it);
                else
                    return data_.end();
            }

            value_type& at(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);

                if (it)
                    return data::get_value(it);
                else
                    throw std::out_of_range("Unable to find key in unordered_map.");
            }




            std::pair<iterator_base, iterator_base> equal_range(key_type const& k) const
            {
                bucket_ptr bucket = get_bucket(k);
                link_ptr it = find_iterator(bucket, k);
                if (it) {
                    iterator_base first(iterator_base(bucket, it));
                    iterator_base second(first);
                    second.increment_group();
                    return std::pair<iterator_base, iterator_base>(first, second);
                }
                else {
                    return std::pair<iterator_base, iterator_base>(
                            data_.end(), data_.end());
                }
            }


            bool equal(key_type const& k, value_type const& v) const
            {
                return key_eq()(k, extract_key(v));
            }


            link_ptr find_iterator(key_type const& k) const
            {
                return find_iterator(get_bucket(k), k);
            }


            link_ptr find_iterator(bucket_ptr bucket,
                    key_type const& k) const
            {
                link_ptr it = data_.begin(bucket);
                while (it && !equal(k, data::get_value(it))) {
                    it = data::next_group(it);
                }

                return it;
            }


            link_ptr* find_for_erase(bucket_ptr bucket, key_type const& k) const
            {
                link_ptr* it = &bucket->next_;
                while(*it && !equal(k, data::get_value(*it)))
                    it = &data::next_group(*it);

                return it;
            }
        };
# 2314 "/usr/include/boost/unordered/detail/hash_table_impl.hpp" 3 4
        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_unique_keys<A>*,
                typename hash_table_data_unique_keys<A>::link_ptr,
                typename hash_table_data_unique_keys<A>::link_ptr,
                KeyType*,
                type_wrapper<KeyType>*)
        {
            return true;
        }

        template <typename A, typename KeyType>
        inline bool group_equals(
                hash_table_data_unique_keys<A>*,
                typename hash_table_data_unique_keys<A>::link_ptr it1,
                typename hash_table_data_unique_keys<A>::link_ptr it2,
                KeyType*,
                void*)
        {
            typedef hash_table_data_unique_keys<A> data;
            return data::get_value(it1).second == data::get_value(it2).second;
        }


        template <typename V, typename K, typename H, typename P, typename A>
        bool equals(hash_table_unique_keys<V, K, H, P, A> const& t1,
                hash_table_unique_keys<V, K, H, P, A> const& t2)
        {
            typedef hash_table_data_unique_keys<A> data;
            typedef typename data::bucket_ptr bucket_ptr;
            typedef typename data::link_ptr link_ptr;

            if(t1.size() != t2.size()) return false;

            for(bucket_ptr i = t1.data_.cached_begin_bucket_,
                    j = t1.data_.buckets_end(); i != j; ++i)
            {
                for(link_ptr it(i->next_); it; it = data::next_group(it))
                {
                    link_ptr other_pos = t2.find_iterator(t2.extract_key(data::get_value(it)));
                    if(!other_pos ||
                        !group_equals((data*)0, it, other_pos, (K*)0, (type_wrapper<V>*)0))
                        return false;
                }
            }

            return true;
        }



        template <typename Alloc> class hash_iterator_unique_keys;
        template <typename Alloc> class hash_const_iterator_unique_keys;
        template <typename Alloc> class hash_local_iterator_unique_keys;
        template <typename Alloc> class hash_const_local_iterator_unique_keys;
        class iterator_access;





        template <typename Alloc>
        class hash_local_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_unique_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_const_local_iterator_unique_keys<Alloc> const_local_iterator;

            friend class hash_const_local_iterator_unique_keys<Alloc>;
            ptr ptr_;

        public:
            hash_local_iterator_unique_keys() : ptr_() {
                ;
            }
            explicit hash_local_iterator_unique_keys(ptr x) : ptr_(x) {}
            typename allocator_reference<Alloc>::type operator*() const
                { return data::get_value(ptr_); }
            value_type* operator->() const { return &data::get_value(ptr_); }
            hash_local_iterator_unique_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_local_iterator_unique_keys operator++(int) { hash_local_iterator_unique_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(hash_local_iterator_unique_keys x) const { return ptr_ == x.ptr_; }
            bool operator==(const_local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator!=(hash_local_iterator_unique_keys x) const { return ptr_ != x.ptr_; }
            bool operator!=(const_local_iterator x) const { return ptr_ != x.ptr_; }
        };

        template <typename Alloc>
        class hash_const_local_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef hash_table_data_unique_keys<Alloc> data;
            typedef typename data::link_ptr ptr;
            typedef hash_local_iterator_unique_keys<Alloc> local_iterator;
            friend class hash_local_iterator_unique_keys<Alloc>;
            ptr ptr_;

        public:
            hash_const_local_iterator_unique_keys() : ptr_() {
                ;
            }
            explicit hash_const_local_iterator_unique_keys(ptr x) : ptr_(x) {}
            hash_const_local_iterator_unique_keys(local_iterator x) : ptr_(x.ptr_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return data::get_value(ptr_); }
            value_type const* operator->() const { return &data::get_value(ptr_); }
            hash_const_local_iterator_unique_keys& operator++() { ptr_ = ptr_->next_; return *this; }
            hash_const_local_iterator_unique_keys operator++(int) { hash_const_local_iterator_unique_keys tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
            bool operator==(local_iterator x) const { return ptr_ == x.ptr_; }
            bool operator==(hash_const_local_iterator_unique_keys x) const { return ptr_ == x.ptr_; }
            bool operator!=(local_iterator x) const { return ptr_ != x.ptr_; }
            bool operator!=(hash_const_local_iterator_unique_keys x) const { return ptr_ != x.ptr_; }
        };






        template <typename Alloc>
        class hash_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_pointer<Alloc>::type,
                typename allocator_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_unique_keys<Alloc>::iterator_base base;
            typedef hash_const_iterator_unique_keys<Alloc> const_iterator;
            friend class hash_const_iterator_unique_keys<Alloc>;
            base base_;

        public:

            hash_iterator_unique_keys() : base_() {}
            explicit hash_iterator_unique_keys(base const& x) : base_(x) {}
            typename allocator_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type* operator->() const { return &*base_; }
            hash_iterator_unique_keys& operator++() { base_.increment(); return *this; }
            hash_iterator_unique_keys operator++(int) { hash_iterator_unique_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(hash_iterator_unique_keys const& x) const { return base_ == x.base_; }
            bool operator==(const_iterator const& x) const { return base_ == x.base_; }
            bool operator!=(hash_iterator_unique_keys const& x) const { return base_ != x.base_; }
            bool operator!=(const_iterator const& x) const { return base_ != x.base_; }
        };

        template <typename Alloc>
        class hash_const_iterator_unique_keys
            : public boost::iterator <
                std::forward_iterator_tag,
                typename allocator_value_type<Alloc>::type,
                std::ptrdiff_t,
                typename allocator_const_pointer<Alloc>::type,
                typename allocator_const_reference<Alloc>::type >
        {
        public:
            typedef typename allocator_value_type<Alloc>::type value_type;

        private:
            typedef typename hash_table_data_unique_keys<Alloc>::iterator_base base;
            typedef hash_iterator_unique_keys<Alloc> iterator;
            friend class hash_iterator_unique_keys<Alloc>;
            friend class iterator_access;
            base base_;

        public:

            hash_const_iterator_unique_keys() : base_() {}
            explicit hash_const_iterator_unique_keys(base const& x) : base_(x) {}
            hash_const_iterator_unique_keys(iterator const& x) : base_(x.base_) {}
            typename allocator_const_reference<Alloc>::type
                operator*() const { return *base_; }
            value_type const* operator->() const { return &*base_; }
            hash_const_iterator_unique_keys& operator++() { base_.increment(); return *this; }
            hash_const_iterator_unique_keys operator++(int) { hash_const_iterator_unique_keys tmp(base_); base_.increment(); return tmp; }
            bool operator==(iterator const& x) const { return base_ == x.base_; }
            bool operator==(hash_const_iterator_unique_keys const& x) const { return base_ == x.base_; }
            bool operator!=(iterator const& x) const { return base_ != x.base_; }
            bool operator!=(hash_const_iterator_unique_keys const& x) const { return base_ != x.base_; }
        };
    }
}
# 279 "/usr/include/boost/unordered/detail/hash_table.hpp" 2 3 4


namespace boost {
    namespace unordered_detail {
        class iterator_access
        {
        public:
            template <class Iterator>
            static typename Iterator::base const& get(Iterator const& it) {
                return it.base_;
            }
        };

        template <class ValueType, class KeyType,
            class Hash, class Pred, class Alloc>
        class hash_types_unique_keys
        {
        public:
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, ValueType>::type
                value_allocator;

            typedef hash_table_unique_keys<ValueType, KeyType, Hash, Pred,
                    value_allocator> hash_table;
            typedef hash_table_data_unique_keys<value_allocator> data;
            typedef typename data::iterator_base iterator_base;

            typedef hash_const_local_iterator_unique_keys<value_allocator> const_local_iterator;
            typedef hash_local_iterator_unique_keys<value_allocator> local_iterator;
            typedef hash_const_iterator_unique_keys<value_allocator> const_iterator;
            typedef hash_iterator_unique_keys<value_allocator> iterator;

            typedef typename data::size_type size_type;
            typedef std::ptrdiff_t difference_type;
        };

        template <class ValueType, class KeyType,
            class Hash, class Pred, class Alloc>
        class hash_types_equivalent_keys
        {
        public:
            typedef typename
                boost::unordered_detail::rebind_wrap<Alloc, ValueType>::type
                value_allocator;

            typedef hash_table_equivalent_keys<ValueType, KeyType, Hash, Pred,
                    value_allocator> hash_table;
            typedef hash_table_data_equivalent_keys<value_allocator> data;
            typedef typename data::iterator_base iterator_base;

            typedef hash_const_local_iterator_equivalent_keys<value_allocator> const_local_iterator;
            typedef hash_local_iterator_equivalent_keys<value_allocator> local_iterator;
            typedef hash_const_iterator_equivalent_keys<value_allocator> const_iterator;
            typedef hash_iterator_equivalent_keys<value_allocator> iterator;

            typedef typename data::size_type size_type;
            typedef std::ptrdiff_t difference_type;
        };
    }
}
# 19 "/usr/include/boost/unordered/unordered_map.hpp" 2 3 4
# 37 "/usr/include/boost/unordered/unordered_map.hpp" 3 4
namespace boost
{
    template <class Key, class T, class Hash, class Pred, class Alloc>
    class unordered_map
    {



        typedef boost::unordered_detail::hash_types_unique_keys<
            std::pair<const Key, T>, Key, Hash, Pred, Alloc
        > implementation;

        typename implementation::hash_table base;

    public:



        typedef Key key_type;
        typedef std::pair<const Key, T> value_type;
        typedef T mapped_type;
        typedef Hash hasher;
        typedef Pred key_equal;

        typedef Alloc allocator_type;
        typedef typename allocator_type::pointer pointer;
        typedef typename allocator_type::const_pointer const_pointer;
        typedef typename allocator_type::reference reference;
        typedef typename allocator_type::const_reference const_reference;

        typedef typename implementation::size_type size_type;
        typedef typename implementation::difference_type difference_type;

        typedef typename implementation::iterator iterator;
        typedef typename implementation::const_iterator const_iterator;
        typedef typename implementation::local_iterator local_iterator;
        typedef typename implementation::const_local_iterator const_local_iterator;



        explicit unordered_map(
                size_type n = boost::unordered_detail::default_initial_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
            : base(n, hf, eql, a)
        {
        }

        explicit unordered_map(allocator_type const& a)
            : base(boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), a)
        {
        }

        unordered_map(unordered_map const& other, allocator_type const& a)
            : base(other.base, a)
        {
        }

        template <class InputIterator>
        unordered_map(InputIterator f, InputIterator l)
            : base(f, l, boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), allocator_type())
        {
        }

        template <class InputIterator>
        unordered_map(InputIterator f, InputIterator l,
                size_type n,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal())
            : base(f, l, n, hf, eql, allocator_type())
        {
        }

        template <class InputIterator>
        unordered_map(InputIterator f, InputIterator l,
                size_type n,
                const hasher &hf,
                const key_equal &eql,
                const allocator_type &a)
            : base(f, l, n, hf, eql, a)
        {
        }

        ~unordered_map() {}


        unordered_map(unordered_map&& other)
            : base(other.base, boost::unordered_detail::move_tag())
        {
        }

        unordered_map(unordered_map&& other, allocator_type const& a)
            : base(other.base, a, boost::unordered_detail::move_tag())
        {
        }

        unordered_map& operator=(unordered_map&& x)
        {
            base.move(x.base);
            return *this;
        }
# 157 "/usr/include/boost/unordered/unordered_map.hpp" 3 4
        unordered_map(std::initializer_list<value_type> list,
                size_type n = boost::unordered_detail::default_initial_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
            : base(list.begin(), list.end(), n, hf, eql, a)
        {
        }

        unordered_map& operator=(std::initializer_list<value_type> list)
        {
            base.data_.clear();
            base.insert_range(list.begin(), list.end());
            return *this;
        }


    private:

        typename implementation::iterator_base const&
            get(const_iterator const& it)
        {
            return boost::unordered_detail::iterator_access::get(it);
        }

    public:

        allocator_type get_allocator() const
        {
            return base.get_allocator();
        }



        bool empty() const
        {
            return base.empty();
        }

        size_type size() const
        {
            return base.size();
        }

        size_type max_size() const
        {
            return base.max_size();
        }



        iterator begin()
        {
            return iterator(base.data_.begin());
        }

        const_iterator begin() const
        {
            return const_iterator(base.data_.begin());
        }

        iterator end()
        {
            return iterator(base.data_.end());
        }

        const_iterator end() const
        {
            return const_iterator(base.data_.end());
        }

        const_iterator cbegin() const
        {
            return const_iterator(base.data_.begin());
        }

        const_iterator cend() const
        {
            return const_iterator(base.data_.end());
        }




        template <class... Args>
        std::pair<iterator, bool> emplace(Args&&... args)
        {
            return boost::unordered_detail::pair_cast<iterator, bool>(
                base.emplace(std::forward<Args>(args)...));
        }

        template <class... Args>
        iterator emplace_hint(const_iterator hint, Args&&... args)
        {
            return iterator(base.emplace_hint(get(hint), std::forward<Args>(args)...));
        }
# 299 "/usr/include/boost/unordered/unordered_map.hpp" 3 4
        std::pair<iterator, bool> insert(const value_type& obj)
        {
            return boost::unordered_detail::pair_cast<iterator, bool>(
                    base.emplace(obj));
        }

        iterator insert(const_iterator hint, const value_type& obj)
        {
            return iterator(base.emplace_hint(get(hint), obj));
        }

        template <class InputIterator>
            void insert(InputIterator first, InputIterator last)
        {
            base.insert_range(first, last);
        }

        iterator erase(const_iterator position)
        {
            return iterator(base.data_.erase(get(position)));
        }

        size_type erase(const key_type& k)
        {
            return base.erase_key(k);
        }

        iterator erase(const_iterator first, const_iterator last)
        {
            return iterator(base.data_.erase_range(get(first), get(last)));
        }

        void clear()
        {
            base.data_.clear();
        }

        void swap(unordered_map& other)
        {
            base.swap(other.base);
        }



        hasher hash_function() const
        {
            return base.hash_function();
        }

        key_equal key_eq() const
        {
            return base.key_eq();
        }

        mapped_type& operator[](const key_type &k)
        {
            return base[k].second;
        }

        mapped_type& at(const key_type& k)
        {
            return base.at(k).second;
        }

        mapped_type const& at(const key_type& k) const
        {
            return base.at(k).second;
        }



        iterator find(const key_type& k)
        {
            return iterator(base.find(k));
        }

        const_iterator find(const key_type& k) const
        {
            return const_iterator(base.find(k));
        }

        size_type count(const key_type& k) const
        {
            return base.count(k);
        }

        std::pair<iterator, iterator>
            equal_range(const key_type& k)
        {
            return boost::unordered_detail::pair_cast<iterator, iterator>(
                    base.equal_range(k));
        }

        std::pair<const_iterator, const_iterator>
            equal_range(const key_type& k) const
        {
            return boost::unordered_detail::pair_cast<const_iterator, const_iterator>(
                    base.equal_range(k));
        }



        size_type bucket_count() const
        {
            return base.bucket_count();
        }

        size_type max_bucket_count() const
        {
            return base.max_bucket_count();
        }

        size_type bucket_size(size_type n) const
        {
            return base.data_.bucket_size(n);
        }

        size_type bucket(const key_type& k) const
        {
            return base.bucket(k);
        }

        local_iterator begin(size_type n)
        {
            return local_iterator(base.data_.begin(n));
        }

        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        local_iterator end(size_type n)
        {
            return local_iterator(base.data_.end(n));
        }

        const_local_iterator end(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }

        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        const_local_iterator cend(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }



        float load_factor() const
        {
            return base.load_factor();
        }

        float max_load_factor() const
        {
            return base.max_load_factor();
        }

        void max_load_factor(float m)
        {
            base.max_load_factor(m);
        }

        void rehash(size_type n)
        {
            base.rehash(n);
        }





        friend bool operator==<Key, T, Hash, Pred, Alloc>(unordered_map const&, unordered_map const&);
        friend bool operator!=<Key, T, Hash, Pred, Alloc>(unordered_map const&, unordered_map const&);

    };

    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_map<K, T, H, P, A> const& m1,
        unordered_map<K, T, H, P, A> const& m2)
    {
        return boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_map<K, T, H, P, A> const& m1,
        unordered_map<K, T, H, P, A> const& m2)
    {
        return !boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_map<K, T, H, P, A> &m1,
            unordered_map<K, T, H, P, A> &m2)
    {
        m1.swap(m2);
    }

    template <class Key, class T, class Hash, class Pred, class Alloc>
    class unordered_multimap
    {



        typedef boost::unordered_detail::hash_types_equivalent_keys<
            std::pair<const Key, T>, Key, Hash, Pred, Alloc
        > implementation;

        typename implementation::hash_table base;

        public:



        typedef Key key_type;
        typedef std::pair<const Key, T> value_type;
        typedef T mapped_type;
        typedef Hash hasher;
        typedef Pred key_equal;

        typedef Alloc allocator_type;
        typedef typename allocator_type::pointer pointer;
        typedef typename allocator_type::const_pointer const_pointer;
        typedef typename allocator_type::reference reference;
        typedef typename allocator_type::const_reference const_reference;

        typedef typename implementation::size_type size_type;
        typedef typename implementation::difference_type difference_type;

        typedef typename implementation::iterator iterator;
        typedef typename implementation::const_iterator const_iterator;
        typedef typename implementation::local_iterator local_iterator;
        typedef typename implementation::const_local_iterator const_local_iterator;



        explicit unordered_multimap(
                size_type n = boost::unordered_detail::default_initial_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
          : base(n, hf, eql, a)
        {
        }

        explicit unordered_multimap(allocator_type const& a)
            : base(boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), a)
        {
        }

        unordered_multimap(unordered_multimap const& other, allocator_type const& a)
            : base(other.base, a)
        {
        }

        template <class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l)
            : base(f, l, boost::unordered_detail::default_initial_bucket_count,
                hasher(), key_equal(), allocator_type())
        {
        }

        template <class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l,
                size_type n,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal())
          : base(f, l, n, hf, eql, allocator_type())
        {
        }

        template <class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l,
                size_type n,
                const hasher &hf,
                const key_equal &eql,
                const allocator_type &a)
          : base(f, l, n, hf, eql, a)
        {
        }

        ~unordered_multimap() {}


        unordered_multimap(unordered_multimap&& other)
            : base(other.base, boost::unordered_detail::move_tag())
        {
        }

        unordered_multimap(unordered_multimap&& other, allocator_type const& a)
            : base(other.base, a, boost::unordered_detail::move_tag())
        {
        }

        unordered_multimap& operator=(unordered_multimap&& x)
        {
            base.move(x.base);
            return *this;
        }
# 621 "/usr/include/boost/unordered/unordered_map.hpp" 3 4
        unordered_multimap(std::initializer_list<value_type> list,
                size_type n = boost::unordered_detail::default_initial_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
            : base(list.begin(), list.end(), n, hf, eql, a)
        {
        }

        unordered_multimap& operator=(std::initializer_list<value_type> list)
        {
            base.data_.clear();
            base.insert_range(list.begin(), list.end());
            return *this;
        }



    private:

        typename implementation::iterator_base const&
            get(const_iterator const& it)
        {
            return boost::unordered_detail::iterator_access::get(it);
        }

    public:

        allocator_type get_allocator() const
        {
            return base.get_allocator();
        }



        bool empty() const
        {
            return base.empty();
        }

        size_type size() const
        {
            return base.size();
        }

        size_type max_size() const
        {
            return base.max_size();
        }



        iterator begin()
        {
            return iterator(base.data_.begin());
        }

        const_iterator begin() const
        {
            return const_iterator(base.data_.begin());
        }

        iterator end()
        {
            return iterator(base.data_.end());
        }

        const_iterator end() const
        {
            return const_iterator(base.data_.end());
        }

        const_iterator cbegin() const
        {
            return const_iterator(base.data_.begin());
        }

        const_iterator cend() const
        {
            return const_iterator(base.data_.end());
        }




        template <class... Args>
        iterator emplace(Args&&... args)
        {
            return iterator(base.emplace(std::forward<Args>(args)...));
        }

        template <class... Args>
        iterator emplace_hint(const_iterator hint, Args&&... args)
        {
            return iterator(base.emplace_hint(get(hint), std::forward<Args>(args)...));
        }
# 763 "/usr/include/boost/unordered/unordered_map.hpp" 3 4
        iterator insert(const value_type& obj)
        {
            return iterator(base.emplace(obj));
        }

        iterator insert(const_iterator hint, const value_type& obj)
        {
            return iterator(base.emplace_hint(get(hint), obj));
        }

        template <class InputIterator>
            void insert(InputIterator first, InputIterator last)
        {
            base.insert_range(first, last);
        }

        iterator erase(const_iterator position)
        {
            return iterator(base.data_.erase(get(position)));
        }

        size_type erase(const key_type& k)
        {
            return base.erase_key(k);
        }

        iterator erase(const_iterator first, const_iterator last)
        {
            return iterator(base.data_.erase_range(get(first), get(last)));
        }

        void clear()
        {
            base.data_.clear();
        }

        void swap(unordered_multimap& other)
        {
            base.swap(other.base);
        }



        hasher hash_function() const
        {
            return base.hash_function();
        }

        key_equal key_eq() const
        {
            return base.key_eq();
        }



        iterator find(const key_type& k)
        {
            return iterator(base.find(k));
        }

        const_iterator find(const key_type& k) const
        {
            return const_iterator(base.find(k));
        }

        size_type count(const key_type& k) const
        {
            return base.count(k);
        }

        std::pair<iterator, iterator>
            equal_range(const key_type& k)
        {
            return boost::unordered_detail::pair_cast<iterator, iterator>(
                    base.equal_range(k));
        }

        std::pair<const_iterator, const_iterator>
            equal_range(const key_type& k) const
        {
            return boost::unordered_detail::pair_cast<const_iterator, const_iterator>(
                    base.equal_range(k));
        }



        size_type bucket_count() const
        {
            return base.bucket_count();
        }

        size_type max_bucket_count() const
        {
            return base.max_bucket_count();
        }

        size_type bucket_size(size_type n) const
        {
            return base.data_.bucket_size(n);
        }

        size_type bucket(const key_type& k) const
        {
            return base.bucket(k);
        }

        local_iterator begin(size_type n)
        {
            return local_iterator(base.data_.begin(n));
        }

        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        local_iterator end(size_type n)
        {
            return local_iterator(base.data_.end(n));
        }

        const_local_iterator end(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }

        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(base.data_.begin(n));
        }

        const_local_iterator cend(size_type n) const
        {
            return const_local_iterator(base.data_.end(n));
        }



        float load_factor() const
        {
            return base.load_factor();
        }

        float max_load_factor() const
        {
            return base.max_load_factor();
        }

        void max_load_factor(float m)
        {
            base.max_load_factor(m);
        }

        void rehash(size_type n)
        {
            base.rehash(n);
        }





        friend bool operator==<Key, T, Hash, Pred, Alloc>(unordered_multimap const&, unordered_multimap const&);
        friend bool operator!=<Key, T, Hash, Pred, Alloc>(unordered_multimap const&, unordered_multimap const&);

    };

    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_multimap<K, T, H, P, A> const& m1,
        unordered_multimap<K, T, H, P, A> const& m2)
    {
        return boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_multimap<K, T, H, P, A> const& m1,
        unordered_multimap<K, T, H, P, A> const& m2)
    {
        return !boost::unordered_detail::equals(m1.base, m2.base);
    }

    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_multimap<K, T, H, P, A> &m1,
            unordered_multimap<K, T, H, P, A> &m2)
    {
        m1.swap(m2);
    }

}
# 17 "/usr/include/boost/unordered_map.hpp" 2 3 4
# 42 "/usr/include/cocaine/common.hpp" 2 3 4


# 1 "/usr/include/cocaine/forwards.hpp" 1 3 4
# 24 "/usr/include/cocaine/forwards.hpp" 3 4
namespace cocaine {

    class context_t;


    struct manifest_t;
    struct profile_t;


    class app_t;

    namespace api {
        class driver_t;
        class isolate_t;
        class logger_t;
        class sandbox_t;
        class service_t;
        class storage_t;

        struct event_t;
        struct stream_t;
    }

    namespace engine {

        struct session_t;


        enum mode: int {
            normal,
            blocking
        };


        class engine_t;
        class slave_t;
    }

    namespace io {
        namespace policies {
            struct unique;
            struct shared;
        }

        template<class>
        struct protocol;


        template<class>
        class channel;

        typedef channel<policies::unique> unique_channel_t;
        typedef channel<policies::shared> shared_channel_t;
    }

    namespace logging {
        enum priorities: int {
            ignore,
            error,
            warning,
            info,
            debug
        };

        struct log_t;
    }

    struct unique_id_t;
}

namespace zmq {
    class context_t;
    class message_t;
}
# 45 "/usr/include/cocaine/common.hpp" 2 3 4
# 1 "/usr/include/cocaine/exceptions.hpp" 1 3 4
# 24 "/usr/include/cocaine/exceptions.hpp" 3 4
# 1 "/usr/include/cocaine/helpers/format.hpp" 1 3 4
# 24 "/usr/include/cocaine/helpers/format.hpp" 3 4
# 1 "/usr/include/boost/format.hpp" 1 3 4
# 23 "/usr/include/boost/format.hpp" 3 4
# 1 "/usr/include/c++/4.4/locale" 1 3 4
# 38 "/usr/include/c++/4.4/locale" 3 4
       
# 39 "/usr/include/c++/4.4/locale" 3




# 1 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 1 3
# 37 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
       
# 38 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3

# 1 "/usr/include/c++/4.4/ctime" 1 3
# 41 "/usr/include/c++/4.4/ctime" 3
       
# 42 "/usr/include/c++/4.4/ctime" 3

# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/ctime" 2 3
# 60 "/usr/include/c++/4.4/ctime" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 40 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {







  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }

      ~__timepunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 207 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const;


}


# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/time_members.h" 1 3
# 38 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null), _M_c_locale_timepunct(__null),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(__null),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null), _M_c_locale_timepunct(__null),
      _M_name_timepunct(__null)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }

}
# 345 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 360 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;

      typedef basic_string<_CharT> __string_type;


      static locale::id id;
# 382 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 399 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 423 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 448 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 476 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 505 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 531 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:

      virtual
      ~time_get() { }
# 551 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 569 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 588 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 607 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 626 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 645 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;


      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;



      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };
# 701 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 722 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 741 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 761 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 788 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };
# 826 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }







  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 947 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
# 959 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 974 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
# 988 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1001 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1030 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1043 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1060 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1077 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1093 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1128 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1150 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1162 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1175 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1188 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1201 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1214 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1228 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1242 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1256 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;


# 1350 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1372 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1402 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1432 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1455 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1467 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1478 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1499 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1520 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1540 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1562 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1596 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1619 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1630 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;






  struct messages_base
  {
    typedef int catalog;
  };
# 1669 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1697 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1711 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1724 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1742 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1760 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1771 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1791 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1810 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {
# 1867 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 3
 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };

}


# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/messages_members.h" 1 3
# 37 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/messages_members.h" 3
# 1 "/usr/include/libintl.h" 1 3 4
# 35 "/usr/include/libintl.h" 3 4
extern "C" {




extern char *gettext (__const char *__msgid)
     throw () __attribute__ ((__format_arg__ (1)));



extern char *dgettext (__const char *__domainname, __const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (__const char *__domainname, __const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (__const char *__domainname,
   __const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (__const char *__domainname,
     __const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));




extern char *ngettext (__const char *__msgid1, __const char *__msgid2,
         unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (__const char *__domainname, __const char *__msgid1,
   __const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (__const char *__domainname, __const char *__msgid1,
    __const char *__msgid2, unsigned long int __n,
    int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (__const char *__domainname) throw ();



extern char *bindtextdomain (__const char *__domainname,
        __const char *__dirname) throw ();



extern char *bind_textdomain_codeset (__const char *__domainname,
          __const char *__codeset) throw ();
# 122 "/usr/include/libintl.h" 3 4
}
# 38 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/messages_members.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
       _M_name_messages(_S_get_c_name())
     { }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale __cloc, const char* __s,
    size_t __refs)
     : facet(__refs), _M_c_locale_messages(__null), _M_name_messages(__null)
     {
       if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
  {
    const size_t __len = __builtin_strlen(__s) + 1;
    char* __tmp = new char[__len];
    __builtin_memcpy(__tmp, __s, __len);
    _M_name_messages = __tmp;
  }
       else
  _M_name_messages = _S_get_c_name();


       _M_c_locale_messages = _S_clone_c_locale(__cloc);
     }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
       if (this->_M_name_messages != locale::facet::_S_get_c_name())
  {
    delete [] this->_M_name_messages;
    if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
      {
        const size_t __len = __builtin_strlen(__s) + 1;
        char* __tmp = new char[__len];
        __builtin_memcpy(__tmp, __s, __len);
        this->_M_name_messages = __tmp;
      }
    else
      this->_M_name_messages = locale::facet::_S_get_c_name();
  }

       if (__builtin_strcmp(__s, "C") != 0
    && __builtin_strcmp(__s, "POSIX") != 0)
  {
    this->_S_destroy_c_locale(this->_M_c_locale_messages);
    this->_S_create_c_locale(this->_M_c_locale_messages, __s);
  }
     }

}
# 1906 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/include/c++/4.4/bits/codecvt.h" 1 3
# 40 "/usr/include/c++/4.4/bits/codecvt.h" 3
       
# 41 "/usr/include/c++/4.4/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 66 "/usr/include/c++/4.4/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 114 "/usr/include/c++/4.4/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 153 "/usr/include/c++/4.4/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 194 "/usr/include/c++/4.4/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 235 "/usr/include/c++/4.4/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



}
# 1909 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/include/c++/4.4/bits/locale_facets_nonio.tcc" 1 3
# 33 "/usr/include/c++/4.4/bits/locale_facets_nonio.tcc" 3
       
# 34 "/usr/include/c++/4.4/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_grouping_size = __mp.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __mp.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(_M_grouping[0]) > 0
    && (_M_grouping[0]
        != __gnu_cxx::__numeric_traits<char>::__max));

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      _M_curr_symbol_size = __mp.curr_symbol().size();
      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];
      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
      _M_curr_symbol = __curr_symbol;

      _M_positive_sign_size = __mp.positive_sign().size();
      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];
      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
      _M_positive_sign = __positive_sign;

      _M_negative_sign_size = __mp.negative_sign().size();
      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];
      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
      _M_negative_sign = __negative_sign;

      _M_pos_format = __mp.pos_format();
      _M_neg_format = __mp.neg_format();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(money_base::_S_atoms,
   money_base::_S_atoms + money_base::_S_end, _M_atoms);
    }



  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 345 "/usr/include/c++/4.4/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 550 "/usr/include/c++/4.4/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 582 "/usr/include/c++/4.4/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }






  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

    __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
      __io, __tmperr);
    break;
  case 'Y':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__days[__tmpwday]);
   __tp._M_days(__days);
   const char_type* __name = __days[__tmpwday];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12,
         __io, __tmperr);







      if (!__tmperr && __beg != __end)
 {
   size_t __pos = __traits_type::length(__months[__tmpmon]);
   __tp._M_months(__months);
   const char_type* __name = __months[__tmpmon];
   if (__name[__pos] == *__beg)
     {

       const size_t __len = __traits_type::length(__name);
       while (__pos < __len && __beg != __end
       && __name[__pos] == *__beg)
  ++__beg, ++__pos;
       if (__len != __pos)
  __tmperr |= ios_base::failbit;
     }
 }
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < 4; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     __value = __value * 10 + (__c - '0');
   else
     break;
 }
      if (__i == 2 || __i == 4)
 __tm->tm_year = __i == 2 ? __value : __value - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type* __res =
       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }






  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);



}
# 1912 "/usr/include/c++/4.4/bits/locale_facets_nonio.h" 2 3
# 44 "/usr/include/c++/4.4/locale" 2 3
# 24 "/usr/include/boost/format.hpp" 2 3 4



# 1 "/usr/include/boost/format/detail/compat_workarounds.hpp" 1 3 4
# 33 "/usr/include/boost/format/detail/compat_workarounds.hpp" 3 4
namespace boost {
    namespace io {



        template<class Tr>
        class CompatTraits;




        template<class Alloc>
        class CompatAlloc;
    }
}


# 1 "/usr/include/boost/format/detail/config_macros.hpp" 1 3 4
# 33 "/usr/include/boost/format/detail/config_macros.hpp" 3 4
# 1 "/usr/include/boost/format/detail/workarounds_gcc-2_95.hpp" 1 3 4
# 34 "/usr/include/boost/format/detail/config_macros.hpp" 2 3 4
# 1 "/usr/include/boost/format/detail/workarounds_stlport.hpp" 1 3 4
# 35 "/usr/include/boost/format/detail/config_macros.hpp" 2 3 4
# 86 "/usr/include/boost/format/detail/config_macros.hpp" 3 4
namespace boost { namespace io { namespace detail {

    typedef ::std:: locale locale_t;



} } }
# 51 "/usr/include/boost/format/detail/compat_workarounds.hpp" 2 3 4
# 65 "/usr/include/boost/format/detail/compat_workarounds.hpp" 3 4
namespace boost {
    namespace io {


        template<class Tr>
        class CompatTraits
        {
        public:
            typedef Tr compatible_type;
        };


        template<class Alloc>
        class CompatAlloc
        {
        public:
            typedef Alloc compatible_type;
        };

    }
}
# 28 "/usr/include/boost/format.hpp" 2 3 4






# 1 "/usr/include/boost/format/format_fwd.hpp" 1 3 4
# 21 "/usr/include/boost/format/format_fwd.hpp" 3 4
namespace boost {

    template <class Ch,


        class Tr = ::std:: char_traits<Ch>, class Alloc = std::allocator<Ch> >



    class basic_format;

    typedef basic_format<char > format;



    typedef basic_format<wchar_t > wformat;


    namespace io {
        enum format_error_bits { bad_format_string_bit = 1,
                                 too_few_args_bit = 2, too_many_args_bit = 4,
                                 out_of_range_bit = 8,
                                 all_error_bits = 255, no_error_bits=0 };

    }

}
# 35 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/internals_fwd.hpp" 1 3 4
# 20 "/usr/include/boost/format/internals_fwd.hpp" 3 4
namespace boost {
namespace io {

namespace detail {
  template<class Ch, class Tr> struct stream_format_state;
    template<class Ch, class Tr, class Alloc> struct format_item;





    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self,
                      int itemN, T manipulator);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self,
                   int argN, const T& val);


    template<class Ch, class Tr, class T>
    void apply_manip_body (stream_format_state<Ch, Tr>& self,
                           T manipulator);


    template<class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x);

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x);

}

}
}
# 36 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/internals.hpp" 1 3 4
# 19 "/usr/include/boost/format/internals.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 20 "/usr/include/boost/format/internals.hpp" 2 3 4
# 1 "/usr/include/boost/optional.hpp" 1 3 4
# 15 "/usr/include/boost/optional.hpp" 3 4
# 1 "/usr/include/boost/optional/optional.hpp" 1 3 4
# 19 "/usr/include/boost/optional/optional.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 20 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/type.hpp" 1 3 4
# 9 "/usr/include/boost/type.hpp" 3 4
namespace boost {



  template <class T>
  struct type {};

}
# 21 "/usr/include/boost/optional/optional.hpp" 2 3 4







# 1 "/usr/include/boost/detail/reference_content.hpp" 1 3 4
# 20 "/usr/include/boost/detail/reference_content.hpp" 3 4
# 1 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 1 3 4
# 12 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 3 4
# 1 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 1 3 4
# 21 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 2 3 4

namespace boost {

namespace detail {

template <typename T>
struct has_trivial_copy_impl
{
   static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::is_pod<T>::value, (__has_trivial_copy(T) && !is_reference<T>::value) >::value, ::boost::type_traits::ice_not< ::boost::is_volatile<T>::value >::value >::value);







};

}

template< typename T > struct has_trivial_copy : ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { };
template< typename T > struct has_trivial_copy_constructor : ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { };

}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 48 "/usr/include/boost/type_traits/has_trivial_copy.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 2 3 4

namespace boost {

namespace detail{

template <class T>
struct has_nothrow_copy_imp{
   static const bool value = (::boost::type_traits::ice_or< ::boost::has_trivial_copy<T>::value, (__has_nothrow_copy(T) && !is_volatile<T>::value && !is_reference<T>::value) >::value);




};

}

template< typename T > struct has_nothrow_copy : ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { };
template< typename T > struct has_nothrow_copy_constructor : ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { };

}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 38 "/usr/include/boost/type_traits/has_nothrow_copy.hpp" 2 3 4
# 21 "/usr/include/boost/detail/reference_content.hpp" 2 3 4





# 1 "/usr/include/boost/mpl/void.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/void.hpp" 3 4
namespace mpl_ {





struct void_ { typedef void_ type; };

}

namespace boost { namespace mpl {

template< typename T >
struct is_void_
    : false_
{



};

template<>
struct is_void_<void_>
    : true_
{



};

template< typename T >
struct is_not_void_
    : true_
{



};

template<>
struct is_not_void_<void_>
    : false_
{



};

template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }

}}
# 27 "/usr/include/boost/detail/reference_content.hpp" 2 3 4

namespace boost {

namespace detail {






template <typename RefT>
class reference_content
{
private:

    RefT content_;

public:

    ~reference_content()
    {
    }

    reference_content(RefT r)
        : content_( r )
    {
    }

    reference_content(const reference_content& operand)
        : content_( operand.content_ )
    {
    }

private:

    reference_content& operator=(const reference_content&);

public:

    RefT get() const
    {
        return content_;
    }

};







template <typename T = mpl::void_> struct make_reference_content;



template <typename T>
struct make_reference_content
{
    typedef T type;
};

template <typename T>
struct make_reference_content< T& >
{
    typedef reference_content<T&> type;
};
# 109 "/usr/include/boost/detail/reference_content.hpp" 3 4
template <>
struct make_reference_content< mpl::void_ >
{
    template <typename T>
    struct apply
        : make_reference_content<T>
    {
    };

    typedef mpl::void_ type;
};

}







template <typename T>
struct has_nothrow_copy<
      ::boost::detail::reference_content< T& >
    >
    : mpl::true_
{
};



}
# 29 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/none.hpp" 1 3 4
# 15 "/usr/include/boost/none.hpp" 3 4
# 1 "/usr/include/boost/none_t.hpp" 1 3 4
# 15 "/usr/include/boost/none_t.hpp" 3 4
namespace boost {

namespace detail { struct none_helper{}; }

typedef int detail::none_helper::*none_t ;

}
# 16 "/usr/include/boost/none.hpp" 2 3 4





namespace boost {

none_t const none = ((none_t)0) ;

}
# 30 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 1 "/usr/include/boost/utility/compare_pointees.hpp" 1 3 4
# 17 "/usr/include/boost/utility/compare_pointees.hpp" 3 4
namespace boost {
# 28 "/usr/include/boost/utility/compare_pointees.hpp" 3 4
template<class OptionalPointee>
inline
bool equal_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return (!x) != (!y) ? false : ( !x ? true : (*x) == (*y) ) ;
}

template<class OptionalPointee>
struct equal_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return equal_pointees(x,y) ; }
} ;
# 51 "/usr/include/boost/utility/compare_pointees.hpp" 3 4
template<class OptionalPointee>
inline
bool less_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return !y ? false : ( !x ? true : (*x) < (*y) ) ;
}

template<class OptionalPointee>
struct less_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return less_pointees(x,y) ; }
} ;

}
# 31 "/usr/include/boost/optional/optional.hpp" 2 3 4

# 1 "/usr/include/boost/optional/optional_fwd.hpp" 1 3 4
# 15 "/usr/include/boost/optional/optional_fwd.hpp" 3 4
namespace boost {

template<class T> class optional ;

}
# 33 "/usr/include/boost/optional/optional.hpp" 2 3 4
# 83 "/usr/include/boost/optional/optional.hpp" 3 4
namespace boost_optional_detail
{
  template <class T, class Factory>
  void construct(Factory const& factory, void* address)
  {
    factory.template apply<T>(address);
  }
}


namespace boost {

class in_place_factory_base ;
class typed_in_place_factory_base ;

namespace optional_detail {





template <class T>
class aligned_storage
{

    union dummy_u
    {
        char data[ sizeof(T) ];
        typename type_with_alignment<
          ::boost::alignment_of<T>::value >::type aligner_;
    } dummy_ ;

  public:

    void const* address() const { return &dummy_.data[0]; }
    void * address() { return &dummy_.data[0]; }
} ;

template<class T>
struct types_when_isnt_ref
{
  typedef T const& reference_const_type ;
  typedef T & reference_type ;
  typedef T const* pointer_const_type ;
  typedef T * pointer_type ;
  typedef T const& argument_type ;
} ;
template<class T>
struct types_when_is_ref
{
  typedef typename remove_reference<T>::type raw_type ;

  typedef raw_type& reference_const_type ;
  typedef raw_type& reference_type ;
  typedef raw_type* pointer_const_type ;
  typedef raw_type* pointer_type ;
  typedef raw_type& argument_type ;
} ;

struct optional_tag {} ;

template<class T>
class optional_base : public optional_tag
{
  private :

    typedef

    typename

    ::boost::detail::make_reference_content<T>::type internal_type ;

    typedef aligned_storage<internal_type> storage_type ;

    typedef types_when_isnt_ref<T> types_when_not_ref ;
    typedef types_when_is_ref<T> types_when_ref ;

    typedef optional_base<T> this_type ;

  protected :

    typedef T value_type ;

    typedef mpl::true_ is_reference_tag ;
    typedef mpl::false_ is_not_reference_tag ;

    typedef typename is_reference<T>::type is_reference_predicate ;

    typedef typename mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;

    typedef bool (this_type::*unspecified_bool_type)() const;

    typedef typename types::reference_type reference_type ;
    typedef typename types::reference_const_type reference_const_type ;
    typedef typename types::pointer_type pointer_type ;
    typedef typename types::pointer_const_type pointer_const_type ;
    typedef typename types::argument_type argument_type ;



    optional_base()
      :
      m_initialized(false) {}



    optional_base ( none_t )
      :
      m_initialized(false) {}



    optional_base ( argument_type val )
      :
      m_initialized(false)
    {
      construct(val);
    }



    optional_base ( bool cond, argument_type val )
      :
      m_initialized(false)
    {
      if ( cond )
        construct(val);
    }



    optional_base ( optional_base const& rhs )
      :
      m_initialized(false)
    {
      if ( rhs.is_initialized() )
        construct(rhs.get_impl());
    }





    template<class Expr>
    explicit optional_base ( Expr const& expr, Expr const* tag )
      :
      m_initialized(false)
    {
      construct(expr,tag);
    }




    ~optional_base() { destroy() ; }


    void assign ( optional_base const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(rhs.get_impl(), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(rhs.get_impl());
      }
    }


    template<class U>
    void assign ( optional<U> const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(static_cast<value_type>(rhs.get()));
      }
    }


    void assign ( argument_type val )
    {
      if (is_initialized())
           assign_value(val, is_reference_predicate() );
      else construct(val);
    }



    void assign ( none_t ) { destroy(); }


    template<class Expr>
    void assign_expr ( Expr const& expr, Expr const* tag )
      {
        if (is_initialized())
             assign_expr_to_initialized(expr,tag);
        else construct(expr,tag);
      }


  public :



    void reset() { destroy(); }


    void reset ( argument_type val ) { assign(val); }




    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }
    pointer_type get_ptr() { return m_initialized ? get_ptr_impl() : 0 ; }

    bool is_initialized() const { return m_initialized ; }

  protected :

    void construct ( argument_type val )
     {
       new (m_storage.address()) internal_type(val) ;
       m_initialized = true ;
     }



    template<class Expr>
    void construct ( Expr const& factory, in_place_factory_base const* )
     {
       static_assert(::boost::mpl::not_<is_reference_predicate>::value, "::boost::mpl::not_<is_reference_predicate>::value") ;
       boost_optional_detail::construct<value_type>(factory, m_storage.address());
       m_initialized = true ;
     }


    template<class Expr>
    void construct ( Expr const& factory, typed_in_place_factory_base const* )
     {
       static_assert(::boost::mpl::not_<is_reference_predicate>::value, "::boost::mpl::not_<is_reference_predicate>::value") ;
       factory.apply(m_storage.address()) ;
       m_initialized = true ;
     }

    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }


    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }






    template<class Expr>
    void construct ( Expr const& expr, void const* )
     {
       new (m_storage.address()) internal_type(expr) ;
       m_initialized = true ;
     }





    template<class Expr>
    void assign_expr_to_initialized ( Expr const& expr, void const* )
     {
       assign_value(expr, is_reference_predicate());
     }
# 402 "/usr/include/boost/optional/optional.hpp" 3 4
    void assign_value ( argument_type val, is_not_reference_tag ) { get_impl() = val; }
    void assign_value ( argument_type val, is_reference_tag ) { construct(val); }

    void destroy()
    {
      if ( m_initialized )
        destroy_impl(is_reference_predicate()) ;
    }

    unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }

    reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }
    reference_type get_impl() { return dereference(get_object(), is_reference_predicate() ) ; }

    pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }
    pointer_type get_ptr_impl() { return cast_ptr(get_object(), is_reference_predicate() ) ; }

  private :


    internal_type const* get_object() const { return static_cast<internal_type const*>(m_storage.address()); }
    internal_type * get_object() { return static_cast<internal_type *> (m_storage.address()); }


    reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }
    reference_type dereference( internal_type* p, is_not_reference_tag ) { return *p ; }
    reference_const_type dereference( internal_type const* p, is_reference_tag ) const { return p->get() ; }
    reference_type dereference( internal_type* p, is_reference_tag ) { return p->get() ; }




    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->T::~T() ; m_initialized = false ; }


    void destroy_impl ( is_reference_tag ) { m_initialized = false ; }




    pointer_const_type cast_ptr( internal_type const* p, is_not_reference_tag ) const { return p ; }
    pointer_type cast_ptr( internal_type * p, is_not_reference_tag ) { return p ; }
    pointer_const_type cast_ptr( internal_type const* p, is_reference_tag ) const { return &p->get() ; }
    pointer_type cast_ptr( internal_type * p, is_reference_tag ) { return &p->get() ; }

    bool m_initialized ;
    storage_type m_storage ;
} ;

}

template<class T>
class optional : public optional_detail::optional_base<T>
{
    typedef optional_detail::optional_base<T> base ;

    typedef typename base::unspecified_bool_type unspecified_bool_type ;

  public :

    typedef optional<T> this_type ;

    typedef typename base::value_type value_type ;
    typedef typename base::reference_type reference_type ;
    typedef typename base::reference_const_type reference_const_type ;
    typedef typename base::pointer_type pointer_type ;
    typedef typename base::pointer_const_type pointer_const_type ;
    typedef typename base::argument_type argument_type ;



    optional() : base() {}



    optional( none_t none_ ) : base(none_) {}



    optional ( argument_type val ) : base(val) {}



    optional ( bool cond, argument_type val ) : base(cond,val) {}







    template<class U>
    explicit optional ( optional<U> const& rhs )
      :
      base()
    {
      if ( rhs.is_initialized() )
        this->construct(rhs.get());
    }
# 513 "/usr/include/boost/optional/optional.hpp" 3 4
    template<class Expr>
    explicit optional ( Expr const& expr ) : base(expr,&expr) {}




    optional ( optional const& rhs ) : base(rhs) {}


    ~optional() {}




    template<class Expr>
    optional& operator= ( Expr expr )
      {
        this->assign_expr(expr,&expr);
        return *this ;
      }







    template<class U>
    optional& operator= ( optional<U> const& rhs )
      {
        this->assign(rhs);
        return *this ;
      }





    optional& operator= ( optional const& rhs )
      {
        this->assign( rhs ) ;
        return *this ;
      }



    optional& operator= ( argument_type val )
      {
        this->assign( val ) ;
        return *this ;
      }




    optional& operator= ( none_t none_ )
      {
        this->assign( none_ ) ;
        return *this ;
      }




    reference_const_type get() const { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 577, __PRETTY_FUNCTION__)) ; return this->get_impl(); }
    reference_type get() { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 578, __PRETTY_FUNCTION__)) ; return this->get_impl(); }


    reference_const_type get_value_or ( reference_const_type v ) const { return this->is_initialized() ? get() : v ; }
    reference_type get_value_or ( reference_type v ) { return this->is_initialized() ? get() : v ; }




    pointer_const_type operator->() const { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 587, __PRETTY_FUNCTION__)) ; return this->get_ptr_impl() ; }
    pointer_type operator->() { ((this->is_initialized()) ? static_cast<void> (0) : __assert_fail ("this->is_initialized()", "/usr/include/boost/optional/optional.hpp", 588, __PRETTY_FUNCTION__)) ; return this->get_ptr_impl() ; }




    reference_const_type operator *() const { return this->get() ; }
    reference_type operator *() { return this->get() ; }



    operator unspecified_bool_type() const { return this->safe_bool() ; }



       bool operator!() const { return !this->is_initialized() ; }
} ;


template<class T>
inline
optional<T> make_optional ( T const& v )
{
  return optional<T>(v);
}


template<class T>
inline
optional<T> make_optional ( bool cond, T const& v )
{
  return optional<T>(cond,v);
}



template<class T>
inline
typename optional<T>::reference_const_type
get ( optional<T> const& opt )
{
  return opt.get() ;
}

template<class T>
inline
typename optional<T>::reference_type
get ( optional<T>& opt )
{
  return opt.get() ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get ( optional<T> const* opt )
{
  return opt->get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get ( optional<T>* opt )
{
  return opt->get_ptr() ;
}



template<class T>
inline
typename optional<T>::reference_const_type
get_optional_value_or ( optional<T> const& opt, typename optional<T>::reference_const_type v )
{
  return opt.get_value_or(v) ;
}

template<class T>
inline
typename optional<T>::reference_type
get_optional_value_or ( optional<T>& opt, typename optional<T>::reference_type v )
{
  return opt.get_value_or(v) ;
}



template<class T>
inline
typename optional<T>::pointer_const_type
get_pointer ( optional<T> const& opt )
{
  return opt.get_ptr() ;
}

template<class T>
inline
typename optional<T>::pointer_type
get_pointer ( optional<T>& opt )
{
  return opt.get_ptr() ;
}
# 701 "/usr/include/boost/optional/optional.hpp" 3 4
template<class T>
inline
bool operator == ( optional<T> const& x, optional<T> const& y )
{ return equal_pointees(x,y); }

template<class T>
inline
bool operator < ( optional<T> const& x, optional<T> const& y )
{ return less_pointees(x,y); }

template<class T>
inline
bool operator != ( optional<T> const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, optional<T> const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( optional<T> const& x, T const& y )
{ return equal_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator < ( optional<T> const& x, T const& y )
{ return less_pointees(x, optional<T>(y)); }

template<class T>
inline
bool operator != ( optional<T> const& x, T const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, T const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, T const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, T const& y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( T const& x, optional<T> const& y )
{ return equal_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator < ( T const& x, optional<T> const& y )
{ return less_pointees( optional<T>(x), y ); }

template<class T>
inline
bool operator != ( T const& x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( T const& x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( T const& x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( T const& x, optional<T> const& y )
{ return !( x < y ) ; }






template<class T>
inline
bool operator == ( optional<T> const& x, none_t )
{ return equal_pointees(x, optional<T>() ); }

template<class T>
inline
bool operator < ( optional<T> const& x, none_t )
{ return less_pointees(x,optional<T>() ); }

template<class T>
inline
bool operator != ( optional<T> const& x, none_t y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( optional<T> const& x, none_t y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( optional<T> const& x, none_t y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( optional<T> const& x, none_t y )
{ return !( x < y ) ; }





template<class T>
inline
bool operator == ( none_t x, optional<T> const& y )
{ return equal_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator < ( none_t x, optional<T> const& y )
{ return less_pointees(optional<T>() ,y); }

template<class T>
inline
bool operator != ( none_t x, optional<T> const& y )
{ return !( x == y ) ; }

template<class T>
inline
bool operator > ( none_t x, optional<T> const& y )
{ return y < x ; }

template<class T>
inline
bool operator <= ( none_t x, optional<T> const& y )
{ return !( y < x ) ; }

template<class T>
inline
bool operator >= ( none_t x, optional<T> const& y )
{ return !( x < y ) ; }





namespace optional_detail {
# 886 "/usr/include/boost/optional/optional.hpp" 3 4
template<class T>
inline
void optional_swap ( optional<T>& x, optional<T>& y )
{
  if ( !x && !!y )
  {
    x.reset(*y);
    y.reset();
  }
  else if ( !!x && !y )
  {
    y.reset(*x);
    x.reset();
  }
  else if ( !!x && !!y )
  {



    using std::swap ;

    swap(*x,*y);
  }
}

}

template<class T> inline void swap ( optional<T>& x, optional<T>& y )
{
  optional_detail::optional_swap(x,y);
}


}
# 16 "/usr/include/boost/optional.hpp" 2 3 4
# 21 "/usr/include/boost/format/internals.hpp" 2 3 4


# 1 "/usr/include/boost/format/alt_sstream.hpp" 1 3 4
# 20 "/usr/include/boost/format/alt_sstream.hpp" 3 4
# 1 "/usr/include/boost/utility/base_from_member.hpp" 1 3 4
# 14 "/usr/include/boost/utility/base_from_member.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp" 1 3 4
# 15 "/usr/include/boost/utility/base_from_member.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/enum_params.hpp" 1 3 4
# 16 "/usr/include/boost/utility/base_from_member.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 1 3 4
# 23 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 24 "/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp" 2 3 4
# 17 "/usr/include/boost/utility/base_from_member.hpp" 2 3 4
# 53 "/usr/include/boost/utility/base_from_member.hpp" 3 4
namespace boost
{
# 65 "/usr/include/boost/utility/base_from_member.hpp" 3 4
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;

    base_from_member()
        : member()
        {}

    template < typename T0 > explicit base_from_member( T0 x0 ) : member( x0 ) {} template < typename T0 , typename T1 > explicit base_from_member( T0 x0 , T1 x1 ) : member( x0 , x1 ) {} template < typename T0 , typename T1 , typename T2 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 ) : member( x0 , x1 , x2 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 ) : member( x0 , x1 , x2 , x3 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 ) : member( x0 , x1 , x2 , x3 , x4 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 ) : member( x0 , x1 , x2 , x3 , x4 , x5 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 , T9 x9 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 ) {}


};

}
# 21 "/usr/include/boost/format/alt_sstream.hpp" 2 3 4

# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 23 "/usr/include/boost/format/alt_sstream.hpp" 2 3 4

namespace boost {
    namespace io {

        template<class Ch, class Tr=::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_altstringbuf;

        template<class Ch, class Tr =::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_oaltstringstream;


        template<class Ch, class Tr, class Alloc>
        class basic_altstringbuf
            : public ::std::basic_streambuf<Ch, Tr>
        {
            typedef ::std::basic_streambuf<Ch, Tr> streambuf_t;
            typedef typename CompatAlloc<Alloc>::compatible_type compat_allocator_type;
            typedef typename CompatTraits<Tr>::compatible_type compat_traits_type;
        public:
            typedef Ch char_type;
            typedef Tr traits_type;
            typedef typename compat_traits_type::int_type int_type;
            typedef typename compat_traits_type::pos_type pos_type;
            typedef typename compat_traits_type::off_type off_type;
            typedef Alloc allocator_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;

            typedef ::std::streamsize streamsize;


            explicit basic_altstringbuf(std::ios_base::openmode mode
                                        = std::ios_base::in | std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                {}
            explicit basic_altstringbuf(const string_type& s,
                                        ::std::ios_base::openmode mode
                                        = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }
            virtual ~basic_altstringbuf()
                { dealloc(); }
            using streambuf_t::pbase;
            using streambuf_t::pptr;
            using streambuf_t::epptr;
            using streambuf_t::eback;
            using streambuf_t::gptr;
            using streambuf_t::egptr;

            void clear_buffer();
            void str(const string_type& s);


            Ch * begin() const;
            size_type size() const;
            size_type cur_size() const;
            Ch * pend() const
                { return ((putend_ < pptr()) ? pptr() : putend_); }
            size_type pcount() const
                { return static_cast<size_type>( pptr() - pbase()) ;}


            string_type str() const
                { return string_type(begin(), size()); }
            string_type cur_str() const
                { return string_type(begin(), cur_size()); }
        protected:
            explicit basic_altstringbuf (basic_altstringbuf * s,
                                         ::std::ios_base::openmode mode
                                         = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }

            virtual pos_type seekoff(off_type off, ::std::ios_base::seekdir way,
                                     ::std::ios_base::openmode which
                                     = ::std::ios_base::in | ::std::ios_base::out);
            virtual pos_type seekpos (pos_type pos,
                                      ::std::ios_base::openmode which
                                      = ::std::ios_base::in | ::std::ios_base::out);
            virtual int_type underflow();
            virtual int_type pbackfail(int_type meta = compat_traits_type::eof());
            virtual int_type overflow(int_type meta = compat_traits_type::eof());
            void dealloc();
        private:
            enum { alloc_min = 256};

            Ch *putend_;
            bool is_allocated_;
            ::std::ios_base::openmode mode_;
            compat_allocator_type alloc_;
        };



        template <class Ch, class Tr, class Alloc>
        class basic_oaltstringstream
            : private base_from_member< shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,
              public ::std::basic_ostream<Ch, Tr>
        {
            class No_Op {

            public:
                template<class T>
                const T & operator()(const T & arg) { return arg; }
            };
            typedef ::std::basic_ostream<Ch, Tr> stream_t;
            typedef boost::base_from_member<boost::shared_ptr<
                basic_altstringbuf<Ch,Tr, Alloc> > >
                pbase_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;
            typedef basic_altstringbuf<Ch, Tr, Alloc> stringbuf_t;
        public:
            typedef Alloc allocator_type;
            basic_oaltstringstream()
                : pbase_type(new stringbuf_t), stream_t(rdbuf())
                { }
            basic_oaltstringstream(::boost::shared_ptr<stringbuf_t> buf)
                : pbase_type(buf), stream_t(rdbuf())
                { }
            basic_oaltstringstream(stringbuf_t * buf)
                : pbase_type(buf, No_Op() ), stream_t(rdbuf())
                { }
            stringbuf_t * rdbuf() const
                { return pbase_type::member.get(); }
            void clear_buffer()
                { rdbuf()->clear_buffer(); }


            Ch * begin() const
                { return rdbuf()->begin(); }
            size_type size() const
                { return rdbuf()->size(); }
            size_type cur_size() const
                { return rdbuf()->cur_size(); }


            string_type str() const
                { return rdbuf()->str(); }
            string_type cur_str() const
                { return rdbuf()->cur_str(); }
            void str(const string_type& s)
                { rdbuf()->str(s); }
        };

    }
}

# 1 "/usr/include/boost/format/alt_sstream_impl.hpp" 1 3 4
# 16 "/usr/include/boost/format/alt_sstream_impl.hpp" 3 4
namespace boost {
    namespace io {


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        clear_buffer () {
            const Ch * p = pptr();
            const Ch * b = pbase();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::out);
            }
            p = gptr();
            b = eback();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::in);
            }
        }

        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        str (const string_type& s) {
            size_type sz=s.size();
            if(sz != 0 && mode_ & (::std::ios_base::in | ::std::ios_base::out) ) {
                Ch *new_ptr = alloc_.allocate(sz, is_allocated_? eback() : 0);

                dealloc();
                sz = s.copy(new_ptr, sz);
                putend_ = new_ptr + sz;
                if(mode_ & ::std::ios_base::in)
                    streambuf_t::setg(new_ptr, new_ptr, new_ptr + sz);
                if(mode_ & ::std::ios_base::out) {
                    streambuf_t::setp(new_ptr, new_ptr + sz);
                    if(mode_ & (::std::ios_base::app | ::std::ios_base::ate))
                        streambuf_t::pbump(static_cast<int>(sz));
                    if(gptr() == __null)
                        streambuf_t::setg(new_ptr, __null, new_ptr);
                }
                is_allocated_ = true;
            }
            else
                dealloc();
        }
        template<class Ch, class Tr, class Alloc>
        Ch* basic_altstringbuf<Ch, Tr, Alloc>::
        begin () const {
            if(mode_ & ::std::ios_base::out && pptr() != __null)
                return pbase();
            else if(mode_ & ::std::ios_base::in && gptr() != __null)
                return eback();
            return __null;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<size_type>(pend() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<size_type>(egptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        cur_size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<streamsize>( pptr() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<streamsize>( gptr() - eback());
            else
                return 0;
        }

        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekoff (off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) {
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(which & ::std::ios_base::in && gptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - gptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(eback() - gptr());
                else if(way != ::std::ios_base::cur || (which & ::std::ios_base::out) )

                    return pos_type(off_type(-1));
                if(eback() <= off+gptr() && off+gptr() <= putend_ ) {

                    streambuf_t::gbump(static_cast<int>(off));
                    if(which & ::std::ios_base::out && pptr() != __null)

                        streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                }
                else
                    off = off_type(-1);
            }
            else if(which & ::std::ios_base::out && pptr() != __null) {

                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - pptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(pbase() - pptr());
                else if(way != ::std::ios_base::beg)
                    return pos_type(off_type(-1));
                if(pbase() <= off+pptr() && off+pptr() <= putend_)

                    streambuf_t::pbump(static_cast<int>(off));
                else
                    off = off_type(-1);
            }
            else
                off = off_type(-1);
            return (pos_type(off));
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekpos (pos_type pos, ::std::ios_base::openmode which) {
            off_type off = off_type(pos);
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(off != off_type(-1)) {
                if(which & ::std::ios_base::in && gptr() != __null) {

                    if(0 <= off && off <= putend_ - eback()) {
                        streambuf_t::gbump(static_cast<int>(eback() - gptr() + off));
                        if(which & ::std::ios_base::out && pptr() != __null) {

                            streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                        }
                    }
                    else
                        off = off_type(-1);
                }
                else if(which & ::std::ios_base::out && pptr() != __null) {

                    if(0 <= off && off <= putend_ - eback())
                        streambuf_t::pbump(static_cast<int>(eback() - pptr() + off));
                    else
                        off = off_type(-1);
                }
                else
                    off = off_type(-1);
                return (pos_type(off));
            }
            else {
                ((0) ? static_cast<void> (0) : __assert_fail ("0", "/usr/include/boost/format/alt_sstream_impl.hpp", 171, __PRETTY_FUNCTION__));
                return pos_type(off_type(-1));
            }
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        underflow () {
            if(gptr() == __null)
                return (compat_traits_type::eof());
            else if(gptr() < egptr())
                return (compat_traits_type::to_int_type(*gptr()));
            else if(mode_ & ::std::ios_base::in && pptr() != __null
                    && (gptr() < pptr() || gptr() < putend_) )
                {
                    if(putend_ < pptr())
                        putend_ = pptr();
                    streambuf_t::setg(eback(), gptr(), putend_);
                    return (compat_traits_type::to_int_type(*gptr()));
                }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        pbackfail (int_type meta) {
            if(gptr() != __null && (eback() < gptr())
               && (mode_ & (::std::ios_base::out)
                   || compat_traits_type::eq_int_type(compat_traits_type::eof(), meta)
                   || compat_traits_type::eq(compat_traits_type::to_char_type(meta), gptr()[-1]) ) ) {
                streambuf_t::gbump(-1);
                if(!compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))

                    *gptr() = compat_traits_type::to_char_type(meta);
                return (compat_traits_type::not_eof(meta));
            }
            else
                return (compat_traits_type::eof());
        }



        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        overflow (int_type meta) {




            if(compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))
                return compat_traits_type::not_eof(meta);
            else if(pptr() != __null && pptr() < epptr()) {
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }
            else if(! (mode_ & ::std::ios_base::out))

                return compat_traits_type::eof();
            else {
                std::size_t prev_size = pptr() == __null ? 0 : epptr() - eback();
                std::size_t new_size = prev_size;

                std::size_t add_size = new_size / 2;
                if(add_size < alloc_min)
                    add_size = alloc_min;
                Ch * newptr = __null, *oldptr = eback();


                while (0 < add_size && ((std::numeric_limits<std::size_t>::max)()
                                        - add_size < new_size) )
                    add_size /= 2;
                if(0 < add_size) {
                    new_size += add_size;
                    newptr = alloc_.allocate(new_size, is_allocated_? oldptr : 0);
                }

                if(0 < prev_size)
                    compat_traits_type::copy(newptr, oldptr, prev_size);
                if(is_allocated_)
                    alloc_.deallocate(oldptr, prev_size);
                is_allocated_=true;

                if(prev_size == 0) {
                    putend_ = newptr;
                    streambuf_t::setp(newptr, newptr + new_size);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr, newptr + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                else {
                    putend_ = putend_ - oldptr + newptr;
                    int pptr_count = static_cast<int>(pptr()-pbase());
                    int gptr_count = static_cast<int>(gptr()-eback());
                    streambuf_t::setp(pbase() - oldptr + newptr, newptr + new_size);
                    streambuf_t::pbump(pptr_count);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr + gptr_count, pptr() + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }



        }


        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>:: dealloc() {
            if(is_allocated_)
                alloc_.deallocate(eback(), (pptr() != __null ? epptr() : egptr()) - eback());
            is_allocated_ = false;
            streambuf_t::setg(0, 0, 0);
            streambuf_t::setp(0, 0);
            putend_ = __null;
        }

    }
}
# 174 "/usr/include/boost/format/alt_sstream.hpp" 2 3 4
# 24 "/usr/include/boost/format/internals.hpp" 2 3 4

namespace boost {
namespace io {
namespace detail {





    template<class Ch, class Tr>
    struct stream_format_state
    {
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;

        stream_format_state(Ch fill) { reset(fill); }


        void reset(Ch fill);
        void set_by_stream(const basic_ios& os);
        void apply_on(basic_ios & os,
                      boost::io::detail::locale_t * loc_default = 0) const;
        template<class T>
        void apply_manip(T manipulator)
            { apply_manip_body<Ch, Tr, T>( *this, manipulator) ; }


        std::streamsize width_;
        std::streamsize precision_;
        Ch fill_;
        std::ios_base::fmtflags flags_;
        std::ios_base::iostate rdstate_;
        std::ios_base::iostate exceptions_;
        boost::optional<boost::io::detail::locale_t> loc_;
    };





    template<class Ch, class Tr, class Alloc>
    struct format_item
    {
        enum pad_values { zeropad = 1, spacepad =2, centered=4, tabulation = 8 };



        enum arg_values { argN_no_posit = -1,
                          argN_tabulation = -2,
                          argN_ignored = -3
        };
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;
        typedef detail::stream_format_state<Ch, Tr> stream_format_state;
        typedef ::std::basic_string<Ch, Tr, Alloc> string_type;

        format_item(Ch fill) :argN_(argN_no_posit), fmtstate_(fill),
                              truncate_(max_streamsize()), pad_scheme_(0) {}
        void reset(Ch fill);
        void compute_states();

        static std::streamsize max_streamsize() {
            return (std::numeric_limits<std::streamsize>::max)();
        }


        int argN_;

        string_type res_;
        string_type appendix_;

        stream_format_state fmtstate_;

        std::streamsize truncate_;
        unsigned int pad_scheme_;
    };






    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: apply_on (basic_ios & os,
                      boost::io::detail::locale_t * loc_default) const {

        if(width_ != -1)
            os.width(width_);
        if(precision_ != -1)
            os.precision(precision_);
        if(fill_ != 0)
            os.fill(fill_);
        os.flags(flags_);
        os.clear(rdstate_);
        os.exceptions(exceptions_);

        if(loc_)
            os.imbue(loc_.get());
        else if(loc_default)
            os.imbue(*loc_default);



    }

    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: set_by_stream(const basic_ios& os) {

        flags_ = os.flags();
        width_ = os.width();
        precision_ = os.precision();
        fill_ = os.fill();
        rdstate_ = os.rdstate();
        exceptions_ = os.exceptions();
    }


    template<class Ch, class Tr, class T>
    void apply_manip_body( stream_format_state<Ch, Tr>& self,
                           T manipulator) {

        basic_oaltstringstream<Ch, Tr> ss;
        self.apply_on( ss );
        ss << manipulator;
        self.set_by_stream( ss );
    }

    template<class Ch, class Tr> inline
    void stream_format_state<Ch,Tr>:: reset(Ch fill) {

        width_=0; precision_=6;
        fill_=fill;
        flags_ = std::ios_base::dec | std::ios_base::skipws;

        exceptions_ = std::ios_base::goodbit;
        rdstate_ = std::ios_base::goodbit;
    }




    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    reset (Ch fill) {
        argN_=argN_no_posit; truncate_ = max_streamsize(); pad_scheme_ =0;
        res_.resize(0); appendix_.resize(0);
        fmtstate_.reset(fill);
    }

    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    compute_states() {


        if(pad_scheme_ & zeropad) {

            if(fmtstate_.flags_ & std::ios_base::left) {
              ((!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))) ? static_cast<void> (0) : __assert_fail ("!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))", "/usr/include/boost/format/internals.hpp", 179, __PRETTY_FUNCTION__));

              pad_scheme_ = pad_scheme_ & (~zeropad);
            }
            else {
                pad_scheme_ &= ~spacepad;
                fmtstate_.fill_='0';
                fmtstate_.flags_ = (fmtstate_.flags_ & ~std::ios_base::adjustfield)
                    | std::ios_base::internal;

            }
        }
        if(pad_scheme_ & spacepad) {
            if(fmtstate_.flags_ & std::ios_base::showpos)
                pad_scheme_ &= ~spacepad;
        }
    }


} } }
# 39 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/format_class.hpp" 1 3 4
# 27 "/usr/include/boost/format/format_class.hpp" 3 4
namespace boost {

    template<class Ch, class Tr, class Alloc>
    class basic_format
    {
        typedef typename io::CompatTraits<Tr>::compatible_type compat_traits;
    public:
        typedef Ch CharT;
        typedef std::basic_string<Ch, Tr, Alloc> string_type;
        typedef typename string_type::size_type size_type;
        typedef io::detail::format_item<Ch, Tr, Alloc> format_item_t;
        typedef io::basic_altstringbuf<Ch, Tr, Alloc> internal_streambuf_t;


        explicit basic_format(const Ch* str=__null);
        explicit basic_format(const string_type& s);
        basic_format(const basic_format& x);
        basic_format& operator= (const basic_format& x);
        void swap(basic_format& x);


        explicit basic_format(const Ch* str, const std::locale & loc);
        explicit basic_format(const string_type& s, const std::locale & loc);

        io::detail::locale_t getloc() const;

        basic_format& clear();
        basic_format& clear_binds();
        basic_format& parse(const string_type&);


        size_type size() const;
        string_type str() const;


        template<class T>
        basic_format& operator%(const T& x)
            { return io::detail::feed<CharT, Tr, Alloc, const T&>(*this,x); }


        template<class T> basic_format& operator%(T& x)
            { return io::detail::feed<CharT, Tr, Alloc, T&>(*this,x); }



        template<class T>
        basic_format& bind_arg(int argN, const T& val)
            { return io::detail::bind_arg_body(*this, argN, val); }
        basic_format& clear_bind(int argN);
        template<class T>
        basic_format& modify_item(int itemN, T manipulator)
            { return io::detail::modify_item_body<Ch,Tr, Alloc, T> (*this, itemN, manipulator);}


        unsigned char exceptions() const;
        unsigned char exceptions(unsigned char newexcept);
# 91 "/usr/include/boost/format/format_class.hpp" 3 4
        template<class Ch2, class Tr2, class Alloc2>
        friend std::basic_ostream<Ch2, Tr2> &
        operator<<( std::basic_ostream<Ch2, Tr2> & ,
                    const basic_format<Ch2, Tr2, Alloc2>& );







        template<class Ch2, class Tr2, class Alloc2, class T>
        friend basic_format<Ch2, Tr2, Alloc2>&
        io::detail::feed (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        void io::detail::distribute (basic_format<Ch2, Tr2, Alloc2>&, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::modify_item_body (basic_format<Ch2, Tr2, Alloc2>&, int, T);

        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::bind_arg_body (basic_format<Ch2, Tr2, Alloc2>&, int, const T&);

    private:

        typedef io::detail::stream_format_state<Ch, Tr> stream_format_state;

        enum style_values { ordered = 1,
                             special_needs = 4 };

        void make_or_reuse_data(std::size_t nbitems);


        std::vector<format_item_t> items_;
        std::vector<bool> bound_;

        int style_;
        int cur_arg_;
        int num_args_;
        mutable bool dumped_;
        string_type prefix_;
        unsigned char exceptions_;
        internal_streambuf_t buf_;
        boost::optional<io::detail::locale_t> loc_;
    };

}
# 42 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/exceptions.hpp" 1 3 4
# 23 "/usr/include/boost/format/exceptions.hpp" 3 4
namespace boost {

    namespace io {



        class format_error : public std::exception
        {
        public:
            format_error() {}
            virtual const char *what() const throw() {
                return "boost::format_error: "
                    "format generic failure";
            }
        };

        class bad_format_string : public format_error
        {
            std::size_t pos_, next_;
        public:
            bad_format_string(std::size_t pos, std::size_t size)
                : pos_(pos), next_(size) {}
            std::size_t get_pos() const { return pos_; }
            std::size_t get_next() const { return next_; }
            virtual const char *what() const throw() {
                return "boost::bad_format_string: format-string is ill-formed";
            }
        };

        class too_few_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_few_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_few_args: "
                    "format-string referred to more arguments than were passed";
            }
        };

        class too_many_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_many_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_many_args: "
                    "format-string referred to less arguments than were passed";
            }
        };


        class out_of_range : public format_error
        {
            int index_, beg_, end_;
        public:
            out_of_range(int index, int beg, int end)
                : index_(index), beg_(beg), end_(end) {}
            int get_index() const { return index_; }
            int get_beg() const { return beg_; }
            int get_end() const { return end_; }
            virtual const char *what() const throw() {
                return "boost::out_of_range: "
                    "tried to refer to an argument (or item) number which"
                    " is out of range, according to the format string";
            }
        };


    }

}
# 45 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/format_implementation.hpp" 1 3 4
# 19 "/usr/include/boost/format/format_implementation.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 20 "/usr/include/boost/format/format_implementation.hpp" 2 3 4



namespace boost {



    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        if( s)
            parse( s );
    }


    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        if(s) parse( s );
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    io::detail::locale_t basic_format<Ch, Tr, Alloc>::
    getloc() const {
        return loc_ ? loc_.get() : io::detail::locale_t();
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        parse(s);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const basic_format& x)
        : items_(x.items_), bound_(x.bound_), style_(x.style_),
          cur_arg_(x.cur_arg_), num_args_(x.num_args_), dumped_(false),
          prefix_(x.prefix_), exceptions_(x.exceptions_), loc_(x.loc_)
    {
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    operator= (const basic_format& x) {
        if(this == &x)
            return *this;
        (basic_format<Ch, Tr, Alloc>(x)).swap(*this);
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    swap (basic_format & x) {
        std::swap(exceptions_, x.exceptions_);
        std::swap(style_, x.style_);
        std::swap(cur_arg_, x.cur_arg_);
        std::swap(num_args_, x.num_args_);
        std::swap(dumped_, x.dumped_);

        items_.swap(x.items_);
        prefix_.swap(x.prefix_);
        bound_.swap(x.bound_);
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions() const {
        return exceptions_;
    }

    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions(unsigned char newexcept) {
        unsigned char swp = exceptions_;
        exceptions_ = newexcept;
        return swp;
    }

    template<class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    make_or_reuse_data (std::size_t nbitems) {

        Ch fill = ( std::use_facet< std::ctype<Ch> >(getloc()) ). widen(' ');



        if(items_.size() == 0)
            items_.assign( nbitems, format_item_t(fill) );
        else {
            if(nbitems>items_.size())
                items_.resize(nbitems, format_item_t(fill));
            bound_.resize(0);
            for(std::size_t i=0; i < nbitems; ++i)
                items_[i].reset(fill);
        }
        prefix_.resize(0);
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear () {



        ((bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())) ? static_cast<void> (0) : __assert_fail ("bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())", "/usr/include/boost/format/format_implementation.hpp", 135, __PRETTY_FUNCTION__));

        for(unsigned long i=0; i<items_.size(); ++i) {

            if( bound_.size()==0 || items_[i].argN_<0 || !bound_[ items_[i].argN_ ] )
                items_[i].res_.resize(0);
        }
        cur_arg_=0; dumped_=false;

        if(bound_.size() != 0) {
            for(; cur_arg_ < num_args_ && bound_[cur_arg_]; ++cur_arg_)
                {}
        }
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_binds () {

        bound_.resize(0);
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_bind (int argN) {

        if(argN<1 || argN > num_args_ || bound_.size()==0 || !bound_[argN-1] ) {
            if( exceptions() & io::out_of_range_bit)
                boost::throw_exception(io::out_of_range(argN, 1, num_args_+1 ) );
            else return *this;
        }
        bound_[argN-1]=false;
        clear();
        return *this;
    }

    template< class Ch, class Tr, class Alloc>
    typename basic_format<Ch, Tr, Alloc>::string_type
    basic_format<Ch,Tr, Alloc>::
    str () const {
        if(items_.size()==0)
            return prefix_;
        if( cur_arg_ < num_args_)
            if( exceptions() & io::too_few_args_bit )

                boost::throw_exception(io::too_few_args(cur_arg_, num_args_));

        unsigned long i;
        string_type res;
        res.reserve(size());
        res += prefix_;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            res += item.res_;
            if( item.argN_ == format_item_t::argN_tabulation) {
                ((item.pad_scheme_ & format_item_t::tabulation) ? static_cast<void> (0) : __assert_fail ("item.pad_scheme_ & format_item_t::tabulation", "/usr/include/boost/format/format_implementation.hpp", 193, __PRETTY_FUNCTION__));
                if( static_cast<size_type>(item.fmtstate_.width_) > res.size() )
                    res.append( static_cast<size_type>(item.fmtstate_.width_) - res.size(),
                                        item.fmtstate_.fill_ );
            }
            res += item.appendix_;
        }
        dumped_=true;
        return res;
    }
    template< class Ch, class Tr, class Alloc>
    typename std::basic_string<Ch, Tr, Alloc>::size_type basic_format<Ch,Tr, Alloc>::
    size () const {







        using std::max;
        size_type sz = prefix_.size();
        unsigned long i;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            sz += item.res_.size();
            if( item.argN_ == format_item_t::argN_tabulation)
                sz = max (sz,
                                        static_cast<size_type>(item.fmtstate_.width_) );
            sz += item.appendix_.size();
        }
        return sz;



    }

namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self, int argN, const T& val) {


        if(self.dumped_)
            self.clear();
        if(argN<1 || argN > self.num_args_) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(argN, 1, self.num_args_+1 ) );
            else return self;
        }
        if(self.bound_.size()==0)
            self.bound_.assign(self.num_args_,false);
        else
            ((self.num_args_ == static_cast<signed int>(self.bound_.size())) ? static_cast<void> (0) : __assert_fail ("self.num_args_ == static_cast<signed int>(self.bound_.size())", "/usr/include/boost/format/format_implementation.hpp", 248, __PRETTY_FUNCTION__));
        int o_cur_arg = self.cur_arg_;
        self.cur_arg_ = argN-1;

        self.bound_[self.cur_arg_]=false;
        self.operator%(val);



        self.cur_arg_ = o_cur_arg;
        self.bound_[argN-1]=true;
        if(self.cur_arg_ == argN-1 ) {

            while(self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_])
                ++self.cur_arg_;
        }

        ((self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]) ? static_cast<void> (0) : __assert_fail ("self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]", "/usr/include/boost/format/format_implementation.hpp", 265, __PRETTY_FUNCTION__));
        return self;
    }

    template<class Ch, class Tr, class Alloc, class T> basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self, int itemN, T manipulator) {


        if(itemN<1 || itemN > static_cast<signed int>(self.items_.size() )) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(itemN, 1, static_cast<int>(self.items_.size()) ));
            else return self;
        }
        self.items_[itemN-1].fmtstate_. template apply_manip<T> ( manipulator );
        return self;
    }

}
}
}
# 48 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/group.hpp" 1 3 4
# 29 "/usr/include/boost/format/group.hpp" 3 4
namespace boost {
namespace io {


namespace detail {



struct group0
{
    group0() {}
};

template <class Ch, class Tr>
inline
::std:: basic_ostream<Ch, Tr>&
operator << ( ::std:: basic_ostream<Ch, Tr>& os,
             const group0& )
{
   return os;
}

template <class T1>
struct group1
{
    T1 a1_;
    group1(T1 a1)
      : a1_(a1)
      {}
private:
   group1& operator=(const group1&);
};

template <class Ch, class Tr, class T1>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group1<T1>& x)
{
   os << x.a1_;
   return os;
}




template <class T1,class T2>
struct group2
{
    T1 a1_;
    T2 a2_;
    group2(T1 a1,T2 a2)
      : a1_(a1),a2_(a2)
      {}
private:
   group2& operator=(const group2&);
};

template <class Ch, class Tr, class T1,class T2>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group2<T1,T2>& x)
{
   os << x.a1_<< x.a2_;
   return os;
}

template <class T1,class T2,class T3>
struct group3
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    group3(T1 a1,T2 a2,T3 a3)
      : a1_(a1),a2_(a2),a3_(a3)
      {}
private:
   group3& operator=(const group3&);
};

template <class Ch, class Tr, class T1,class T2,class T3>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group3<T1,T2,T3>& x)
{
   os << x.a1_<< x.a2_<< x.a3_;
   return os;
}

template <class T1,class T2,class T3,class T4>
struct group4
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    group4(T1 a1,T2 a2,T3 a3,T4 a4)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4)
      {}
private:
   group4& operator=(const group4&);
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group4<T1,T2,T3,T4>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5>
struct group5
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    group5(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group5<T1,T2,T3,T4,T5>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
struct group6
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    group6(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group6<T1,T2,T3,T4,T5,T6>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
struct group7
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    group7(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group7<T1,T2,T3,T4,T5,T6,T7>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
struct group8
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    group8(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group8<T1,T2,T3,T4,T5,T6,T7,T8>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
struct group9
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    group9(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_;
   return os;
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
struct group10
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    T10 a10_;
    group10(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9,T10 a10)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9),a10_(a10)
      {}
};

template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_<< x.a10_;
   return os;
}




template <class T1,class T2>
inline
group1<T1>
group_head( group2<T1,T2> const& x)
{
   return group1<T1> (x.a1_);
}

template <class T1,class T2>
inline
group1<T2>
group_last( group2<T1,T2> const& x)
{
   return group1<T2> (x.a2_);
}



template <class T1,class T2,class T3>
inline
group2<T1,T2>
group_head( group3<T1,T2,T3> const& x)
{
   return group2<T1,T2> (x.a1_,x.a2_);
}

template <class T1,class T2,class T3>
inline
group1<T3>
group_last( group3<T1,T2,T3> const& x)
{
   return group1<T3> (x.a3_);
}



template <class T1,class T2,class T3,class T4>
inline
group3<T1,T2,T3>
group_head( group4<T1,T2,T3,T4> const& x)
{
   return group3<T1,T2,T3> (x.a1_,x.a2_,x.a3_);
}

template <class T1,class T2,class T3,class T4>
inline
group1<T4>
group_last( group4<T1,T2,T3,T4> const& x)
{
   return group1<T4> (x.a4_);
}



template <class T1,class T2,class T3,class T4,class T5>
inline
group4<T1,T2,T3,T4>
group_head( group5<T1,T2,T3,T4,T5> const& x)
{
   return group4<T1,T2,T3,T4> (x.a1_,x.a2_,x.a3_,x.a4_);
}

template <class T1,class T2,class T3,class T4,class T5>
inline
group1<T5>
group_last( group5<T1,T2,T3,T4,T5> const& x)
{
   return group1<T5> (x.a5_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group5<T1,T2,T3,T4,T5>
group_head( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group5<T1,T2,T3,T4,T5> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group1<T6>
group_last( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group1<T6> (x.a6_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group6<T1,T2,T3,T4,T5,T6>
group_head( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group6<T1,T2,T3,T4,T5,T6> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group1<T7>
group_last( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group1<T7> (x.a7_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group7<T1,T2,T3,T4,T5,T6,T7>
group_head( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group7<T1,T2,T3,T4,T5,T6,T7> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group1<T8>
group_last( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group1<T8> (x.a8_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group8<T1,T2,T3,T4,T5,T6,T7,T8>
group_head( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group8<T1,T2,T3,T4,T5,T6,T7,T8> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group1<T9>
group_last( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group1<T9> (x.a9_);
}



template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>
group_head( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_,x.a9_);
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group1<T10>
group_last( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group1<T10> (x.a10_);
}





}






inline detail::group1< detail::group0 >
group() { return detail::group1< detail::group0 > ( detail::group0() ); }

template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var const&> >
  group(T1 a1, Var const& var)
{
   return detail::group1< detail::group2<T1, Var const&> >
                   ( detail::group2<T1, Var const&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var const&> >
  group(T1 a1,T2 a2, Var const& var)
{
   return detail::group1< detail::group3<T1,T2, Var const&> >
                   ( detail::group3<T1,T2, Var const&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var const&> >
  group(T1 a1,T2 a2,T3 a3, Var const& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var const&> >
                   ( detail::group4<T1,T2,T3, Var const&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var const& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
                   ( detail::group5<T1,T2,T3,T4, Var const&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var const& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var const&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var const& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var const&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var const& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var const& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var const& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}




template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var&> >
  group(T1 a1, Var& var)
{
   return detail::group1< detail::group2<T1, Var&> >
                   ( detail::group2<T1, Var&>
                        (a1, var)
                  );
}

template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var&> >
  group(T1 a1,T2 a2, Var& var)
{
   return detail::group1< detail::group3<T1,T2, Var&> >
                   ( detail::group3<T1,T2, Var&>
                        (a1,a2, var)
                  );
}

template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var&> >
  group(T1 a1,T2 a2,T3 a3, Var& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var&> >
                   ( detail::group4<T1,T2,T3, Var&>
                        (a1,a2,a3, var)
                  );
}

template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
                   ( detail::group5<T1,T2,T3,T4, Var&>
                        (a1,a2,a3,a4, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var&>
                        (a1,a2,a3,a4,a5, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}

template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}





}

}
# 49 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/feed_args.hpp" 1 3 4
# 18 "/usr/include/boost/format/feed_args.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 19 "/usr/include/boost/format/feed_args.hpp" 2 3 4




# 1 "/usr/include/boost/format/detail/msvc_disambiguater.hpp" 1 3 4
# 24 "/usr/include/boost/format/feed_args.hpp" 2 3 4

namespace boost {
namespace io {
namespace detail {

    template<class Ch, class Tr, class Alloc>
    void mk_str( std::basic_string<Ch,Tr, Alloc> & res,
                 const Ch * beg,
                 typename std::basic_string<Ch,Tr,Alloc>::size_type size,
                 std::streamsize w,
                 const Ch fill_char,
                 std::ios_base::fmtflags f,
                 const Ch prefix_space,
                 bool center)


    {
        typedef typename std::basic_string<Ch,Tr,Alloc>::size_type size_type;
        res.resize(0);
        if(w<=0 || static_cast<size_type>(w) <=size) {

            res.reserve(size + !!prefix_space);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
        }
        else {
            std::streamsize n=static_cast<std::streamsize>(w-size-!!prefix_space);
            std::streamsize n_after = 0, n_before = 0;
            res.reserve(static_cast<size_type>(w));
            if(center)
                n_after = n/2, n_before = n - n_after;
            else
                if(f & std::ios_base::left)
                    n_after = n;
                else
                    n_before = n;

            if(n_before) res.append(static_cast<size_type>(n_before), fill_char);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
            if(n_after) res.append(static_cast<size_type>(n_after), fill_char);
        }
    }
# 89 "/usr/include/boost/format/feed_args.hpp" 3 4
    template< class Ch, class Tr, class T> inline
    void put_head (::std:: basic_ostream<Ch, Tr> &, const T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_head(x.a1_);
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const T& x ) {
        os << x ;
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_last(x.a1_);
    }


    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> &, T& ) {
    }

    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, T& x) {
        os << x ;
    }




    template< class Ch, class Tr, class Alloc, class T>
    void put( T x,
              const format_item<Ch, Tr, Alloc>& specs,
              typename basic_format<Ch, Tr, Alloc>::string_type& res,
              typename basic_format<Ch, Tr, Alloc>::internal_streambuf_t & buf,
              io::detail::locale_t *loc_p = __null)
    {
# 138 "/usr/include/boost/format/feed_args.hpp" 3 4
        typedef typename basic_format<Ch, Tr, Alloc>::string_type string_type;
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;
        typedef typename string_type::size_type size_type;

        basic_oaltstringstream<Ch, Tr, Alloc> oss( &buf);
        specs.fmtstate_.apply_on(oss, loc_p);


        put_head( oss, x );



        const std::ios_base::fmtflags fl=oss.flags();
        const bool internal = (fl & std::ios_base::internal) != 0;
        const std::streamsize w = oss.width();
        const bool two_stepped_padding= internal && (w!=0);

        res.resize(0);
        if(! two_stepped_padding) {
            if(w>0)
                oss.width(0);
            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            Ch prefix_space = 0;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = oss.widen(' ');
            size_type res_size = (std::min)(
                static_cast<size_type>(specs.truncate_ - !!prefix_space),
                buf.pcount() );
            mk_str(res, res_beg, res_size, w, oss.fill(), fl,
                   prefix_space, (specs.pad_scheme_ & format_item_t::centered) !=0 );
        }
        else {



            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            size_type res_size = buf.pcount();
            bool prefix_space=false;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = true;
            if(res_size == static_cast<size_type>(w) && w<=specs.truncate_ && !prefix_space) {

                res.assign(res_beg, res_size);
            }
            else {



                res.assign(res_beg, res_size);
                res_beg=__null;


                buf.clear_buffer();
                basic_oaltstringstream<Ch, Tr, Alloc> oss2( &buf);
                specs.fmtstate_.apply_on(oss2, loc_p);
                put_head( oss2, x );

                oss2.width(0);
                if(prefix_space)
                    oss2 << ' ';
                put_last(oss2, x );
                if(buf.pcount()==0 && specs.pad_scheme_ & format_item_t::spacepad) {
                    prefix_space =true;
                    oss2 << ' ';
                }

                const Ch * tmp_beg = buf.pbase();
                size_type tmp_size = (std::min)(static_cast<size_type>(specs.truncate_),
                                                buf.pcount() );


                if(static_cast<size_type>(w) <= tmp_size) {

                        res.assign(tmp_beg, tmp_size);
                }
                else {

                    size_type sz = (std::min)(res_size + (prefix_space ? 1 : 0), tmp_size);
                    size_type i = prefix_space;
                    for(; i<sz && tmp_beg[i] == res[i - (prefix_space ? 1 : 0)]; ++i) {}
                    if(i>=tmp_size) i=prefix_space;
                    res.assign(tmp_beg, i);
                                        std::streamsize d = w - static_cast<std::streamsize>(tmp_size);
                                        ((d>0) ? static_cast<void> (0) : __assert_fail ("d>0", "/usr/include/boost/format/feed_args.hpp", 227, __PRETTY_FUNCTION__));
                    res.append(static_cast<size_type>( d ), oss2.fill());
                    res.append(tmp_beg+i, tmp_size-i);
                    ((i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)) ? static_cast<void> (0) : __assert_fail ("i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)", "/usr/include/boost/format/feed_args.hpp", 231, __PRETTY_FUNCTION__));

                    ((res.size() == static_cast<size_type>(w)) ? static_cast<void> (0) : __assert_fail ("res.size() == static_cast<size_type>(w)", "/usr/include/boost/format/feed_args.hpp", 232, __PRETTY_FUNCTION__));
                }
            }
        }
        buf.clear_buffer();



    }


    template< class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x) {

        if(self.cur_arg_ >= self.num_args_) {
            if( self.exceptions() & too_many_args_bit )
                boost::throw_exception(too_many_args(self.cur_arg_, self.num_args_));
            else return;
        }
        for(unsigned long i=0; i < self.items_.size(); ++i) {
            if(self.items_[i].argN_ == self.cur_arg_) {
                put<Ch, Tr, Alloc, T> (x, self.items_[i], self.items_[i].res_,
                                self.buf_, boost::get_pointer(self.loc_) );
            }
        }
    }

    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x) {
        if(self.dumped_) self.clear();
        distribute<Ch, Tr, Alloc, T> (self, x);
        ++self.cur_arg_;
        if(self.bound_.size() != 0) {
                while( self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_] )
                    ++self.cur_arg_;
        }
        return self;
    }

}
}
}
# 50 "/usr/include/boost/format.hpp" 2 3 4
# 1 "/usr/include/boost/format/parsing.hpp" 1 3 4
# 21 "/usr/include/boost/format/parsing.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 22 "/usr/include/boost/format/parsing.hpp" 2 3 4


namespace boost {
namespace io {
namespace detail {
# 35 "/usr/include/boost/format/parsing.hpp" 3 4
    template<class T>
    const T& const_or_not(const T& x) {
        return x;
    }


    template<class Ch, class Facet> inline
    char wrap_narrow(const Facet& fac, Ch c, char deflt) {
        return const_or_not(fac).narrow(c, deflt);
    }

    template<class Ch, class Facet> inline
    bool wrap_isdigit(const Facet& fac, Ch c) {

        return fac.is(std::ctype<Ch>::digit, c);





    }

    template<class Iter, class Facet>
    Iter wrap_scan_notdigit(const Facet & fac, Iter beg, Iter end) {
        using namespace std;
        for( ; beg!=end && wrap_isdigit(fac, *beg); ++beg) ;
        return beg;
    }






    template<class Res, class Iter, class Facet>
    Iter str2int (const Iter & start, const Iter & last, Res & res,
                 const Facet& fac)
    {
        using namespace std;
        Iter it;
        res=0;
        for(it=start; it != last && wrap_isdigit(fac, *it); ++it ) {
            char cur_ch = wrap_narrow(fac, *it, 0);
            res *= 10;
            res += cur_ch - '0';
        }
        return it;
    }






    template<class Iter, class Facet>
    Iter skip_asterisk(Iter start, Iter last, const Facet& fac)
    {
        using namespace std;
        ++ start;
        start = wrap_scan_notdigit(fac, start, last);
        if(start!=last && *start== const_or_not(fac).widen( '$') )
            ++start;
        return start;
    }





    inline void maybe_throw_exception(unsigned char exceptions,
                                      std::size_t pos, std::size_t size)
    {
        if(exceptions & io::bad_format_string_bit)
            boost::throw_exception(io::bad_format_string(pos, size) );
    }
# 122 "/usr/include/boost/format/parsing.hpp" 3 4
    template<class Ch, class Tr, class Alloc, class Iter, class Facet>
    bool parse_printf_directive(Iter & start, const Iter& last,
                                detail::format_item<Ch, Tr, Alloc> * fpar,
                                const Facet& fac,
                                std::size_t offset, unsigned char exceptions)
    {
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;

        fpar->argN_ = format_item_t::argN_no_posit;
        bool precision_set = false;
        bool in_brackets=false;
        Iter start0 = start;
        std::size_t fstring_size = last-start0+offset;

        if(start>= last) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
        }

        if(*start== const_or_not(fac).widen( '|')) {
            in_brackets=true;
            if( ++start >= last ) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
            }
        }


        if(*start== const_or_not(fac).widen( '0'))
            goto parse_flags;


        if(wrap_isdigit(fac, *start)) {
            int n;
            start = str2int(start, last, n, fac);
            if( start >= last ) {
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
                return false;
            }


            if( *start == const_or_not(fac).widen( '%') ) {
                fpar->argN_ = n-1;
                ++start;
                if( in_brackets)
                    maybe_throw_exception(exceptions, start-start0+offset, fstring_size);

                else
                    return true;
            }

            if ( *start== const_or_not(fac).widen( '$') ) {
                fpar->argN_ = n-1;
                ++start;
            }
            else {

                fpar->fmtstate_.width_ = n;
                fpar->argN_ = format_item_t::argN_no_posit;
                goto parse_precision;
            }
        }

      parse_flags:

        while ( start != last) {

            switch ( wrap_narrow(fac, *start, 0)) {
            case '\'' : break;
            case 'l':
            case 'h':
                break;
            case '-':
                fpar->fmtstate_.flags_ |= std::ios_base::left;
                break;
            case '=':
                fpar->pad_scheme_ |= format_item_t::centered;
                break;
            case '_':
                fpar->fmtstate_.flags_ |= std::ios_base::internal;
                break;
            case ' ':
                fpar->pad_scheme_ |= format_item_t::spacepad;
                break;
            case '+':
                fpar->fmtstate_.flags_ |= std::ios_base::showpos;
                break;
            case '0':
                fpar->pad_scheme_ |= format_item_t::zeropad;


                break;
            case '#':
                fpar->fmtstate_.flags_ |= std::ios_base::showpoint | std::ios_base::showbase;
                break;
            default:
                goto parse_width;
            }
            ++start;
        }

        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }
      parse_width:


        if(*start == const_or_not(fac).widen( '*') )
            start = skip_asterisk(start, last, fac);
        if(start!=last && wrap_isdigit(fac, *start))
            start = str2int(start, last, fpar->fmtstate_.width_, fac);

      parse_precision:
        if( start>= last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if (*start== const_or_not(fac).widen( '.')) {
            ++start;
            if(start != last && *start == const_or_not(fac).widen( '*') )
                start = skip_asterisk(start, last, fac);
            if(start != last && wrap_isdigit(fac, *start)) {
                start = str2int(start, last, fpar->fmtstate_.precision_, fac);
                precision_set = true;
            }
            else
                fpar->fmtstate_.precision_ =0;
        }


        while( start != last && ( *start== const_or_not(fac).widen( 'l')
                                  || *start== const_or_not(fac).widen( 'L')
                                  || *start== const_or_not(fac).widen( 'h')) )
            ++start;
        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }

        if( in_brackets && *start== const_or_not(fac).widen( '|') ) {
            ++start;
            return true;
        }
        switch ( wrap_narrow(fac, *start, 0) ) {
        case 'X':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'p':
        case 'x':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::hex;
            break;

        case 'o':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::oct;
            break;

        case 'E':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'e':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::scientific;

            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'f':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::fixed;
        case 'u':
        case 'd':
        case 'i':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;

        case 'T':
            ++start;
            if( start >= last)
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            else
                fpar->fmtstate_.fill_ = *start;
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;
        case 't':
            fpar->fmtstate_.fill_ = const_or_not(fac).widen( ' ');
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;

        case 'G':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
            break;
        case 'g':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;


            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            break;

        case 'C':
        case 'c':
            fpar->truncate_ = 1;
            break;
        case 'S':
        case 's':
            if(precision_set)
                fpar->truncate_ = fpar->fmtstate_.precision_;
            fpar->fmtstate_.precision_ = 6;
            break;
        case 'n' :
            fpar->argN_ = format_item_t::argN_ignored;
            break;
        default:
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        ++start;

        if( in_brackets ) {
            if( start != last && *start== const_or_not(fac).widen( '|') ) {
                ++start;
                return true;
            }
            else maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        return true;
    }


    template<class String, class Facet>
    int upper_bound_from_fstring(const String& buf,
                                 const typename String::value_type arg_mark,
                                 const Facet& fac,
                                 unsigned char exceptions)
    {


        using namespace boost::io;
        typename String::size_type i1=0;
        int num_items=0;
        while( (i1=buf.find(arg_mark,i1)) != String::npos ) {
            if( i1+1 >= buf.size() ) {
                if(exceptions & bad_format_string_bit)
                    boost::throw_exception(bad_format_string(i1, buf.size() ));
                else {
                  ++num_items;
                  break;
                }
            }
            if(buf[i1+1] == buf[i1] ) {
                i1+=2; continue;
            }

            ++i1;

            i1 = detail::wrap_scan_notdigit(fac, buf.begin()+i1, buf.end()) - buf.begin();
            if( i1 < buf.size() && buf[i1] == arg_mark )
                ++i1;
            ++num_items;
        }
        return num_items;
    }
    template<class String> inline
    void append_string(String& dst, const String& src,
                       const typename String::size_type beg,
                       const typename String::size_type end) {

        dst.append(src.begin()+beg, src.begin()+end);



    }

}
}






    template<class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    parse (const string_type& buf) {

        using namespace std;

        const std::ctype<Ch> & fac = std::use_facet< std::ctype<Ch> >(getloc());





        const Ch arg_mark = io::detail::const_or_not(fac).widen( '%');
        bool ordered_args=true;
        int max_argN=-1;


        int num_items = io::detail::upper_bound_from_fstring(buf, arg_mark, fac, exceptions());
        make_or_reuse_data(num_items);


        num_items=0;
        typename string_type::size_type i0=0, i1=0;
        typename string_type::const_iterator it;
        bool special_things=false;
        int cur_item=0;
        while( (i1=buf.find(arg_mark,i1)) != string_type::npos ) {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            if( buf[i1+1] == buf[i1] ) {
                io::detail::append_string(piece, buf, i0, i1+1);
                i1+=2; i0=i1;
                continue;
            }
            ((static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0) ? static_cast<void> (0) : __assert_fail ("static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0", "/usr/include/boost/format/parsing.hpp", 441, __PRETTY_FUNCTION__));

            if(i1!=i0) {
                io::detail::append_string(piece, buf, i0, i1);
                i0=i1;
            }
            ++i1;
            it = buf.begin()+i1;
            bool parse_ok = io::detail::parse_printf_directive(
                it, buf.end(), &items_[cur_item], fac, i1, exceptions());
            i1 = it - buf.begin();
            if( ! parse_ok )
                continue;
            i0=i1;
            items_[cur_item].compute_states();

            int argN=items_[cur_item].argN_;
            if(argN == format_item_t::argN_ignored)
                continue;
            if(argN ==format_item_t::argN_no_posit)
                ordered_args=false;
            else if(argN == format_item_t::argN_tabulation) special_things=true;
            else if(argN > max_argN) max_argN = argN;
            ++num_items;
            ++cur_item;
        }
        ((cur_item == num_items) ? static_cast<void> (0) : __assert_fail ("cur_item == num_items", "/usr/include/boost/format/parsing.hpp", 467, __PRETTY_FUNCTION__));


        {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            io::detail::append_string(piece, buf, i0, buf.size());
        }

        if( !ordered_args) {
            if(max_argN >= 0 ) {
                if(exceptions() & io::bad_format_string_bit)
                    boost::throw_exception(io::bad_format_string(max_argN, 0));

            }

            int non_ordered_items = 0;
            for(int i=0; i< num_items; ++i)
                if(items_[i].argN_ == format_item_t::argN_no_posit) {
                    items_[i].argN_ = non_ordered_items;
                    ++non_ordered_items;
                }
            max_argN = non_ordered_items-1;
        }


        items_.resize(num_items, format_item_t(io::detail::const_or_not(fac).widen( ' ')) );

        if(special_things) style_ |= special_needs;
        num_args_ = max_argN + 1;
        if(ordered_args) style_ |= ordered;
        else style_ &= ~ordered;
        return *this;
    }

}
# 51 "/usr/include/boost/format.hpp" 2 3 4


# 1 "/usr/include/boost/format/free_funcs.hpp" 1 3 4
# 19 "/usr/include/boost/format/free_funcs.hpp" 3 4
namespace boost {

    template<class Ch, class Tr, class Alloc> inline
    std::basic_string<Ch, Tr, Alloc> str(const basic_format<Ch, Tr, Alloc>& f) {

        return f.str();
    }
    namespace io {
         using ::boost::str;
    }


        template<class Ch, class Tr, class Alloc>
        std::basic_ostream<Ch, Tr> &
        operator<<( std::basic_ostream<Ch, Tr> & os,
                    const basic_format<Ch, Tr, Alloc>& f)







    {
        typedef boost::basic_format<Ch, Tr, Alloc> format_t;
        if(f.items_.size()==0)
            os << f.prefix_;
        else {
            if(f.cur_arg_ < f.num_args_)
                if( f.exceptions() & io::too_few_args_bit )

                    boost::throw_exception(io::too_few_args(f.cur_arg_, f.num_args_));
            if(f.style_ & format_t::special_needs)
                os << f.str();
            else {

                os << f.prefix_;
                for(unsigned long i=0; i<f.items_.size(); ++i) {
                    const typename format_t::format_item_t& item = f.items_[i];
                    os << item.res_;
                    os << item.appendix_;
                }
            }
        }
        f.dumped_=true;
        return os;
    }

}
# 54 "/usr/include/boost/format.hpp" 2 3 4



# 1 "/usr/include/boost/format/detail/unset_macros.hpp" 1 3 4
# 58 "/usr/include/boost/format.hpp" 2 3 4
# 25 "/usr/include/cocaine/helpers/format.hpp" 2 3 4

namespace cocaine {

namespace detail {
    static inline
    std::string
    substitute(boost::format& message) {
        return message.str();
    }

    template<typename T, typename... Args>
    static inline
    std::string
    substitute(boost::format& message,
               const T& argument,
               const Args&... args)
    {
        return substitute(message % argument, args...);
    }
}

template<typename... Args>
static inline
std::string
format(const std::string& format,
       const Args&... args)
{
    boost::format message(format);

    try {
        return detail::substitute(message, args...);
    } catch(const boost::io::format_error& e) {
        return "<unable to format the message>";
    }
}

}
# 25 "/usr/include/cocaine/exceptions.hpp" 2 3 4

# 1 "/usr/include/c++/4.4/cerrno" 1 3 4
# 41 "/usr/include/c++/4.4/cerrno" 3 4
       
# 42 "/usr/include/c++/4.4/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 44 "/usr/include/c++/4.4/cerrno" 2 3
# 27 "/usr/include/cocaine/exceptions.hpp" 2 3 4
# 1 "/usr/include/c++/4.4/cstring" 1 3 4
# 41 "/usr/include/c++/4.4/cstring" 3 4
       
# 42 "/usr/include/c++/4.4/cstring" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 92 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 164 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 208 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strchr (__const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 231 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strrchr (__const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 258 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 310 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strstr (__const char *__haystack,
        __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 338 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" __const char *strcasestr (__const char *__haystack,
           __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 380 "/usr/include/string.h" 3 4
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 436 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *index (__const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 485 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *rindex (__const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 513 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *basename (__const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4
}
# 46 "/usr/include/c++/4.4/cstring" 2 3
# 74 "/usr/include/c++/4.4/cstring" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 121 "/usr/include/c++/4.4/cstring" 3
}
# 28 "/usr/include/cocaine/exceptions.hpp" 2 3 4


namespace cocaine {

enum error_code {
    invocation_error = 1,
    resource_error,
    timeout_error,
    deadline_error
};

struct error_t:
    public std::exception
{
    template<typename... Args>
    error_t(const std::string& format,
            const Args&... args):
        m_message(cocaine::format(format, args...))
    { }

    virtual
    ~error_t() throw() {

    }

    virtual
    const char*
    what() const throw() {
        return m_message.c_str();
    }

private:
    const std::string m_message;
};

struct configuration_error_t:
    public error_t
{
    template<typename... Args>
    configuration_error_t(const std::string& format,
                          const Args&... args):
        error_t(format, args...)
    { }
};

struct system_error_t:
    public error_t
{
    public:
        template<typename... Args>
        system_error_t(const std::string& format,
                       const Args&... args):
            error_t(format, args...)
        {
            ::strerror_r((*__errno_location ()), m_reason, 1024);
        }

        const char*
        reason() const throw() {
            return m_reason;
        }

    private:
        char m_reason[1024];
};

}
# 46 "/usr/include/cocaine/common.hpp" 2 3 4
# 6 "../src/worker.hpp" 2
# 1 "/usr/include/cocaine/rpc.hpp" 1 3 4
# 24 "/usr/include/cocaine/rpc.hpp" 3 4
# 1 "/usr/include/cocaine/channel.hpp" 1 3 4
# 24 "/usr/include/cocaine/channel.hpp" 3 4
# 1 "/usr/include/cocaine/io.hpp" 1 3 4
# 25 "/usr/include/cocaine/io.hpp" 3 4
# 1 "/usr/include/cocaine/traits.hpp" 1 3 4
# 26 "/usr/include/cocaine/traits.hpp" 3 4
# 1 "/usr/include/boost/mpl/begin.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/begin.hpp" 3 4
# 1 "/usr/include/boost/mpl/begin_end.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/begin_end.hpp" 3 4
# 1 "/usr/include/boost/mpl/begin_end_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/begin_end_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct begin_impl;
template< typename Tag > struct end_impl;

template< typename Sequence > struct begin;
template< typename Sequence > struct end;

}}
# 18 "/usr/include/boost/mpl/begin_end.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/begin_end_impl.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/begin_end_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/sequence_tag_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/sequence_tag_fwd.hpp" 3 4
namespace boost { namespace mpl {

struct nested_begin_end_tag;
struct non_sequence_tag;

template< typename Sequence > struct sequence_tag;

}}
# 19 "/usr/include/boost/mpl/aux_/begin_end_impl.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/has_begin.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/has_begin.hpp" 3 4
# 1 "/usr/include/boost/mpl/has_xxx.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/has_xxx.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/type_wrapper.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/aux_/type_wrapper.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

template< typename T > struct type_wrapper
{
    typedef T type;
};






template< typename T > struct wrapped_type;

template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};







}}}
# 20 "/usr/include/boost/mpl/has_xxx.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/config/has_xxx.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/has_xxx.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/msvc_typename.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/has_xxx.hpp" 2 3 4
# 18 "/usr/include/boost/mpl/aux_/has_begin.hpp" 2 3 4

namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_begin { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::begin>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 22 "/usr/include/boost/mpl/aux_/begin_end_impl.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/traits_lambda_spec.hpp" 1 3 4
# 24 "/usr/include/boost/mpl/aux_/begin_end_impl.hpp" 2 3 4


namespace boost { namespace mpl {


namespace aux {

template< typename Sequence >
struct begin_type
{
    typedef typename Sequence::begin type;
};
template< typename Sequence >
struct end_type
{
    typedef typename Sequence::end type;
};

}





template< typename Tag >
struct begin_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::begin_type<Sequence>, void_>::type type;
    };
};

template< typename Tag >
struct end_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::end_type<Sequence>, void_>::type type;
    };
};
# 82 "/usr/include/boost/mpl/aux_/begin_end_impl.hpp" 3 4
template<> struct begin_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::begin type; }; };
template<> struct end_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::end type; }; };




template<> struct begin_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct begin_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };







}}
# 19 "/usr/include/boost/mpl/begin_end.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/sequence_tag.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/sequence_tag.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/has_tag.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/has_tag.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 19 "/usr/include/boost/mpl/sequence_tag.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 1 3 4
# 21 "/usr/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
# 62 "/usr/include/boost/mpl/aux_/is_msvc_eti_arg.hpp" 3 4
}}}
# 22 "/usr/include/boost/mpl/sequence_tag.hpp" 2 3 4




namespace boost { namespace mpl {
# 78 "/usr/include/boost/mpl/sequence_tag.hpp" 3 4
namespace aux {

template< bool has_tag_, bool has_begin_ >
struct sequence_tag_impl
{


    template< typename Sequence > struct result2_;
};
# 98 "/usr/include/boost/mpl/sequence_tag.hpp" 3 4
template<> struct sequence_tag_impl<true,true> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<true,false> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<false,true> { template< typename Sequence > struct result2_ { typedef nested_begin_end_tag type; }; };
template<> struct sequence_tag_impl<false,false> { template< typename Sequence > struct result2_ { typedef non_sequence_tag type; }; };



}

template<
      typename Sequence = na
    >
struct sequence_tag
    : aux::sequence_tag_impl<
          ::boost::mpl::aux::has_tag<Sequence>::value
        , ::boost::mpl::aux::has_begin<Sequence>::value
        >::template result2_<Sequence>
{
};



template<> struct sequence_tag< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sequence_tag< T1 > { }; }; template< typename Tag > struct lambda< sequence_tag< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sequence_tag< na > result_; typedef sequence_tag< na > type; }; namespace aux { template< typename T1 > struct template_arity< sequence_tag< T1 > > : int_<1> { }; template<> struct template_arity< sequence_tag< na > > : int_<-1> { }; }

}}
# 20 "/usr/include/boost/mpl/begin_end.hpp" 2 3 4



namespace boost { namespace mpl {




template<
      typename Sequence = na
    >
struct begin
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename begin_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<
      typename Sequence = na
    >
struct end
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename end_impl< tag_ >
        ::template apply< Sequence >::type type;

   
};

template<> struct begin< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : begin< T1 > { }; }; template< typename Tag > struct lambda< begin< na > , Tag , int_<-1> > { typedef false_ is_le; typedef begin< na > result_; typedef begin< na > type; }; namespace aux { template< typename T1 > struct template_arity< begin< T1 > > : int_<1> { }; template<> struct template_arity< begin< na > > : int_<-1> { }; }
template<> struct end< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : end< T1 > { }; }; template< typename Tag > struct lambda< end< na > , Tag , int_<-1> > { typedef false_ is_le; typedef end< na > result_; typedef end< na > type; }; namespace aux { template< typename T1 > struct template_arity< end< T1 > > : int_<1> { }; template<> struct template_arity< end< na > > : int_<-1> { }; }

}}
# 18 "/usr/include/boost/mpl/begin.hpp" 2 3 4
# 27 "/usr/include/cocaine/traits.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/deref.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/deref.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/msvc_type.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/aux_/msvc_type.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
# 48 "/usr/include/boost/mpl/aux_/msvc_type.hpp" 3 4
template< typename T > struct msvc_type
{
    typedef typename T::type type;
};

template<> struct msvc_type<int>
{
    typedef int type;
};



}}}
# 18 "/usr/include/boost/mpl/deref.hpp" 2 3 4




namespace boost { namespace mpl {

template<
      typename Iterator = na
    >
struct deref
{

    typedef typename Iterator::type type;



   
};

template<> struct deref< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : deref< T1 > { }; }; template< typename Tag > struct lambda< deref< na > , Tag , int_<-1> > { typedef false_ is_le; typedef deref< na > result_; typedef deref< na > type; }; namespace aux { template< typename T1 > struct template_arity< deref< T1 > > : int_<1> { }; template<> struct template_arity< deref< na > > : int_<-1> { }; }

}}
# 28 "/usr/include/cocaine/traits.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/is_sequence.hpp" 1 3 4
# 40 "/usr/include/boost/mpl/is_sequence.hpp" 3 4
namespace boost { namespace mpl {
# 90 "/usr/include/boost/mpl/is_sequence.hpp" 3 4
template<
      typename T = na
    >
struct is_sequence
    : not_< is_same< typename begin<T>::type, void_ > >
{
   
};
# 108 "/usr/include/boost/mpl/is_sequence.hpp" 3 4
template<> struct is_sequence< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_sequence< T1 > { }; }; template< typename Tag > struct lambda< is_sequence< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_sequence< na > result_; typedef is_sequence< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_sequence< T1 > > : int_<1> { }; template<> struct template_arity< is_sequence< na > > : int_<-1> { }; }

}}
# 29 "/usr/include/cocaine/traits.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/next.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/next.hpp" 3 4
# 1 "/usr/include/boost/mpl/next_prior.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/next_prior.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/common_name_wknd.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/next_prior.hpp" 2 3 4



namespace boost { namespace mpl {




template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;
   
};

template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;
   
};

template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }

}}
# 18 "/usr/include/boost/mpl/next.hpp" 2 3 4
# 30 "/usr/include/cocaine/traits.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/size.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/size.hpp" 3 4
# 1 "/usr/include/boost/mpl/size_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/size_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct size_impl;
template< typename Sequence > struct size;

}}
# 18 "/usr/include/boost/mpl/size.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/size_impl.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/size_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/distance.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/distance.hpp" 3 4
# 1 "/usr/include/boost/mpl/distance_fwd.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/distance_fwd.hpp" 3 4
namespace boost { namespace mpl {



template< typename Tag > struct distance_impl;
template< typename First, typename Last > struct distance;

}}
# 18 "/usr/include/boost/mpl/distance.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/iter_fold.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/iter_fold.hpp" 3 4
# 1 "/usr/include/boost/mpl/O1_size.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/O1_size.hpp" 3 4
# 1 "/usr/include/boost/mpl/O1_size_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/O1_size_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct O1_size_impl;
template< typename Sequence > struct O1_size;

}}
# 18 "/usr/include/boost/mpl/O1_size.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/long.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/long.hpp" 3 4
# 1 "/usr/include/boost/mpl/long_fwd.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/long_fwd.hpp" 3 4
namespace mpl_ {

template< long N > struct long_;

}
namespace boost { namespace mpl { using ::mpl_::long_; } }
# 18 "/usr/include/boost/mpl/long.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 1 3 4
# 40 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
namespace mpl_ {

template< long N >
struct long_
{
    static const long value = N;





    typedef long_ type;

    typedef long value_type;
    typedef integral_c_tag tag;
# 72 "/usr/include/boost/mpl/aux_/integral_wrapper.hpp" 3 4
    typedef mpl_::long_< static_cast<long>((value + 1)) > next;
    typedef mpl_::long_< static_cast<long>((value - 1)) > prior;






    operator long() const { return static_cast<long>(this->value); }
};


template< long N >
long const mpl_::long_< N >::value;


}
# 21 "/usr/include/boost/mpl/long.hpp" 2 3 4
# 19 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/has_size.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/has_size.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_size { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::size>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 21 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/config/forwarding.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 2 3 4




namespace boost { namespace mpl {
# 35 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 3 4
namespace aux {
template< typename Sequence > struct O1_size_impl
    : Sequence::size
{
};
}

template< typename Tag >
struct O1_size_impl
{
    template< typename Sequence > struct apply

        : if_<
              aux::has_size<Sequence>
            , aux::O1_size_impl<Sequence>
            , long_<-1>
            >::type
    {
# 69 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 3 4
    };
};
# 85 "/usr/include/boost/mpl/aux_/O1_size_impl.hpp" 3 4
}}
# 20 "/usr/include/boost/mpl/O1_size.hpp" 2 3 4



namespace boost { namespace mpl {


template<
      typename Sequence = na
    >
struct O1_size
    : O1_size_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence >
{
   
};

template<> struct O1_size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : O1_size< T1 > { }; }; template< typename Tag > struct lambda< O1_size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef O1_size< na > result_; typedef O1_size< na > type; }; namespace aux { template< typename T1 > struct template_arity< O1_size< T1 > > : int_<1> { }; template<> struct template_arity< O1_size< na > > : int_<-1> { }; }

}}
# 20 "/usr/include/boost/mpl/iter_fold.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/lambda.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/lambda.hpp" 3 4
# 1 "/usr/include/boost/mpl/bind.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/bind.hpp" 3 4
# 1 "/usr/include/boost/mpl/bind_fwd.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/bind_fwd.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/bind.hpp" 1 3 4
# 26 "/usr/include/boost/mpl/bind_fwd.hpp" 2 3 4






# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;

template<
      typename F
    >
struct bind0;

template<
      typename F, typename T1
    >
struct bind1;

template<
      typename F, typename T1, typename T2
    >
struct bind2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 33 "/usr/include/boost/mpl/bind_fwd.hpp" 2 3 4
# 24 "/usr/include/boost/mpl/bind.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/placeholders.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/bind.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/protect.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/protect.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{



    typedef protect type;

};
# 48 "/usr/include/boost/mpl/protect.hpp" 3 4
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };

namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }


}}
# 27 "/usr/include/boost/mpl/bind.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/apply_wrap.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/apply_wrap.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/has_apply.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/has_apply.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/config/has_apply.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/has_apply.hpp" 2 3 4

namespace boost { namespace mpl { namespace aux {

template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };







}}}
# 24 "/usr/include/boost/mpl/apply_wrap.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/msvc_never_true.hpp" 1 3 4
# 26 "/usr/include/boost/mpl/apply_wrap.hpp" 2 3 4
# 34 "/usr/include/boost/mpl/apply_wrap.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename F

    , typename has_apply_ = typename aux::has_apply<F>::type

    >
struct apply_wrap0

    : F::template apply< >
{
};

template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};

template<
      typename F, typename T1

    >
struct apply_wrap1

    : F::template apply<T1>
{
};

template<
      typename F, typename T1, typename T2

    >
struct apply_wrap2

    : F::template apply< T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3

    >
struct apply_wrap3

    : F::template apply< T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4

    >
struct apply_wrap4

    : F::template apply< T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5

    >
struct apply_wrap5

    : F::template apply< T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 35 "/usr/include/boost/mpl/apply_wrap.hpp" 2 3 4
# 28 "/usr/include/boost/mpl/bind.hpp" 2 3 4
# 50 "/usr/include/boost/mpl/bind.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 1 3 4
# 13 "/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp" 3 4
namespace boost { namespace mpl {

namespace aux {

template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};

template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};

template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};

template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}

template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

     public:
        typedef typename apply_wrap0<
              f_
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }

template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};

template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }

template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }

template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }

template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;

        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;

        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;

     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;

    };
};

namespace aux {

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};

}


namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};


template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;

template< typename T1, typename T2, typename T3 > struct if_;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;

template< typename T1, typename T2, typename T3 > struct eval_if;

template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;

        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;

        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;

        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;

     public:
        typedef typename f_::type type;
    };
};

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 51 "/usr/include/boost/mpl/bind.hpp" 2 3 4
# 19 "/usr/include/boost/mpl/lambda.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 3 4
# 1 "/usr/include/boost/mpl/bind_fwd.hpp" 1 3 4
# 24 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/quote.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/quote.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/has_type.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/has_type.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
# 24 "/usr/include/boost/mpl/quote.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/config/bcc.hpp" 1 3 4
# 27 "/usr/include/boost/mpl/quote.hpp" 2 3 4
# 45 "/usr/include/boost/mpl/quote.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp" 3 4
namespace boost { namespace mpl {

template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};

template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};

template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply

        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply

        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply

        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >

    {
    };
};

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >

    {
    };
};

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply

        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >

    {
    };
};

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 46 "/usr/include/boost/mpl/quote.hpp" 2 3 4
# 26 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/arg.hpp" 1 3 4
# 27 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/aux_/template_arity.hpp" 1 3 4
# 43 "/usr/include/boost/mpl/aux_/template_arity.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};

template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    static const int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) );



};

arity_tag<0>::type arity_helper(...);

template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    static const int value = sizeof(arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1;


};

template< typename F >
struct template_arity
{
    static const int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value );




    typedef mpl::int_<value> type;
};

}}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 44 "/usr/include/boost/mpl/aux_/template_arity.hpp" 2 3 4
# 30 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 2 3 4
# 44 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp" 3 4
namespace boost { namespace mpl {

namespace aux {

template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};

template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};

}

template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};

template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};

template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};

template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;

    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;

    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;

    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;

    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;

    typedef result_ type;
};

namespace aux {

template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;

    typedef result_ type;
};

template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;

    typedef mpl::protect<result_> type;
};

}

template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;

    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;


    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;

    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;

    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;

    typedef result_ type;
};


template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};

template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};

template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 45 "/usr/include/boost/mpl/aux_/full_lambda.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/lambda.hpp" 2 3 4
# 21 "/usr/include/boost/mpl/iter_fold.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/iter_fold_impl.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/aux_/iter_fold_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/apply.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/apply.hpp" 3 4
# 1 "/usr/include/boost/mpl/apply_fwd.hpp" 1 3 4
# 31 "/usr/include/boost/mpl/apply_fwd.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;

template<
      typename F
    >
struct apply0;

template<
      typename F, typename T1
    >
struct apply1;

template<
      typename F, typename T1, typename T2
    >
struct apply2;

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 32 "/usr/include/boost/mpl/apply_fwd.hpp" 2 3 4
# 23 "/usr/include/boost/mpl/apply.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/apply_wrap.hpp" 1 3 4
# 24 "/usr/include/boost/mpl/apply.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/placeholders.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/apply.hpp" 2 3 4
# 36 "/usr/include/boost/mpl/apply.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename F
    >
struct apply0

    : apply_wrap0<
          typename lambda<F>::type

        >
{
   




};

template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};

template<
      typename F, typename T1
    >
struct apply1

    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{
   




};

template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};

template<
      typename F, typename T1, typename T2
    >
struct apply2

    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{
   




};

template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3

    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4

    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{
   




};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};

template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5

    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{
   




};



template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 37 "/usr/include/boost/mpl/apply.hpp" 2 3 4
# 20 "/usr/include/boost/mpl/aux_/iter_fold_impl.hpp" 2 3 4
# 33 "/usr/include/boost/mpl/aux_/iter_fold_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp" 3 4
namespace boost { namespace mpl { namespace aux {



template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl;

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 0,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef state0 state;
    typedef iter0 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 1,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;


    typedef state1 state;
    typedef iter1 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 2,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;


    typedef state2 state;
    typedef iter2 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 3,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;


    typedef state3 state;
    typedef iter3 iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< 4,First,Last,State,ForwardOp >
{
    typedef First iter0;
    typedef State state0;
    typedef typename apply2< ForwardOp,state0,iter0 >::type state1;
    typedef typename mpl::next<iter0>::type iter1;
    typedef typename apply2< ForwardOp,state1,iter1 >::type state2;
    typedef typename mpl::next<iter1>::type iter2;
    typedef typename apply2< ForwardOp,state2,iter2 >::type state3;
    typedef typename mpl::next<iter2>::type iter3;
    typedef typename apply2< ForwardOp,state3,iter3 >::type state4;
    typedef typename mpl::next<iter3>::type iter4;


    typedef state4 state;
    typedef iter4 iterator;
};

template<
      int N
    , typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl
{
    typedef iter_fold_impl<
          4
        , First
        , Last
        , State
        , ForwardOp
        > chunk_;

    typedef iter_fold_impl<
          ( (N - 4) < 0 ? 0 : N - 4 )
        , typename chunk_::iterator
        , Last
        , typename chunk_::state
        , ForwardOp
        > res_;

    typedef typename res_::state state;
    typedef typename res_::iterator iterator;
};

template<
      typename First
    , typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,First,Last,State,ForwardOp >
    : iter_fold_impl<
          -1
        , typename mpl::next<First>::type
        , Last
        , typename apply2< ForwardOp,State,First >::type
        , ForwardOp
        >
{
};

template<
      typename Last
    , typename State
    , typename ForwardOp
    >
struct iter_fold_impl< -1,Last,Last,State,ForwardOp >
{
    typedef State state;
    typedef Last iterator;
};

}}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 34 "/usr/include/boost/mpl/aux_/iter_fold_impl.hpp" 2 3 4
# 22 "/usr/include/boost/mpl/iter_fold.hpp" 2 3 4



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    >
struct iter_fold
{
    typedef typename aux::iter_fold_impl<
          ::boost::mpl::O1_size<Sequence>::value
        , typename begin<Sequence>::type
        , typename end<Sequence>::type
        , State
        , typename lambda<ForwardOp>::type
        >::state type;

   
};

template<> struct iter_fold< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : iter_fold< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< iter_fold< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold< na , na , na > result_; typedef iter_fold< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< iter_fold< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< iter_fold< na , na , na > > : int_<-1> { }; }

}}
# 19 "/usr/include/boost/mpl/distance.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/iterator_range.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/iterator_range.hpp" 3 4
namespace boost { namespace mpl {

struct iterator_range_tag;

template<
      typename First = na
    , typename Last = na
    >
struct iterator_range
{
    typedef iterator_range_tag tag;
    typedef iterator_range type;
    typedef First begin;
    typedef Last end;

   
};

template<> struct iterator_range< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : iterator_range< T1 , T2 > { }; }; template< typename Tag > struct lambda< iterator_range< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iterator_range< na , na > result_; typedef iterator_range< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< iterator_range< T1 , T2 > > : int_<2> { }; template<> struct template_arity< iterator_range< na , na > > : int_<-1> { }; }

}}
# 20 "/usr/include/boost/mpl/distance.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/tag.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/tag.hpp" 3 4
namespace boost { namespace mpl {

namespace aux {
template< typename T > struct tag_impl
{
    typedef typename T::tag type;
};
}

template< typename T, typename Default = void_ > struct tag

    : if_<
          aux::has_tag<T>
        , aux::tag_impl<T>
        , Default
        >::type
{
# 48 "/usr/include/boost/mpl/tag.hpp" 3 4
};

}}
# 23 "/usr/include/boost/mpl/distance.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/apply_wrap.hpp" 1 3 4
# 24 "/usr/include/boost/mpl/distance.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/msvc_eti_base.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/aux_/msvc_eti_base.hpp" 3 4
namespace boost { namespace mpl { namespace aux {
# 55 "/usr/include/boost/mpl/aux_/msvc_eti_base.hpp" 3 4
template< typename T > struct msvc_eti_base
    : T
{

    msvc_eti_base();

    typedef T type;
};



template<> struct msvc_eti_base<int>
{
    typedef msvc_eti_base type;
    typedef msvc_eti_base first;
    typedef msvc_eti_base second;
    typedef msvc_eti_base tag;
    enum { value = 0 };
};

}}}
# 25 "/usr/include/boost/mpl/distance.hpp" 2 3 4






namespace boost { namespace mpl {


template< typename Tag > struct distance_impl
{
    template< typename First, typename Last > struct apply

        : aux::msvc_eti_base< typename iter_fold<
              iterator_range<First,Last>
            , mpl::long_<0>
            , next<>
            >::type >
    {
# 60 "/usr/include/boost/mpl/distance.hpp" 3 4
    };
};

template<
      typename First = na
    , typename Last = na
    >
struct distance
    : distance_impl< typename tag<First>::type >
        ::template apply<First, Last>
{
   
};

template<> struct distance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : distance< T1 , T2 > { }; }; template< typename Tag > struct lambda< distance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef distance< na , na > result_; typedef distance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< distance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< distance< na , na > > : int_<-1> { }; }

}}
# 20 "/usr/include/boost/mpl/aux_/size_impl.hpp" 2 3 4



namespace boost { namespace mpl {




template< typename Tag >
struct size_impl
{
    template< typename Sequence > struct apply

        : distance<
              typename begin<Sequence>::type
            , typename end<Sequence>::type
            >
    {







    };
};

 template<> struct size_impl<non_sequence_tag> {};

}}
# 20 "/usr/include/boost/mpl/size.hpp" 2 3 4




namespace boost { namespace mpl {

template<
      typename Sequence = na
    >
struct size
    : aux::msvc_eti_base<
        typename size_impl< typename sequence_tag<Sequence>::type >
            ::template apply< Sequence >::type
      >::type
{
   
};

template<> struct size< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : size< T1 > { }; }; template< typename Tag > struct lambda< size< na > , Tag , int_<-1> > { typedef false_ is_le; typedef size< na > result_; typedef size< na > type; }; namespace aux { template< typename T1 > struct template_arity< size< T1 > > : int_<1> { }; template<> struct template_arity< size< na > > : int_<-1> { }; }

}}
# 31 "/usr/include/cocaine/traits.hpp" 2 3 4

# 1 "/usr/include/msgpack.hpp" 1 3 4
# 18 "/usr/include/msgpack.hpp" 3 4
# 1 "/usr/include/msgpack/object.hpp" 1 3 4
# 21 "/usr/include/msgpack/object.hpp" 3 4
# 1 "/usr/include/msgpack/object.h" 1 3 4
# 21 "/usr/include/msgpack/object.h" 3 4
# 1 "/usr/include/msgpack/zone.h" 1 3 4
# 21 "/usr/include/msgpack/zone.h" 3 4
# 1 "/usr/include/msgpack/sysdep.h" 1 3 4
# 32 "/usr/include/msgpack/sysdep.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 33 "/usr/include/msgpack/sysdep.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stdbool.h" 1 3 4
# 35 "/usr/include/msgpack/sysdep.h" 2 3 4
# 43 "/usr/include/msgpack/sysdep.h" 3 4
typedef unsigned int _msgpack_atomic_counter_t;
# 63 "/usr/include/msgpack/sysdep.h" 3 4
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 23 "/usr/include/arpa/inet.h" 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
# 25 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/sys/socket.h" 1 3 4
# 26 "/usr/include/sys/socket.h" 3 4
extern "C" {

# 1 "/usr/include/sys/uio.h" 1 3 4
# 26 "/usr/include/sys/uio.h" 3 4
extern "C" {


# 1 "/usr/include/bits/uio.h" 1 3 4
# 44 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 30 "/usr/include/sys/uio.h" 2 3 4
# 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, __const struct iovec *__iovec, int __count)
  ;
# 51 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, __const struct iovec *__iovec, int __count)
  ;
# 82 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, __const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "preadv64") ;


extern ssize_t pwritev (int __fd, __const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "pwritev64") ;
# 104 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, __const struct iovec *__iovec, int __count,
    __off64_t __offset) ;
# 116 "/usr/include/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, __const struct iovec *__iovec, int __count,
     __off64_t __offset) ;



}
# 29 "/usr/include/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 31 "/usr/include/sys/socket.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 34 "/usr/include/sys/socket.h" 2 3 4






# 1 "/usr/include/bits/socket.h" 1 3 4
# 29 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 30 "/usr/include/bits/socket.h" 2 3 4
# 40 "/usr/include/bits/socket.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 04000


};
# 171 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 29 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 172 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 187 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;



  };
# 293 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) throw ();
# 320 "/usr/include/bits/socket.h" 3 4
enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};
# 366 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 2 3 4
# 367 "/usr/include/bits/socket.h" 2 3 4
# 400 "/usr/include/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 41 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 105 "/usr/include/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) throw ();





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) throw ();


extern int bind (int __fd, __const struct sockaddr * __addr, socklen_t __len)
     throw ();


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();
# 129 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, __const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();






extern ssize_t send (int __fd, __const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, __const void *__buf, size_t __n,
         int __flags, __const struct sockaddr * __addr,
         socklen_t __addr_len);
# 166 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, __const struct msghdr *__message,
   int __flags);






extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);





extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) throw ();




extern int setsockopt (int __fd, int __level, int __optname,
         __const void *__optval, socklen_t __optlen) throw ();





extern int listen (int __fd, int __n) throw ();
# 214 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, struct sockaddr *__restrict __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 232 "/usr/include/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) throw ();




extern int sockatmark (int __fd) throw ();







extern int isfdtype (int __fd, int __fdtype) throw ();
# 254 "/usr/include/sys/socket.h" 3 4
}
# 26 "/usr/include/netinet/in.h" 2 3 4



extern "C" {


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_HOPOPTS = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MTP = 92,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
# 198 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 225 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };


struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 356 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/bits/in.h" 1 3 4
# 86 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 357 "/usr/include/netinet/in.h" 2 3 4
# 365 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) throw () __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     throw () __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     throw () __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     throw () __attribute__ ((__const__));




# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 377 "/usr/include/netinet/in.h" 2 3 4
# 440 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) throw ();


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     throw ();
# 471 "/usr/include/netinet/in.h" 3 4
struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) throw () __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    __const uint8_t *__typep, int __multx,
    int __plusy) throw () __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_next (__const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_find (__const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     throw () __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) throw ();
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) throw ();
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     throw ();
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();



extern socklen_t inet6_rth_space (int __type, int __segments) throw ();
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) throw ();
extern int inet6_rth_add (void *__bp, __const struct in6_addr *__addr) throw ();
extern int inet6_rth_reverse (__const void *__in, void *__out) throw ();
extern int inet6_rth_segments (__const void *__bp) throw ();
extern struct in6_addr *inet6_rth_getaddr (__const void *__bp, int __index)
     throw ();





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     throw ();


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    __const struct in_addr *__slist)
     throw ();



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       __const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) throw ();


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       __const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       __const struct sockaddr_storage *__slist) throw ();


}
# 24 "/usr/include/arpa/inet.h" 2 3 4







extern "C" {



extern in_addr_t inet_addr (__const char *__cp) throw ();


extern in_addr_t inet_lnaof (struct in_addr __in) throw ();



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     throw ();


extern in_addr_t inet_netof (struct in_addr __in) throw ();



extern in_addr_t inet_network (__const char *__cp) throw ();



extern char *inet_ntoa (struct in_addr __in) throw ();




extern int inet_pton (int __af, __const char *__restrict __cp,
        void *__restrict __buf) throw ();




extern __const char *inet_ntop (int __af, __const void *__restrict __cp,
    char *__restrict __buf, socklen_t __len)
     throw ();






extern int inet_aton (__const char *__cp, struct in_addr *__inp) throw ();



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) throw ();




extern char *inet_net_ntop (int __af, __const void *__cp, int __bits,
       char *__buf, size_t __len) throw ();




extern int inet_net_pton (int __af, __const char *__cp,
     void *__buf, size_t __len) throw ();




extern unsigned int inet_nsap_addr (__const char *__cp,
        unsigned char *__buf, int __len) throw ();



extern char *inet_nsap_ntoa (int __len, __const unsigned char *__cp,
        char *__buf) throw ();


}
# 64 "/usr/include/msgpack/sysdep.h" 2 3 4
# 22 "/usr/include/msgpack/zone.h" 2 3 4


extern "C" {
# 34 "/usr/include/msgpack/zone.h" 3 4
typedef struct msgpack_zone_finalizer {
 void (*func)(void* data);
 void* data;
} msgpack_zone_finalizer;

typedef struct msgpack_zone_finalizer_array {
 msgpack_zone_finalizer* tail;
 msgpack_zone_finalizer* end;
 msgpack_zone_finalizer* array;
} msgpack_zone_finalizer_array;

struct msgpack_zone_chunk;
typedef struct msgpack_zone_chunk msgpack_zone_chunk;

typedef struct msgpack_zone_chunk_list {
 size_t free;
 char* ptr;
 msgpack_zone_chunk* head;
} msgpack_zone_chunk_list;

typedef struct msgpack_zone {
 msgpack_zone_chunk_list chunk_list;
 msgpack_zone_finalizer_array finalizer_array;
 size_t chunk_size;
} msgpack_zone;





bool msgpack_zone_init(msgpack_zone* zone, size_t chunk_size);
void msgpack_zone_destroy(msgpack_zone* zone);

msgpack_zone* msgpack_zone_new(size_t chunk_size);
void msgpack_zone_free(msgpack_zone* zone);

static inline void* msgpack_zone_malloc(msgpack_zone* zone, size_t size);
static inline void* msgpack_zone_malloc_no_align(msgpack_zone* zone, size_t size);

static inline bool msgpack_zone_push_finalizer(msgpack_zone* zone,
  void (*func)(void* data), void* data);

bool msgpack_zone_is_empty(msgpack_zone* zone);

void msgpack_zone_clear(msgpack_zone* zone);
# 87 "/usr/include/msgpack/zone.h" 3 4
void* msgpack_zone_malloc_expand(msgpack_zone* zone, size_t size);

void* msgpack_zone_malloc_no_align(msgpack_zone* zone, size_t size)
{
 msgpack_zone_chunk_list* cl = &zone->chunk_list;

 if(zone->chunk_list.free < size) {
  return msgpack_zone_malloc_expand(zone, size);
 }

 char* ptr = cl->ptr;
 cl->free -= size;
 cl->ptr += size;

 return ptr;
}

void* msgpack_zone_malloc(msgpack_zone* zone, size_t size)
{
 return msgpack_zone_malloc_no_align(zone,
   ((size)+((sizeof(int))-1)) & ~((sizeof(int))-1));
}


bool msgpack_zone_push_finalizer_expand(msgpack_zone* zone,
  void (*func)(void* data), void* data);

bool msgpack_zone_push_finalizer(msgpack_zone* zone,
  void (*func)(void* data), void* data)
{
 msgpack_zone_finalizer_array* const fa = &zone->finalizer_array;
 msgpack_zone_finalizer* fin = fa->tail;

 if(fin == fa->end) {
  return msgpack_zone_push_finalizer_expand(zone, func, data);
 }

 fin->func = func;
 fin->data = data;

 ++fa->tail;

 return true;
}



}
# 22 "/usr/include/msgpack/object.h" 2 3 4



extern "C" {
# 35 "/usr/include/msgpack/object.h" 3 4
typedef enum {
 MSGPACK_OBJECT_NIL = 0x00,
 MSGPACK_OBJECT_BOOLEAN = 0x01,
 MSGPACK_OBJECT_POSITIVE_INTEGER = 0x02,
 MSGPACK_OBJECT_NEGATIVE_INTEGER = 0x03,
 MSGPACK_OBJECT_DOUBLE = 0x04,
 MSGPACK_OBJECT_RAW = 0x05,
 MSGPACK_OBJECT_ARRAY = 0x06,
 MSGPACK_OBJECT_MAP = 0x07,
} msgpack_object_type;


struct msgpack_object;
struct msgpack_object_kv;

typedef struct {
 uint32_t size;
 struct msgpack_object* ptr;
} msgpack_object_array;

typedef struct {
 uint32_t size;
 struct msgpack_object_kv* ptr;
} msgpack_object_map;

typedef struct {
 uint32_t size;
 const char* ptr;
} msgpack_object_raw;

typedef union {
 bool boolean;
 uint64_t u64;
 int64_t i64;
 double dec;
 msgpack_object_array array;
 msgpack_object_map map;
 msgpack_object_raw raw;
} msgpack_object_union;

typedef struct msgpack_object {
 msgpack_object_type type;
 msgpack_object_union via;
} msgpack_object;

typedef struct msgpack_object_kv {
 msgpack_object key;
 msgpack_object val;
} msgpack_object_kv;


void msgpack_object_print(FILE* out, msgpack_object o);

bool msgpack_object_equal(const msgpack_object x, const msgpack_object y);





}
# 22 "/usr/include/msgpack/object.hpp" 2 3 4
# 1 "/usr/include/msgpack/pack.hpp" 1 3 4
# 21 "/usr/include/msgpack/pack.hpp" 3 4
# 1 "/usr/include/msgpack/pack_define.h" 1 3 4
# 21 "/usr/include/msgpack/pack_define.h" 3 4
# 1 "/usr/include/msgpack/sysdep.h" 1 3 4
# 22 "/usr/include/msgpack/pack_define.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/limits.h" 1 3 4
# 11 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/limits.h" 1 3 4
# 122 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/limits.h" 2 3 4
# 23 "/usr/include/msgpack/pack_define.h" 2 3 4
# 22 "/usr/include/msgpack/pack.hpp" 2 3 4

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include-fixed/limits.h" 1 3 4
# 24 "/usr/include/msgpack/pack.hpp" 2 3 4

namespace msgpack {


template <typename Stream>
class packer {
public:
 packer(Stream* s);
 packer(Stream& s);
 ~packer();

public:
 template <typename T>
 packer<Stream>& pack(const T& v);

 packer<Stream>& pack_uint8(uint8_t d);
 packer<Stream>& pack_uint16(uint16_t d);
 packer<Stream>& pack_uint32(uint32_t d);
 packer<Stream>& pack_uint64(uint64_t d);
 packer<Stream>& pack_int8(int8_t d);
 packer<Stream>& pack_int16(int16_t d);
 packer<Stream>& pack_int32(int32_t d);
 packer<Stream>& pack_int64(int64_t d);

 packer<Stream>& pack_fix_uint8(uint8_t d);
 packer<Stream>& pack_fix_uint16(uint16_t d);
 packer<Stream>& pack_fix_uint32(uint32_t d);
 packer<Stream>& pack_fix_uint64(uint64_t d);
 packer<Stream>& pack_fix_int8(int8_t d);
 packer<Stream>& pack_fix_int16(int16_t d);
 packer<Stream>& pack_fix_int32(int32_t d);
 packer<Stream>& pack_fix_int64(int64_t d);

 packer<Stream>& pack_short(short d);
 packer<Stream>& pack_int(int d);
 packer<Stream>& pack_long(long d);
 packer<Stream>& pack_long_long(long long d);
 packer<Stream>& pack_unsigned_short(unsigned short d);
 packer<Stream>& pack_unsigned_int(unsigned int d);
 packer<Stream>& pack_unsigned_long(unsigned long d);
 packer<Stream>& pack_unsigned_long_long(unsigned long long d);

 packer<Stream>& pack_float(float d);
 packer<Stream>& pack_double(double d);

 packer<Stream>& pack_nil();
 packer<Stream>& pack_true();
 packer<Stream>& pack_false();

 packer<Stream>& pack_array(unsigned int n);

 packer<Stream>& pack_map(unsigned int n);

 packer<Stream>& pack_raw(size_t l);
 packer<Stream>& pack_raw_body(const char* b, size_t l);

private:
 static void _pack_uint8(Stream& x, uint8_t d);
 static void _pack_uint16(Stream& x, uint16_t d);
 static void _pack_uint32(Stream& x, uint32_t d);
 static void _pack_uint64(Stream& x, uint64_t d);
 static void _pack_int8(Stream& x, int8_t d);
 static void _pack_int16(Stream& x, int16_t d);
 static void _pack_int32(Stream& x, int32_t d);
 static void _pack_int64(Stream& x, int64_t d);

 static void _pack_fix_uint8(Stream& x, uint8_t d);
 static void _pack_fix_uint16(Stream& x, uint16_t d);
 static void _pack_fix_uint32(Stream& x, uint32_t d);
 static void _pack_fix_uint64(Stream& x, uint64_t d);
 static void _pack_fix_int8(Stream& x, int8_t d);
 static void _pack_fix_int16(Stream& x, int16_t d);
 static void _pack_fix_int32(Stream& x, int32_t d);
 static void _pack_fix_int64(Stream& x, int64_t d);

 static void _pack_short(Stream& x, short d);
 static void _pack_int(Stream& x, int d);
 static void _pack_long(Stream& x, long d);
 static void _pack_long_long(Stream& x, long long d);
 static void _pack_unsigned_short(Stream& x, unsigned short d);
 static void _pack_unsigned_int(Stream& x, unsigned int d);
 static void _pack_unsigned_long(Stream& x, unsigned long d);
 static void _pack_unsigned_long_long(Stream& x, unsigned long long d);

 static void _pack_float(Stream& x, float d);
 static void _pack_double(Stream& x, double d);

 static void _pack_nil(Stream& x);
 static void _pack_true(Stream& x);
 static void _pack_false(Stream& x);

 static void _pack_array(Stream& x, unsigned int n);

 static void _pack_map(Stream& x, unsigned int n);

 static void _pack_raw(Stream& x, size_t l);
 static void _pack_raw_body(Stream& x, const void* b, size_t l);

 static void append_buffer(Stream& x, const unsigned char* buf, unsigned int len)
  { x.write((const char*)buf, len); }

private:
 Stream& m_stream;

private:
 packer();
};


template <typename Stream, typename T>
inline void pack(Stream* s, const T& v)
{
 packer<Stream>(s).pack(v);
}

template <typename Stream, typename T>
inline void pack(Stream& s, const T& v)
{
 packer<Stream>(s).pack(v);
}
# 162 "/usr/include/msgpack/pack.hpp" 3 4
# 1 "/usr/include/msgpack/pack_template.h" 1 3 4
# 277 "/usr/include/msgpack/pack_template.h" 3 4
template <typename Stream> inline void packer<Stream>::_pack_fix_uint8(Stream& x, uint8_t d)
{
 unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]};
 append_buffer(x, buf, 2);
}

template <typename Stream> inline void packer<Stream>::_pack_fix_uint16(Stream& x, uint16_t d)
{
 unsigned char buf[3];
 buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);;
 append_buffer(x, buf, 3);
}

template <typename Stream> inline void packer<Stream>::_pack_fix_uint32(Stream& x, uint32_t d)
{
 unsigned char buf[5];
 buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);;
 append_buffer(x, buf, 5);
}

template <typename Stream> inline void packer<Stream>::_pack_fix_uint64(Stream& x, uint64_t d)
{
 unsigned char buf[9];
 buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);;
 append_buffer(x, buf, 9);
}

template <typename Stream> inline void packer<Stream>::_pack_fix_int8(Stream& x, int8_t d)
{
 unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]};
 append_buffer(x, buf, 2);
}

template <typename Stream> inline void packer<Stream>::_pack_fix_int16(Stream& x, int16_t d)
{
 unsigned char buf[3];
 buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);;
 append_buffer(x, buf, 3);
}

template <typename Stream> inline void packer<Stream>::_pack_fix_int32(Stream& x, int32_t d)
{
 unsigned char buf[5];
 buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);;
 append_buffer(x, buf, 5);
}

template <typename Stream> inline void packer<Stream>::_pack_fix_int64(Stream& x, int64_t d)
{
 unsigned char buf[9];
 buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);;
 append_buffer(x, buf, 9);
}





template <typename Stream> inline void packer<Stream>::_pack_uint8(Stream& x, uint8_t d)
{
 do { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } while(0);
}

template <typename Stream> inline void packer<Stream>::_pack_uint16(Stream& x, uint16_t d)
{
 do { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } } while(0);
}

template <typename Stream> inline void packer<Stream>::_pack_uint32(Stream& x, uint32_t d)
{
 do { if(d < (1<<8)) { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } } } while(0);
}

template <typename Stream> inline void packer<Stream>::_pack_uint64(Stream& x, uint64_t d)
{
 do { if(d < (1ULL<<8)) { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } } } while(0);
}

template <typename Stream> inline void packer<Stream>::_pack_int8(Stream& x, int8_t d)
{
 do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { append_buffer(x, &((uint8_t*)&d)[0], 1); } } while(0);
}

template <typename Stream> inline void packer<Stream>::_pack_int16(Stream& x, int16_t d)
{
 do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } } } while(0);
}

template <typename Stream> inline void packer<Stream>::_pack_int32(Stream& x, int32_t d)
{
 do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } } } while(0);
}

template <typename Stream> inline void packer<Stream>::_pack_int64(Stream& x, int64_t d)
{
 do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } } else if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } } } } while(0);
}




template <typename Stream> inline void packer<Stream>::_pack_short(Stream& x, short d)
{
# 391 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } } } while(0);
# 407 "/usr/include/msgpack/pack_template.h" 3 4
}

template <typename Stream> inline void packer<Stream>::_pack_int(Stream& x, int d)
{
# 424 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } } } while(0);
# 438 "/usr/include/msgpack/pack_template.h" 3 4
}

template <typename Stream> inline void packer<Stream>::_pack_long(Stream& x, long d)
{
# 457 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } } else if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } } } } while(0);
# 469 "/usr/include/msgpack/pack_template.h" 3 4
}

template <typename Stream> inline void packer<Stream>::_pack_long_long(Stream& x, long long d)
{
# 488 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } } else if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } } } } while(0);
# 500 "/usr/include/msgpack/pack_template.h" 3 4
}

template <typename Stream> inline void packer<Stream>::_pack_unsigned_short(Stream& x, unsigned short d)
{
# 515 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } } while(0);
# 531 "/usr/include/msgpack/pack_template.h" 3 4
}

template <typename Stream> inline void packer<Stream>::_pack_unsigned_int(Stream& x, unsigned int d)
{
# 548 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1<<8)) { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } } } while(0);
# 562 "/usr/include/msgpack/pack_template.h" 3 4
}

template <typename Stream> inline void packer<Stream>::_pack_unsigned_long(Stream& x, unsigned long d)
{
# 581 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1ULL<<8)) { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } } } while(0);
# 593 "/usr/include/msgpack/pack_template.h" 3 4
}

template <typename Stream> inline void packer<Stream>::_pack_unsigned_long_long(Stream& x, unsigned long long d)
{
# 612 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1ULL<<8)) { if(d < (1<<7)) { append_buffer(x, &((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; append_buffer(x, buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; append_buffer(x, buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; append_buffer(x, buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; append_buffer(x, buf, 9); } } } while(0);
# 624 "/usr/include/msgpack/pack_template.h" 3 4
}
# 635 "/usr/include/msgpack/pack_template.h" 3 4
template <typename Stream> inline void packer<Stream>::_pack_float(Stream& x, float d)
{
 union { float f; uint32_t i; } mem;
 mem.f = d;
 unsigned char buf[5];
 buf[0] = 0xca; do { uint32_t val = ntohl(mem.i); memcpy(&buf[1], &val, 4); } while(0);;
 append_buffer(x, buf, 5);
}

template <typename Stream> inline void packer<Stream>::_pack_double(Stream& x, double d)
{
 union { double f; uint64_t i; } mem;
 mem.f = d;
 unsigned char buf[9];
 buf[0] = 0xcb; do { uint64_t val = ( ((((uint64_t)mem.i) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)mem.i) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)mem.i) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)mem.i) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)mem.i) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)mem.i) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)mem.i) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)mem.i) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);;
 append_buffer(x, buf, 9);
}






template <typename Stream> inline void packer<Stream>::_pack_nil(Stream& x)
{
 static const unsigned char d = 0xc0;
 append_buffer(x, &d, 1);
}






template <typename Stream> inline void packer<Stream>::_pack_true(Stream& x)
{
 static const unsigned char d = 0xc3;
 append_buffer(x, &d, 1);
}

template <typename Stream> inline void packer<Stream>::_pack_false(Stream& x)
{
 static const unsigned char d = 0xc2;
 append_buffer(x, &d, 1);
}






template <typename Stream> inline void packer<Stream>::_pack_array(Stream& x, unsigned int n)
{
 if(n < 16) {
  unsigned char d = 0x90 | n;
  append_buffer(x, &d, 1);
 } else if(n < 65536) {
  unsigned char buf[3];
  buf[0] = 0xdc; do { uint16_t val = ntohs(n); memcpy(&buf[1], &val, 2); } while(0);;
  append_buffer(x, buf, 3);
 } else {
  unsigned char buf[5];
  buf[0] = 0xdd; do { uint32_t val = ntohl(n); memcpy(&buf[1], &val, 4); } while(0);;
  append_buffer(x, buf, 5);
 }
}






template <typename Stream> inline void packer<Stream>::_pack_map(Stream& x, unsigned int n)
{
 if(n < 16) {
  unsigned char d = 0x80 | n;
  append_buffer(x, &((uint8_t*)&d)[0], 1);
 } else if(n < 65536) {
  unsigned char buf[3];
  buf[0] = 0xde; do { uint16_t val = ntohs(n); memcpy(&buf[1], &val, 2); } while(0);;
  append_buffer(x, buf, 3);
 } else {
  unsigned char buf[5];
  buf[0] = 0xdf; do { uint32_t val = ntohl(n); memcpy(&buf[1], &val, 4); } while(0);;
  append_buffer(x, buf, 5);
 }
}






template <typename Stream> inline void packer<Stream>::_pack_raw(Stream& x, size_t l)
{
 if(l < 32) {
  unsigned char d = 0xa0 | l;
  append_buffer(x, &((uint8_t*)&d)[0], 1);
 } else if(l < 65536) {
  unsigned char buf[3];
  buf[0] = 0xda; do { uint16_t val = ntohs(l); memcpy(&buf[1], &val, 2); } while(0);;
  append_buffer(x, buf, 3);
 } else {
  unsigned char buf[5];
  buf[0] = 0xdb; do { uint32_t val = ntohl(l); memcpy(&buf[1], &val, 4); } while(0);;
  append_buffer(x, buf, 5);
 }
}

template <typename Stream> inline void packer<Stream>::_pack_raw_body(Stream& x, const void* b, size_t l)
{
 append_buffer(x, (const unsigned char*)b, l);
}
# 163 "/usr/include/msgpack/pack.hpp" 2 3 4


template <typename Stream>
packer<Stream>::packer(Stream* s) : m_stream(*s) { }

template <typename Stream>
packer<Stream>::packer(Stream& s) : m_stream(s) { }

template <typename Stream>
packer<Stream>::~packer() { }


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_uint8(uint8_t d)
{ _pack_uint8(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_uint16(uint16_t d)
{ _pack_uint16(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_uint32(uint32_t d)
{ _pack_uint32(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_uint64(uint64_t d)
{ _pack_uint64(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_int8(int8_t d)
{ _pack_int8(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_int16(int16_t d)
{ _pack_int16(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_int32(int32_t d)
{ _pack_int32(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_int64(int64_t d)
{ _pack_int64(m_stream, d); return *this;}


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_uint8(uint8_t d)
{ _pack_fix_uint8(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_uint16(uint16_t d)
{ _pack_fix_uint16(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_uint32(uint32_t d)
{ _pack_fix_uint32(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_uint64(uint64_t d)
{ _pack_fix_uint64(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_int8(int8_t d)
{ _pack_fix_int8(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_int16(int16_t d)
{ _pack_fix_int16(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_int32(int32_t d)
{ _pack_fix_int32(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_fix_int64(int64_t d)
{ _pack_fix_int64(m_stream, d); return *this;}


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_short(short d)
{ _pack_short(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_int(int d)
{ _pack_int(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_long(long d)
{ _pack_long(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_long_long(long long d)
{ _pack_long_long(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_unsigned_short(unsigned short d)
{ _pack_unsigned_short(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_unsigned_int(unsigned int d)
{ _pack_unsigned_int(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_unsigned_long(unsigned long d)
{ _pack_unsigned_long(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_unsigned_long_long(unsigned long long d)
{ _pack_unsigned_long_long(m_stream, d); return *this; }


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_float(float d)
{ _pack_float(m_stream, d); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_double(double d)
{ _pack_double(m_stream, d); return *this; }


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_nil()
{ _pack_nil(m_stream); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_true()
{ _pack_true(m_stream); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_false()
{ _pack_false(m_stream); return *this; }


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_array(unsigned int n)
{ _pack_array(m_stream, n); return *this; }


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_map(unsigned int n)
{ _pack_map(m_stream, n); return *this; }


template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_raw(size_t l)
{ _pack_raw(m_stream, l); return *this; }

template <typename Stream>
inline packer<Stream>& packer<Stream>::pack_raw_body(const char* b, size_t l)
{ _pack_raw_body(m_stream, b, l); return *this; }


}
# 23 "/usr/include/msgpack/object.hpp" 2 3 4
# 1 "/usr/include/msgpack/zone.hpp" 1 3 4
# 22 "/usr/include/msgpack/zone.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstdlib" 1 3 4
# 41 "/usr/include/c++/4.4/cstdlib" 3 4
       
# 42 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstdlib" 2 3
# 23 "/usr/include/msgpack/zone.hpp" 2 3 4




namespace msgpack {


class zone : public msgpack_zone {
public:
 zone(size_t chunk_size = 8192);
 ~zone();

public:
 void* malloc(size_t size);
 void* malloc_no_align(size_t size);

 void push_finalizer(void (*func)(void*), void* data);

 template <typename T>
 void push_finalizer(std::auto_ptr<T> obj);

 void clear();


 template <typename T>
 T* allocate();

 template <typename T, typename A1>
 T* allocate(A1 a1);

 template <typename T, typename A1, typename A2>
 T* allocate(A1 a1, A2 a2);

 template <typename T, typename A1, typename A2, typename A3>
 T* allocate(A1 a1, A2 a2, A3 a3);

 template <typename T, typename A1, typename A2, typename A3, typename A4>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14);

 template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
 T* allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15);


private:
 void undo_malloc(size_t size);

 template <typename T>
 static void object_destructor(void* obj);

 typedef msgpack_zone base;

private:
 zone(const zone&);
};



inline zone::zone(size_t chunk_size)
{
 msgpack_zone_init(this, chunk_size);
}

inline zone::~zone()
{
 msgpack_zone_destroy(this);
}

inline void* zone::malloc(size_t size)
{
 void* ptr = msgpack_zone_malloc(this, size);
 if(!ptr) {
  throw std::bad_alloc();
 }
 return ptr;
}

inline void* zone::malloc_no_align(size_t size)
{
 void* ptr = msgpack_zone_malloc_no_align(this, size);
 if(!ptr) {
  throw std::bad_alloc();
 }
 return ptr;
}

inline void zone::push_finalizer(void (*func)(void*), void* data)
{
 if(!msgpack_zone_push_finalizer(this, func, data)) {
  throw std::bad_alloc();
 }
}

template <typename T>
inline void zone::push_finalizer(std::auto_ptr<T> obj)
{
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, obj.get())) {
  throw std::bad_alloc();
 }
 obj.release();
}

inline void zone::clear()
{
 msgpack_zone_clear(this);
}

template <typename T>
void zone::object_destructor(void* obj)
{
 reinterpret_cast<T*>(obj)->~T();
}

inline void zone::undo_malloc(size_t size)
{
 base::chunk_list.ptr -= size;
 base::chunk_list.free += size;
}


template <typename T>
T* zone::allocate()
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T();
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1>
T* zone::allocate(A1 a1)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2>
T* zone::allocate(A1 a1, A2 a2)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3>
T* zone::allocate(A1 a1, A2 a2, A3 a3)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8, a9);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}

template <typename T, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
T* zone::allocate(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15)
{
 void* x = malloc(sizeof(T));
 if(!msgpack_zone_push_finalizer(this, &zone::object_destructor<T>, x)) {
  undo_malloc(sizeof(T));
  throw std::bad_alloc();
 }
 try {
  return new (x) T(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
 } catch (...) {
  --base::finalizer_array.tail;
  undo_malloc(sizeof(T));
  throw;
 }
}


}
# 24 "/usr/include/msgpack/object.hpp" 2 3 4






namespace msgpack {


class type_error : public std::bad_cast { };


namespace type {
 enum object_type {
  NIL = MSGPACK_OBJECT_NIL,
  BOOLEAN = MSGPACK_OBJECT_BOOLEAN,
  POSITIVE_INTEGER = MSGPACK_OBJECT_POSITIVE_INTEGER,
  NEGATIVE_INTEGER = MSGPACK_OBJECT_NEGATIVE_INTEGER,
  DOUBLE = MSGPACK_OBJECT_DOUBLE,
  RAW = MSGPACK_OBJECT_RAW,
  ARRAY = MSGPACK_OBJECT_ARRAY,
  MAP = MSGPACK_OBJECT_MAP,
 };
}


struct object;
struct object_kv;

struct object_array {
 uint32_t size;
 object* ptr;
};

struct object_map {
 uint32_t size;
 object_kv* ptr;
};

struct object_raw {
 uint32_t size;
 const char* ptr;
};

struct object {
 union union_type {
  bool boolean;
  uint64_t u64;
  int64_t i64;
  double dec;
  object_array array;
  object_map map;
  object_raw raw;
  object_raw ref;
 };

 type::object_type type;
 union_type via;

 bool is_nil() const { return type == type::NIL; }

 template <typename T>
 T as() const;

 template <typename T>
 void convert(T* v) const;

 object();

 object(msgpack_object o);

 template <typename T>
 explicit object(const T& v);

 template <typename T>
 object(const T& v, zone* z);

 template <typename T>
 object& operator=(const T& v);

 operator msgpack_object() const;

 struct with_zone;

private:
 struct implicit_type;

public:
 implicit_type convert() const;
};

struct object_kv {
 object key;
 object val;
};

struct object::with_zone : object {
 with_zone(msgpack::zone* zone) : zone(zone) { }
 msgpack::zone* zone;
private:
 with_zone();
};


bool operator==(const object x, const object y);
bool operator!=(const object x, const object y);

template <typename T>
bool operator==(const object x, const T& y);

template <typename T>
bool operator==(const T& y, const object x);

template <typename T>
bool operator!=(const object x, const T& y);

template <typename T>
bool operator!=(const T& y, const object x);

std::ostream& operator<< (std::ostream& s, const object o);



template <typename Stream, typename T>
packer<Stream>& operator<< (packer<Stream>& o, const T& v);


template <typename T>
T& operator>> (object o, T& v);


template <typename T>
void operator<< (object::with_zone& o, const T& v);


struct object::implicit_type {
 implicit_type(object o) : obj(o) { }
 ~implicit_type() { }

 template <typename T>
 operator T() { return obj.as<T>(); }

private:
 object obj;
};



template <typename Type>
class define : public Type {
public:
 typedef Type msgpack_type;
 typedef define<Type> define_type;

 define() {}
 define(const msgpack_type& v) : msgpack_type(v) {}

 template <typename Packer>
 void msgpack_pack(Packer& o) const
 {
  o << static_cast<const msgpack_type&>(*this);
 }

 void msgpack_unpack(object o)
 {
  o >> static_cast<msgpack_type&>(*this);
 }
};


template <typename Stream>
template <typename T>
inline packer<Stream>& packer<Stream>::pack(const T& v)
{
 *this << v;
 return *this;
}

inline object& operator>> (object o, object& v)
{
 v = o;
 return v;
}

template <typename T>
inline T& operator>> (object o, T& v)
{
 v.msgpack_unpack(o.convert());
 return v;
}

template <typename Stream, typename T>
inline packer<Stream>& operator<< (packer<Stream>& o, const T& v)
{
 v.msgpack_pack(o);
 return o;
}

template <typename T>
void operator<< (object::with_zone& o, const T& v)
{
 v.msgpack_object(static_cast<object*>(&o), o.zone);
}


inline bool operator==(const object x, const object y)
{
 return msgpack_object_equal(x, y);
}

template <typename T>
inline bool operator==(const object x, const T& y)
try {
 return x == object(y);
} catch (msgpack::type_error&) {
 return false;
}

inline bool operator!=(const object x, const object y)
{ return !(x == y); }

template <typename T>
inline bool operator==(const T& y, const object x)
{ return x == y; }

template <typename T>
inline bool operator!=(const object x, const T& y)
{ return !(x == y); }

template <typename T>
inline bool operator!=(const T& y, const object x)
{ return x != y; }


inline object::implicit_type object::convert() const
{
 return implicit_type(*this);
}

template <typename T>
inline void object::convert(T* v) const
{
 *this >> *v;
}

template <typename T>
inline T object::as() const
{
 T v;
 convert(&v);
 return v;
}


inline object::object()
{
 type = type::NIL;
}

template <typename T>
inline object::object(const T& v)
{
 *this << v;
}

template <typename T>
inline object& object::operator=(const T& v)
{
 *this = object(v);
 return *this;
}

template <typename T>
object::object(const T& v, zone* z)
{
 with_zone oz(z);
 oz << v;
 type = oz.type;
 via = oz.via;
}


inline object::object(msgpack_object o)
{

 ::memcpy(this, &o, sizeof(o));
}

inline void operator<< (object& o, msgpack_object v)
{

 ::memcpy(&o, &v, sizeof(v));
}

inline object::operator msgpack_object() const
{

 msgpack_object obj;
 ::memcpy(&obj, this, sizeof(obj));
 return obj;
}



template <typename T>
inline void convert(T& v, object o)
{
 o.convert(&v);
}


template <typename Stream, typename T>
inline void pack(packer<Stream>& o, const T& v)
{
 o.pack(v);
}


template <typename Stream, typename T>
inline void pack_copy(packer<Stream>& o, T v)
{
 pack(o, v);
}


template <typename Stream>
packer<Stream>& operator<< (packer<Stream>& o, const object& v)
{
 switch(v.type) {
 case type::NIL:
  o.pack_nil();
  return o;

 case type::BOOLEAN:
  if(v.via.boolean) {
   o.pack_true();
  } else {
   o.pack_false();
  }
  return o;

 case type::POSITIVE_INTEGER:
  o.pack_uint64(v.via.u64);
  return o;

 case type::NEGATIVE_INTEGER:
  o.pack_int64(v.via.i64);
  return o;

 case type::DOUBLE:
  o.pack_double(v.via.dec);
  return o;

 case type::RAW:
  o.pack_raw(v.via.raw.size);
  o.pack_raw_body(v.via.raw.ptr, v.via.raw.size);
  return o;

 case type::ARRAY:
  o.pack_array(v.via.array.size);
  for(object* p(v.via.array.ptr),
    * const pend(v.via.array.ptr + v.via.array.size);
    p < pend; ++p) {
   o << *p;
  }
  return o;

 case type::MAP:
  o.pack_map(v.via.map.size);
  for(object_kv* p(v.via.map.ptr),
    * const pend(v.via.map.ptr + v.via.map.size);
    p < pend; ++p) {
   o << p->key;
   o << p->val;
  }
  return o;

 default:
  throw type_error();
 }
}


}

# 1 "/usr/include/msgpack/type.hpp" 1 3 4
# 1 "/usr/include/msgpack/type/bool.hpp" 1 3 4
# 21 "/usr/include/msgpack/type/bool.hpp" 3 4
# 1 "/usr/include/msgpack/object.hpp" 1 3 4
# 22 "/usr/include/msgpack/type/bool.hpp" 2 3 4


namespace msgpack {


inline bool& operator>> (object o, bool& v)
{
 if(o.type != type::BOOLEAN) { throw type_error(); }
 v = o.via.boolean;
 return v;
}

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const bool& v)
{
 if(v) { o.pack_true(); }
 else { o.pack_false(); }
 return o;
}

inline void operator<< (object& o, bool v)
{
 o.type = type::BOOLEAN;
 o.via.boolean = v;
}

inline void operator<< (object::with_zone& o, bool v)
 { static_cast<object&>(o) << v; }


}
# 2 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/deque.hpp" 1 3 4
# 22 "/usr/include/msgpack/type/deque.hpp" 3 4
# 1 "/usr/include/c++/4.4/deque" 1 3 4
# 59 "/usr/include/c++/4.4/deque" 3 4
       
# 60 "/usr/include/c++/4.4/deque" 3





# 1 "/usr/include/c++/4.4/bits/stl_deque.h" 1 3
# 65 "/usr/include/c++/4.4/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 77 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
# 93 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator()
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value);
# 360 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }


      _Deque_base(_Deque_base&& __x)
      : _M_impl(__x._M_get_Tp_allocator())
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   {
     std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
     std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
     std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
     std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
   }
      }


      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 490 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 637 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:





      deque()
      : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 709 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 722 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 736 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque(deque&& __x)
      : _Base(std::forward<_Base>(__x)) { }
# 750 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
 : _Base(__a)
        {
   _M_range_initialize(__l.begin(), __l.end(),
         random_access_iterator_tag());
 }
# 774 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 799 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 810 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque&
      operator=(deque&& __x)
      {

 this->clear();
 this->swap(__x);
 return *this;
      }
# 830 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 848 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 864 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 884 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }






      const_iterator
      cbegin() const
      { return this->_M_impl._M_start; }






      const_iterator
      cend() const
      { return this->_M_impl._M_finish; }






      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }




      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 1024 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }





      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1054 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 1069 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 1094 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1112 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1169 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }


      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args);
# 1200 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 1231 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1252 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1275 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
# 1289 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1302 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1315 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      insert(iterator __p, initializer_list<value_type> __l)
      { this->insert(__p, __l.begin(), __l.end()); }
# 1329 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1343 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1366 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1385 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1397 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void

      swap(deque&& __x)



      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1463 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1485 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);
# 1495 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
# 1559 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename... _Args>
        void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
        void _M_push_front_aux(_Args&&... __args);


      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1578 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
        iterator
        _M_insert_aux(iterator __pos, _Args&&... __args);



      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }



      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1714 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1746 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1764 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>&& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>&& __y)
    { __x.swap(__y); }


}
# 66 "/usr/include/c++/4.4/deque" 2 3


# 1 "/usr/include/c++/4.4/bits/deque.tcc" 1 3
# 60 "/usr/include/c++/4.4/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1,
        std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
        std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     push_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     push_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position, std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)





      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {

     this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
        std::forward<_Args>(__args)...);



     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)





      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;

     this->_M_impl.construct(this->_M_impl._M_start._M_cur,
        std::forward<_Args>(__args)...);



   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);







 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

}
# 69 "/usr/include/c++/4.4/deque" 2 3
# 23 "/usr/include/msgpack/type/deque.hpp" 2 3 4

namespace msgpack {


template <typename T>
inline std::deque<T>& operator>> (object o, std::deque<T>& v)
{
 if(o.type != type::ARRAY) { throw type_error(); }
 v.resize(o.via.array.size);
 object* p = o.via.array.ptr;
 object* const pend = o.via.array.ptr + o.via.array.size;
 typename std::deque<T>::iterator it = v.begin();
 for(; p < pend; ++p, ++it) {
  p->convert(&*it);
 }
 return v;
}

template <typename Stream, typename T>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::deque<T>& v)
{
 o.pack_array(v.size());
 for(typename std::deque<T>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(*it);
 }
 return o;
}

template <typename T>
inline void operator<< (object::with_zone& o, const std::deque<T>& v)
{
 o.type = type::ARRAY;
 if(v.empty()) {
  o.via.array.ptr = __null;
  o.via.array.size = 0;
 } else {
  object* p = (object*)o.zone->malloc(sizeof(object)*v.size());
  object* const pend = p + v.size();
  o.via.array.ptr = p;
  o.via.array.size = v.size();
  typename std::deque<T>::const_iterator it(v.begin());
  do {
   *p = object(*it, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


}
# 3 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/fixint.hpp" 1 3 4
# 22 "/usr/include/msgpack/type/fixint.hpp" 3 4
# 1 "/usr/include/msgpack/type/int.hpp" 1 3 4
# 24 "/usr/include/msgpack/type/int.hpp" 3 4
namespace msgpack {


namespace type {
namespace detail {
 template <typename T, bool Signed>
 struct convert_integer_sign;

 template <typename T>
 struct convert_integer_sign<T, true> {
  static inline T convert(object o) {
   if(o.type == type::POSITIVE_INTEGER) {
    if(o.via.u64 > (uint64_t)std::numeric_limits<T>::max())
     { throw type_error(); }
    return o.via.u64;
   } else if(o.type == type::NEGATIVE_INTEGER) {
    if(o.via.i64 < (int64_t)std::numeric_limits<T>::min())
     { throw type_error(); }
    return o.via.i64;
   }
   throw type_error();
  }
 };

 template <typename T>
 struct convert_integer_sign<T, false> {
  static inline T convert(object o) {
   if(o.type == type::POSITIVE_INTEGER) {
    if(o.via.u64 > (uint64_t)std::numeric_limits<T>::max())
     { throw type_error(); }
    return o.via.u64;
   }
   throw type_error();
  }
 };

 template <typename T>
 static inline T convert_integer(object o)
 {
  return detail::convert_integer_sign<T, std::numeric_limits<T>::is_signed>::convert(o);
 }

}
}


inline signed char& operator>> (object o, signed char& v)
 { v = type::detail::convert_integer<signed char>(o); return v; }

inline signed short& operator>> (object o, signed short& v)
 { v = type::detail::convert_integer<signed short>(o); return v; }

inline signed int& operator>> (object o, signed int& v)
 { v = type::detail::convert_integer<signed int>(o); return v; }

inline signed long& operator>> (object o, signed long& v)
 { v = type::detail::convert_integer<signed long>(o); return v; }

inline signed long long& operator>> (object o, signed long long& v)
 { v = type::detail::convert_integer<signed long long>(o); return v; }


inline unsigned char& operator>> (object o, unsigned char& v)
 { v = type::detail::convert_integer<unsigned char>(o); return v; }

inline unsigned short& operator>> (object o, unsigned short& v)
 { v = type::detail::convert_integer<unsigned short>(o); return v; }

inline unsigned int& operator>> (object o, unsigned int& v)
 { v = type::detail::convert_integer<unsigned int>(o); return v; }

inline unsigned long& operator>> (object o, unsigned long& v)
 { v = type::detail::convert_integer<unsigned long>(o); return v; }

inline unsigned long long& operator>> (object o, unsigned long long& v)
 { v = type::detail::convert_integer<unsigned long long>(o); return v; }


template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const signed char& v)
 { o.pack_int8(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const signed short& v)
 { o.pack_short(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const signed int& v)
 { o.pack_int(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const signed long& v)
 { o.pack_long(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const signed long long& v)
 { o.pack_long_long(v); return o; }


template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const unsigned char& v)
 { o.pack_uint8(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const unsigned short& v)
 { o.pack_unsigned_short(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const unsigned int& v)
 { o.pack_unsigned_int(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const unsigned long& v)
 { o.pack_unsigned_long(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const unsigned long long& v)
 { o.pack_unsigned_long_long(v); return o; }


inline void operator<< (object& o, signed char v)
 { v < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v : o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, signed short v)
 { v < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v : o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, signed int v)
 { v < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v : o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, signed long v)
 { v < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v : o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, signed long long v)
 { v < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v : o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }


inline void operator<< (object& o, unsigned char v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, unsigned short v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, unsigned int v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, unsigned long v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }

inline void operator<< (object& o, unsigned long long v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v; }


inline void operator<< (object::with_zone& o, signed char v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, signed short v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, signed int v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, signed long v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, signed long long v)
 { static_cast<object&>(o) << v; }


inline void operator<< (object::with_zone& o, unsigned char v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, unsigned short v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, unsigned int v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, unsigned long v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, unsigned long long v)
 { static_cast<object&>(o) << v; }


}
# 23 "/usr/include/msgpack/type/fixint.hpp" 2 3 4

namespace msgpack {

namespace type {


template <typename T>
struct fix_int {
 fix_int() : value(0) { }
 fix_int(T value) : value(value) { }

 operator T() const { return value; }

 T get() const { return value; }

private:
 T value;
};


typedef fix_int<uint8_t> fix_uint8;
typedef fix_int<uint16_t> fix_uint16;
typedef fix_int<uint32_t> fix_uint32;
typedef fix_int<uint64_t> fix_uint64;

typedef fix_int<int8_t> fix_int8;
typedef fix_int<int16_t> fix_int16;
typedef fix_int<int32_t> fix_int32;
typedef fix_int<int64_t> fix_int64;


}


inline type::fix_int8& operator>> (object o, type::fix_int8& v)
 { v = type::detail::convert_integer<int8_t>(o); return v; }

inline type::fix_int16& operator>> (object o, type::fix_int16& v)
 { v = type::detail::convert_integer<int16_t>(o); return v; }

inline type::fix_int32& operator>> (object o, type::fix_int32& v)
 { v = type::detail::convert_integer<int32_t>(o); return v; }

inline type::fix_int64& operator>> (object o, type::fix_int64& v)
 { v = type::detail::convert_integer<int64_t>(o); return v; }


inline type::fix_uint8& operator>> (object o, type::fix_uint8& v)
 { v = type::detail::convert_integer<uint8_t>(o); return v; }

inline type::fix_uint16& operator>> (object o, type::fix_uint16& v)
 { v = type::detail::convert_integer<uint16_t>(o); return v; }

inline type::fix_uint32& operator>> (object o, type::fix_uint32& v)
 { v = type::detail::convert_integer<uint32_t>(o); return v; }

inline type::fix_uint64& operator>> (object o, type::fix_uint64& v)
 { v = type::detail::convert_integer<uint64_t>(o); return v; }


template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_int8& v)
 { o.pack_fix_int8(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_int16& v)
 { o.pack_fix_int16(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_int32& v)
 { o.pack_fix_int32(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_int64& v)
 { o.pack_fix_int64(v); return o; }


template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_uint8& v)
 { o.pack_fix_uint8(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_uint16& v)
 { o.pack_fix_uint16(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_uint32& v)
 { o.pack_fix_uint32(v); return o; }

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::fix_uint64& v)
 { o.pack_fix_uint64(v); return o; }


inline void operator<< (object& o, type::fix_int8 v)
 { v.get() < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v.get() : o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }

inline void operator<< (object& o, type::fix_int16 v)
 { v.get() < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v.get() : o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }

inline void operator<< (object& o, type::fix_int32 v)
 { v.get() < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v.get() : o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }

inline void operator<< (object& o, type::fix_int64 v)
 { v.get() < 0 ? o.type = type::NEGATIVE_INTEGER, o.via.i64 = v.get() : o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }


inline void operator<< (object& o, type::fix_uint8 v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }

inline void operator<< (object& o, type::fix_uint16 v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }

inline void operator<< (object& o, type::fix_uint32 v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }

inline void operator<< (object& o, type::fix_uint64 v)
 { o.type = type::POSITIVE_INTEGER, o.via.u64 = v.get(); }


inline void operator<< (object::with_zone& o, type::fix_int8 v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, type::fix_int16 v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, type::fix_int32 v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, type::fix_int64 v)
 { static_cast<object&>(o) << v; }


inline void operator<< (object::with_zone& o, type::fix_uint8 v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, type::fix_uint16 v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, type::fix_uint32 v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, type::fix_uint64 v)
 { static_cast<object&>(o) << v; }


}
# 4 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/float.hpp" 1 3 4
# 24 "/usr/include/msgpack/type/float.hpp" 3 4
namespace msgpack {





inline float& operator>> (object o, float& v)
{
 if(o.type != type::DOUBLE) { throw type_error(); }
 v = o.via.dec;
 return v;
}

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const float& v)
{
 o.pack_float(v);
 return o;
}


inline double& operator>> (object o, double& v)
{
 if(o.type != type::DOUBLE) { throw type_error(); }
 v = o.via.dec;
 return v;
}

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const double& v)
{
 o.pack_double(v);
 return o;
}


inline void operator<< (object& o, float v)
{
 o.type = type::DOUBLE;
 o.via.dec = v;
}

inline void operator<< (object& o, double v)
{
 o.type = type::DOUBLE;
 o.via.dec = v;
}

inline void operator<< (object::with_zone& o, float v)
 { static_cast<object&>(o) << v; }

inline void operator<< (object::with_zone& o, double v)
 { static_cast<object&>(o) << v; }


}
# 5 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/int.hpp" 1 3 4
# 6 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/list.hpp" 1 3 4
# 22 "/usr/include/msgpack/type/list.hpp" 3 4
# 1 "/usr/include/c++/4.4/list" 1 3 4
# 59 "/usr/include/c++/4.4/list" 3 4
       
# 60 "/usr/include/c++/4.4/list" 3



# 1 "/usr/include/c++/4.4/bits/stl_list.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_list.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;

    static void
    swap(_List_node_base& __x, _List_node_base& __y);

    void
    transfer(_List_node_base * const __first,
      _List_node_base * const __last);

    void
    reverse();

    void
    hook(_List_node_base * const __position);

    void
    unhook();
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
    {

      _Tp _M_data;


      template<typename... _Args>
        _List_node(_Args&&... __args)
 : _List_node_base(), _M_data(std::forward<_Args>(__args)...) { }

    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator()
      : _M_node() { }

      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }


      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      _List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator()
      : _M_node() { }

      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }



      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }

      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }


      const _List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 293 "/usr/include/c++/4.4/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }


      _List_base(_List_base&& __x)
      : _M_impl(__x._M_get_Node_allocator())
      {
 _M_init();
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);
      }



      ~_List_base()
      { _M_clear(); }

      void
      _M_clear();

      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 416 "/usr/include/c++/4.4/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
# 474 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename... _Args>
        _Node*
        _M_create_node(_Args&&... __args)
 {
   _Node* __p = this->_M_get_node();
   try
     {
       _M_get_Node_allocator().construct(__p,
      std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__p);
       throw;
     }
   return __p;
 }


    public:





      list()
      : _Base() { }





      explicit
      list(const allocator_type& __a)
      : _Base(__a) { }
# 518 "/usr/include/c++/4.4/bits/stl_list.h" 3
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
# 531 "/usr/include/c++/4.4/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 543 "/usr/include/c++/4.4/bits/stl_list.h" 3
      list(list&& __x)
      : _Base(std::forward<_Base>(__x)) { }
# 554 "/usr/include/c++/4.4/bits/stl_list.h" 3
      list(initializer_list<value_type> __l,
           const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }
# 570 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
# 595 "/usr/include/c++/4.4/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 606 "/usr/include/c++/4.4/bits/stl_list.h" 3
      list&
      operator=(list&& __x)
      {

 this->clear();
 this->swap(__x);
 return *this;
      }
# 622 "/usr/include/c++/4.4/bits/stl_list.h" 3
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 640 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 656 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 673 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      cend() const
      { return const_iterator(&this->_M_impl._M_node); }






      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(begin()); }







      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const
      { return std::distance(begin(), end()); }


      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }
# 822 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type());






      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 877 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }


      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args)
        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
# 904 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      pop_front()
      { this->_M_erase(begin()); }
# 918 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }


      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args)
        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
# 944 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 961 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
# 977 "/usr/include/c++/4.4/bits/stl_list.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 992 "/usr/include/c++/4.4/bits/stl_list.h" 3
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1009 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      insert(iterator __p, initializer_list<value_type> __l)
      { this->insert(__p, __l.begin(), __l.end()); }
# 1026 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
# 1046 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
# 1070 "/usr/include/c++/4.4/bits/stl_list.h" 3
      iterator
      erase(iterator __position);
# 1091 "/usr/include/c++/4.4/bits/stl_list.h" 3
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
# 1108 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void

      swap(list&& __x)



      {
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1148 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void

      splice(iterator __position, list&& __x)



      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
# 1172 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void

      splice(iterator __position, list&& __x, iterator __i)



      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position, __i, __j);
      }
# 1202 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void

      splice(iterator __position, list&& __x, iterator __first,
      iterator __last)




      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position, __first, __last);
   }
      }
# 1231 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1245 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1259 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      unique();
# 1274 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1287 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void

      merge(list&& __x);
# 1306 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void

        merge(list&&, _StrictWeakOrdering);
# 1319 "/usr/include/c++/4.4/bits/stl_list.h" 3
      void
      reverse()
      { this->_M_impl._M_node.reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   push_back(__x);
      }
# 1380 "/usr/include/c++/4.4/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->transfer(__first._M_node, __last._M_node); }
# 1411 "/usr/include/c++/4.4/bits/stl_list.h" 3
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->hook(__position._M_node);
       }



      void
      _M_erase(iterator __position)
      {
        __position._M_node->unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);

        _M_get_Node_allocator().destroy(__n);



        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
# 1454 "/usr/include/c++/4.4/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1483 "/usr/include/c++/4.4/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>&& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>&& __y)
    { __x.swap(__y); }


}
# 64 "/usr/include/c++/4.4/list" 2 3


# 1 "/usr/include/c++/4.4/bits/list.tcc" 1 3
# 60 "/usr/include/c++/4.4/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);

   _M_get_Node_allocator().destroy(__tmp);



   _M_put_node(__tmp);
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->hook(__position._M_node);
 return iterator(__tmp);
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->hook(__position._M_node);
      return iterator(__tmp);
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (&*__first != &__value)
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::

    merge(list&& __x)



    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::

      merge(list&& __x, _StrictWeakOrdering __comp)



      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }

}
# 67 "/usr/include/c++/4.4/list" 2 3
# 23 "/usr/include/msgpack/type/list.hpp" 2 3 4

namespace msgpack {


template <typename T>
inline std::list<T>& operator>> (object o, std::list<T>& v)
{
 if(o.type != type::ARRAY) { throw type_error(); }
 v.resize(o.via.array.size);
 object* p = o.via.array.ptr;
 object* const pend = o.via.array.ptr + o.via.array.size;
 typename std::list<T>::iterator it = v.begin();
 for(; p < pend; ++p, ++it) {
  p->convert(&*it);
 }
 return v;
}

template <typename Stream, typename T>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::list<T>& v)
{
 o.pack_array(v.size());
 for(typename std::list<T>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(*it);
 }
 return o;
}

template <typename T>
inline void operator<< (object::with_zone& o, const std::list<T>& v)
{
 o.type = type::ARRAY;
 if(v.empty()) {
  o.via.array.ptr = __null;
  o.via.array.size = 0;
 } else {
  object* p = (object*)o.zone->malloc(sizeof(object)*v.size());
  object* const pend = p + v.size();
  o.via.array.ptr = p;
  o.via.array.size = v.size();
  typename std::list<T>::const_iterator it(v.begin());
  do {
   *p = object(*it, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


}
# 7 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/map.hpp" 1 3 4
# 26 "/usr/include/msgpack/type/map.hpp" 3 4
namespace msgpack {


namespace type {

template <typename K, typename V>
class assoc_vector : public std::vector< std::pair<K, V> > {};

namespace detail {
 template <typename K, typename V>
 struct pair_first_less {
  bool operator() (const std::pair<K, V>& x, const std::pair<K, V>& y) const
   { return x.first < y.first; }
 };
}

}


template <typename K, typename V>
inline type::assoc_vector<K,V>& operator>> (object o, type::assoc_vector<K,V>& v)
{
 if(o.type != type::MAP) { throw type_error(); }
 v.resize(o.via.map.size);
 object_kv* p = o.via.map.ptr;
 object_kv* const pend = o.via.map.ptr + o.via.map.size;
 std::pair<K, V>* it(&v.front());
 for(; p < pend; ++p, ++it) {
  p->key.convert(&it->first);
  p->val.convert(&it->second);
 }
 std::sort(v.begin(), v.end(), type::detail::pair_first_less<K,V>());
 return v;
}

template <typename Stream, typename K, typename V>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::assoc_vector<K,V>& v)
{
 o.pack_map(v.size());
 for(typename type::assoc_vector<K,V>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(it->first);
  o.pack(it->second);
 }
 return o;
}

template <typename K, typename V>
inline void operator<< (object::with_zone& o, const type::assoc_vector<K,V>& v)
{
 o.type = type::MAP;
 if(v.empty()) {
  o.via.map.ptr = __null;
  o.via.map.size = 0;
 } else {
  object_kv* p = (object_kv*)o.zone->malloc(sizeof(object_kv)*v.size());
  object_kv* const pend = p + v.size();
  o.via.map.ptr = p;
  o.via.map.size = v.size();
  typename type::assoc_vector<K,V>::const_iterator it(v.begin());
  do {
   p->key = object(it->first, o.zone);
   p->val = object(it->second, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


template <typename K, typename V>
inline std::map<K, V> operator>> (object o, std::map<K, V>& v)
{
 if(o.type != type::MAP) { throw type_error(); }
 object_kv* p(o.via.map.ptr);
 object_kv* const pend(o.via.map.ptr + o.via.map.size);
 for(; p != pend; ++p) {
  K key;
  p->key.convert(&key);
  typename std::map<K,V>::iterator it(v.lower_bound(key));
  if(it != v.end() && !(key < it->first)) {
   p->val.convert(&it->second);
  } else {
   V val;
   p->val.convert(&val);
   v.insert(it, std::pair<K,V>(key, val));
  }
 }
 return v;
}

template <typename Stream, typename K, typename V>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::map<K,V>& v)
{
 o.pack_map(v.size());
 for(typename std::map<K,V>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(it->first);
  o.pack(it->second);
 }
 return o;
}

template <typename K, typename V>
inline void operator<< (object::with_zone& o, const std::map<K,V>& v)
{
 o.type = type::MAP;
 if(v.empty()) {
  o.via.map.ptr = __null;
  o.via.map.size = 0;
 } else {
  object_kv* p = (object_kv*)o.zone->malloc(sizeof(object_kv)*v.size());
  object_kv* const pend = p + v.size();
  o.via.map.ptr = p;
  o.via.map.size = v.size();
  typename std::map<K,V>::const_iterator it(v.begin());
  do {
   p->key = object(it->first, o.zone);
   p->val = object(it->second, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


template <typename K, typename V>
inline std::multimap<K, V> operator>> (object o, std::multimap<K, V>& v)
{
 if(o.type != type::MAP) { throw type_error(); }
 object_kv* p(o.via.map.ptr);
 object_kv* const pend(o.via.map.ptr + o.via.map.size);
 for(; p != pend; ++p) {
  std::pair<K, V> value;
  p->key.convert(&value.first);
  p->val.convert(&value.second);
  v.insert(value);
 }
 return v;
}

template <typename Stream, typename K, typename V>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::multimap<K,V>& v)
{
 o.pack_map(v.size());
 for(typename std::multimap<K,V>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(it->first);
  o.pack(it->second);
 }
 return o;
}

template <typename K, typename V>
inline void operator<< (object::with_zone& o, const std::multimap<K,V>& v)
{
 o.type = type::MAP;
 if(v.empty()) {
  o.via.map.ptr = __null;
  o.via.map.size = 0;
 } else {
  object_kv* p = (object_kv*)o.zone->malloc(sizeof(object_kv)*v.size());
  object_kv* const pend = p + v.size();
  o.via.map.ptr = p;
  o.via.map.size = v.size();
  typename std::multimap<K,V>::const_iterator it(v.begin());
  do {
   p->key = object(it->first, o.zone);
   p->val = object(it->second, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


}
# 8 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/nil.hpp" 1 3 4
# 23 "/usr/include/msgpack/type/nil.hpp" 3 4
namespace msgpack {

namespace type {

struct nil { };

}


inline type::nil& operator>> (object o, type::nil& v)
{
 if(o.type != type::NIL) { throw type_error(); }
 return v;
}

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::nil& v)
{
 o.pack_nil();
 return o;
}

inline void operator<< (object& o, type::nil v)
{
 o.type = type::NIL;
}

inline void operator<< (object::with_zone& o, type::nil v)
 { static_cast<object&>(o) << v; }


template <>
inline void object::as<void>() const
{
 msgpack::type::nil v;
 convert(&v);
}


}
# 9 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/pair.hpp" 1 3 4
# 24 "/usr/include/msgpack/type/pair.hpp" 3 4
namespace msgpack {


template <typename T1, typename T2>
inline std::pair<T1, T2>& operator>> (object o, std::pair<T1, T2>& v)
{
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size != 2) { throw type_error(); }
 o.via.array.ptr[0].convert(&v.first);
 o.via.array.ptr[1].convert(&v.second);
 return v;
}

template <typename Stream, typename T1, typename T2>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::pair<T1, T2>& v)
{
 o.pack_array(2);
 o.pack(v.first);
 o.pack(v.second);
 return o;
}

template <typename T1, typename T2>
inline void operator<< (object::with_zone& o, const std::pair<T1, T2>& v)
{
 o.type = type::ARRAY;
 object* p = (object*)o.zone->malloc(sizeof(object)*2);
 o.via.array.ptr = p;
 o.via.array.size = 2;
 p[0] = object(v.first, o.zone);
 p[1] = object(v.second, o.zone);
}


}
# 10 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/raw.hpp" 1 3 4
# 25 "/usr/include/msgpack/type/raw.hpp" 3 4
namespace msgpack {

namespace type {

struct raw_ref {
 raw_ref() : size(0), ptr(__null) {}
 raw_ref(const char* p, uint32_t s) : size(s), ptr(p) {}

 uint32_t size;
 const char* ptr;

 std::string str() const { return std::string(ptr, size); }

 bool operator== (const raw_ref& x) const
 {
  return size == x.size && memcmp(ptr, x.ptr, size) == 0;
 }

 bool operator!= (const raw_ref& x) const
 {
  return !(*this != x);
 }

 bool operator< (const raw_ref& x) const
 {
  if(size == x.size) { return memcmp(ptr, x.ptr, size) < 0; }
  else { return size < x.size; }
 }

 bool operator> (const raw_ref& x) const
 {
  if(size == x.size) { return memcmp(ptr, x.ptr, size) > 0; }
  else { return size > x.size; }
 }
};

}


inline type::raw_ref& operator>> (object o, type::raw_ref& v)
{
 if(o.type != type::RAW) { throw type_error(); }
 v.ptr = o.via.raw.ptr;
 v.size = o.via.raw.size;
 return v;
}

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const type::raw_ref& v)
{
 o.pack_raw(v.size);
 o.pack_raw_body(v.ptr, v.size);
 return o;
}

inline void operator<< (object& o, const type::raw_ref& v)
{
 o.type = type::RAW;
 o.via.raw.ptr = v.ptr;
 o.via.raw.size = v.size;
}

inline void operator<< (object::with_zone& o, const type::raw_ref& v)
 { static_cast<object&>(o) << v; }


}
# 11 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/set.hpp" 1 3 4
# 22 "/usr/include/msgpack/type/set.hpp" 3 4
# 1 "/usr/include/c++/4.4/set" 1 3 4
# 58 "/usr/include/c++/4.4/set" 3 4
       
# 59 "/usr/include/c++/4.4/set" 3


# 1 "/usr/include/c++/4.4/bits/stl_set.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 85 "/usr/include/c++/4.4/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

    public:


      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;






      set()
      : _M_t() { }






      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 158 "/usr/include/c++/4.4/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 174 "/usr/include/c++/4.4/bits/stl_set.h" 3
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 188 "/usr/include/c++/4.4/bits/stl_set.h" 3
      set(const set& __x)
      : _M_t(__x._M_t) { }
# 199 "/usr/include/c++/4.4/bits/stl_set.h" 3
      set(set&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
# 212 "/usr/include/c++/4.4/bits/stl_set.h" 3
      set(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a)
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
# 226 "/usr/include/c++/4.4/bits/stl_set.h" 3
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 241 "/usr/include/c++/4.4/bits/stl_set.h" 3
      set&
      operator=(set&& __x)
      {

 this->clear();
 this->swap(__x);
 return *this;
      }
# 261 "/usr/include/c++/4.4/bits/stl_set.h" 3
      set&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }







      iterator
      cbegin() const
      { return _M_t.begin(); }






      iterator
      cend() const
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const
      { return _M_t.rend(); }



      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 385 "/usr/include/c++/4.4/bits/stl_set.h" 3
      void

      swap(set&& __x)



      { _M_t.swap(__x._M_t); }
# 407 "/usr/include/c++/4.4/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 434 "/usr/include/c++/4.4/bits/stl_set.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 447 "/usr/include/c++/4.4/bits/stl_set.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 460 "/usr/include/c++/4.4/bits/stl_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 474 "/usr/include/c++/4.4/bits/stl_set.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 489 "/usr/include/c++/4.4/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 504 "/usr/include/c++/4.4/bits/stl_set.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 528 "/usr/include/c++/4.4/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 546 "/usr/include/c++/4.4/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 567 "/usr/include/c++/4.4/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 583 "/usr/include/c++/4.4/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 608 "/usr/include/c++/4.4/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
# 637 "/usr/include/c++/4.4/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 654 "/usr/include/c++/4.4/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>&& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>&& __y)
    { __x.swap(__y); }


}
# 62 "/usr/include/c++/4.4/set" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_multiset.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 82 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

     

    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;





      multiset()
      : _M_t() { }






      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 151 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 167 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 181 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
# 192 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      multiset(multiset&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
# 205 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      multiset(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a)
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }
# 219 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 234 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      multiset&
      operator=(multiset&& __x)
      {

 this->clear();
 this->swap(__x);
 return *this;
      }
# 254 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      multiset&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }






      iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const
      { return _M_t.rend(); }







      iterator
      cbegin() const
      { return _M_t.begin(); }






      iterator
      cend() const
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const
      { return _M_t.rend(); }



      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 378 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      void

      swap(multiset&& __x)



      { _M_t.swap(__x._M_t); }
# 398 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 422 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 434 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 447 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 462 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 477 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 492 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }







      void
      clear()
      { _M_t.clear(); }
# 513 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 531 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 552 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 568 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 593 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
# 623 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 640 "/usr/include/c++/4.4/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>&& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>&& __y)
    { __x.swap(__y); }


}
# 63 "/usr/include/c++/4.4/set" 2 3
# 23 "/usr/include/msgpack/type/set.hpp" 2 3 4

namespace msgpack {


template <typename T>
inline std::set<T>& operator>> (object o, std::set<T>& v)
{
 if(o.type != type::ARRAY) { throw type_error(); }
 object* p = o.via.array.ptr + o.via.array.size;
 object* const pbegin = o.via.array.ptr;
 while(p > pbegin) {
  --p;
  v.insert(p->as<T>());
 }
 return v;
}

template <typename Stream, typename T>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::set<T>& v)
{
 o.pack_array(v.size());
 for(typename std::set<T>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(*it);
 }
 return o;
}

template <typename T>
inline void operator<< (object::with_zone& o, const std::set<T>& v)
{
 o.type = type::ARRAY;
 if(v.empty()) {
  o.via.array.ptr = __null;
  o.via.array.size = 0;
 } else {
  object* p = (object*)o.zone->malloc(sizeof(object)*v.size());
  object* const pend = p + v.size();
  o.via.array.ptr = p;
  o.via.array.size = v.size();
  typename std::set<T>::const_iterator it(v.begin());
  do {
   *p = object(*it, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


template <typename T>
inline std::multiset<T>& operator>> (object o, std::multiset<T>& v)
{
 if(o.type != type::ARRAY) { throw type_error(); }
 object* p = o.via.array.ptr + o.via.array.size;
 object* const pbegin = o.via.array.ptr;
 while(p > pbegin) {
  --p;
  v.insert(p->as<T>());
 }
 return v;
}

template <typename Stream, typename T>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::multiset<T>& v)
{
 o.pack_array(v.size());
 for(typename std::multiset<T>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(*it);
 }
 return o;
}

template <typename T>
inline void operator<< (object::with_zone& o, const std::multiset<T>& v)
{
 o.type = type::ARRAY;
 if(v.empty()) {
  o.via.array.ptr = __null;
  o.via.array.size = 0;
 } else {
  object* p = (object*)o.zone->malloc(sizeof(object)*v.size());
  object* const pend = p + v.size();
  o.via.array.ptr = p;
  o.via.array.size = v.size();
  typename std::multiset<T>::const_iterator it(v.begin());
  do {
   *p = object(*it, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


}
# 12 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/string.hpp" 1 3 4
# 24 "/usr/include/msgpack/type/string.hpp" 3 4
namespace msgpack {


inline std::string& operator>> (object o, std::string& v)
{
 if(o.type != type::RAW) { throw type_error(); }
 v.assign(o.via.raw.ptr, o.via.raw.size);
 return v;
}

template <typename Stream>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::string& v)
{
 o.pack_raw(v.size());
 o.pack_raw_body(v.data(), v.size());
 return o;
}

inline void operator<< (object::with_zone& o, const std::string& v)
{
 o.type = type::RAW;
 char* ptr = (char*)o.zone->malloc(v.size());
 o.via.raw.ptr = ptr;
 o.via.raw.size = v.size();
 memcpy(ptr, v.data(), v.size());
}

inline void operator<< (object& o, const std::string& v)
{
 o.type = type::RAW;
 o.via.raw.ptr = v.data();
 o.via.raw.size = v.size();
}


}
# 13 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/vector.hpp" 1 3 4
# 24 "/usr/include/msgpack/type/vector.hpp" 3 4
namespace msgpack {


template <typename T>
inline std::vector<T>& operator>> (object o, std::vector<T>& v)
{
 if(o.type != type::ARRAY) { throw type_error(); }
 v.resize(o.via.array.size);
 if(o.via.array.size > 0) {
  object* p = o.via.array.ptr;
  object* const pend = o.via.array.ptr + o.via.array.size;
  T* it = &v[0];
  do {
   p->convert(it);
   ++p;
   ++it;
  } while(p < pend);
 }
 return v;
}

template <typename Stream, typename T>
inline packer<Stream>& operator<< (packer<Stream>& o, const std::vector<T>& v)
{
 o.pack_array(v.size());
 for(typename std::vector<T>::const_iterator it(v.begin()), it_end(v.end());
   it != it_end; ++it) {
  o.pack(*it);
 }
 return o;
}

template <typename T>
inline void operator<< (object::with_zone& o, const std::vector<T>& v)
{
 o.type = type::ARRAY;
 if(v.empty()) {
  o.via.array.ptr = __null;
  o.via.array.size = 0;
 } else {
  object* p = (object*)o.zone->malloc(sizeof(object)*v.size());
  object* const pend = p + v.size();
  o.via.array.ptr = p;
  o.via.array.size = v.size();
  typename std::vector<T>::const_iterator it(v.begin());
  do {
   *p = object(*it, o.zone);
   ++p;
   ++it;
  } while(p < pend);
 }
}


}
# 14 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/tuple.hpp" 1 3 4
# 23 "/usr/include/msgpack/type/tuple.hpp" 3 4
namespace msgpack {

namespace type {





template <typename A0 = void, typename A1 = void, typename A2 = void, typename A3 = void, typename A4 = void, typename A5 = void, typename A6 = void, typename A7 = void, typename A8 = void, typename A9 = void, typename A10 = void, typename A11 = void, typename A12 = void, typename A13 = void, typename A14 = void, typename A15 = void, typename A16 = void, typename A17 = void, typename A18 = void, typename A19 = void, typename A20 = void, typename A21 = void, typename A22 = void, typename A23 = void, typename A24 = void, typename A25 = void, typename A26 = void, typename A27 = void, typename A28 = void, typename A29 = void, typename A30 = void, typename A31 = void, typename A32 = void>
struct tuple;

template <typename Tuple, int N>
struct tuple_element;

template <typename Tuple, int N>
struct const_tuple_element;

template <typename T>
struct tuple_type {
 typedef T type;
 typedef T value_type;
 typedef T& reference;
 typedef const T& const_reference;
 typedef const T& transparent_reference;
};

template <typename T>
struct tuple_type<T&> {
 typedef T type;
 typedef T& value_type;
 typedef T& reference;
 typedef const T& const_reference;
 typedef T& transparent_reference;
};

template <typename T>
struct tuple_type<const T&> {
 typedef T type;
 typedef T& value_type;
 typedef T& reference;
 typedef const T& const_reference;
 typedef const T& transparent_reference;
};



template <typename A0>
struct tuple_element<tuple<A0>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0>& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};



template <typename A0, typename A1>
struct tuple_element<tuple<A0, A1>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1>
struct tuple_element<tuple<A0, A1>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};



template <typename A0, typename A1, typename A2>
struct tuple_element<tuple<A0, A1, A2>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2>
struct tuple_element<tuple<A0, A1, A2>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2>
struct tuple_element<tuple<A0, A1, A2>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3>
struct tuple_element<tuple<A0, A1, A2, A3>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3>
struct tuple_element<tuple<A0, A1, A2, A3>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3>
struct tuple_element<tuple<A0, A1, A2, A3>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3>
struct tuple_element<tuple<A0, A1, A2, A3>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct tuple_element<tuple<A0, A1, A2, A3, A4>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct tuple_element<tuple<A0, A1, A2, A3, A4>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct tuple_element<tuple<A0, A1, A2, A3, A4>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct tuple_element<tuple<A0, A1, A2, A3, A4>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct tuple_element<tuple<A0, A1, A2, A3, A4>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 25> : tuple_type<A25> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 >& x) : _x(x.a25) {}
 typename tuple_type<A25>::reference get() { return _x; }
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 25> : tuple_type<A25> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a25) {}
 typename tuple_type<A25>::reference get() { return _x; }
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 26> : tuple_type<A26> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 >& x) : _x(x.a26) {}
 typename tuple_type<A26>::reference get() { return _x; }
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 25> : tuple_type<A25> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a25) {}
 typename tuple_type<A25>::reference get() { return _x; }
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 26> : tuple_type<A26> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a26) {}
 typename tuple_type<A26>::reference get() { return _x; }
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 27> : tuple_type<A27> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 >& x) : _x(x.a27) {}
 typename tuple_type<A27>::reference get() { return _x; }
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 25> : tuple_type<A25> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a25) {}
 typename tuple_type<A25>::reference get() { return _x; }
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 26> : tuple_type<A26> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a26) {}
 typename tuple_type<A26>::reference get() { return _x; }
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 27> : tuple_type<A27> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a27) {}
 typename tuple_type<A27>::reference get() { return _x; }
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 28> : tuple_type<A28> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 >& x) : _x(x.a28) {}
 typename tuple_type<A28>::reference get() { return _x; }
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 25> : tuple_type<A25> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a25) {}
 typename tuple_type<A25>::reference get() { return _x; }
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 26> : tuple_type<A26> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a26) {}
 typename tuple_type<A26>::reference get() { return _x; }
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 27> : tuple_type<A27> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a27) {}
 typename tuple_type<A27>::reference get() { return _x; }
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 28> : tuple_type<A28> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a28) {}
 typename tuple_type<A28>::reference get() { return _x; }
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 29> : tuple_type<A29> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 >& x) : _x(x.a29) {}
 typename tuple_type<A29>::reference get() { return _x; }
 typename tuple_type<A29>::const_reference get() const { return _x; }
private:
 typename tuple_type<A29>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 25> : tuple_type<A25> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a25) {}
 typename tuple_type<A25>::reference get() { return _x; }
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 26> : tuple_type<A26> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a26) {}
 typename tuple_type<A26>::reference get() { return _x; }
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 27> : tuple_type<A27> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a27) {}
 typename tuple_type<A27>::reference get() { return _x; }
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 28> : tuple_type<A28> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a28) {}
 typename tuple_type<A28>::reference get() { return _x; }
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 29> : tuple_type<A29> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a29) {}
 typename tuple_type<A29>::reference get() { return _x; }
 typename tuple_type<A29>::const_reference get() const { return _x; }
private:
 typename tuple_type<A29>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 30> : tuple_type<A30> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 >& x) : _x(x.a30) {}
 typename tuple_type<A30>::reference get() { return _x; }
 typename tuple_type<A30>::const_reference get() const { return _x; }
private:
 typename tuple_type<A30>::reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 0> : tuple_type<A0> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a0) {}
 typename tuple_type<A0>::reference get() { return _x; }
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 1> : tuple_type<A1> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a1) {}
 typename tuple_type<A1>::reference get() { return _x; }
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 2> : tuple_type<A2> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a2) {}
 typename tuple_type<A2>::reference get() { return _x; }
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 3> : tuple_type<A3> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a3) {}
 typename tuple_type<A3>::reference get() { return _x; }
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 4> : tuple_type<A4> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a4) {}
 typename tuple_type<A4>::reference get() { return _x; }
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 5> : tuple_type<A5> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a5) {}
 typename tuple_type<A5>::reference get() { return _x; }
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 6> : tuple_type<A6> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a6) {}
 typename tuple_type<A6>::reference get() { return _x; }
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 7> : tuple_type<A7> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a7) {}
 typename tuple_type<A7>::reference get() { return _x; }
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 8> : tuple_type<A8> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a8) {}
 typename tuple_type<A8>::reference get() { return _x; }
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 9> : tuple_type<A9> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a9) {}
 typename tuple_type<A9>::reference get() { return _x; }
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 10> : tuple_type<A10> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a10) {}
 typename tuple_type<A10>::reference get() { return _x; }
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 11> : tuple_type<A11> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a11) {}
 typename tuple_type<A11>::reference get() { return _x; }
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 12> : tuple_type<A12> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a12) {}
 typename tuple_type<A12>::reference get() { return _x; }
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 13> : tuple_type<A13> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a13) {}
 typename tuple_type<A13>::reference get() { return _x; }
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 14> : tuple_type<A14> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a14) {}
 typename tuple_type<A14>::reference get() { return _x; }
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 15> : tuple_type<A15> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a15) {}
 typename tuple_type<A15>::reference get() { return _x; }
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 16> : tuple_type<A16> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a16) {}
 typename tuple_type<A16>::reference get() { return _x; }
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 17> : tuple_type<A17> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a17) {}
 typename tuple_type<A17>::reference get() { return _x; }
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 18> : tuple_type<A18> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a18) {}
 typename tuple_type<A18>::reference get() { return _x; }
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 19> : tuple_type<A19> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a19) {}
 typename tuple_type<A19>::reference get() { return _x; }
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 20> : tuple_type<A20> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a20) {}
 typename tuple_type<A20>::reference get() { return _x; }
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 21> : tuple_type<A21> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a21) {}
 typename tuple_type<A21>::reference get() { return _x; }
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 22> : tuple_type<A22> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a22) {}
 typename tuple_type<A22>::reference get() { return _x; }
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 23> : tuple_type<A23> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a23) {}
 typename tuple_type<A23>::reference get() { return _x; }
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 24> : tuple_type<A24> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a24) {}
 typename tuple_type<A24>::reference get() { return _x; }
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 25> : tuple_type<A25> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a25) {}
 typename tuple_type<A25>::reference get() { return _x; }
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 26> : tuple_type<A26> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a26) {}
 typename tuple_type<A26>::reference get() { return _x; }
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 27> : tuple_type<A27> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a27) {}
 typename tuple_type<A27>::reference get() { return _x; }
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 28> : tuple_type<A28> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a28) {}
 typename tuple_type<A28>::reference get() { return _x; }
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 29> : tuple_type<A29> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a29) {}
 typename tuple_type<A29>::reference get() { return _x; }
 typename tuple_type<A29>::const_reference get() const { return _x; }
private:
 typename tuple_type<A29>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 30> : tuple_type<A30> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a30) {}
 typename tuple_type<A30>::reference get() { return _x; }
 typename tuple_type<A30>::const_reference get() const { return _x; }
private:
 typename tuple_type<A30>::reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 31> : tuple_type<A31> {
 tuple_element(tuple<A0, A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 , A11 , A12 , A13 , A14 , A15 , A16 , A17 , A18 , A19 , A20 , A21 , A22 , A23 , A24 , A25 , A26 , A27 , A28 , A29 , A30 , A31 >& x) : _x(x.a31) {}
 typename tuple_type<A31>::reference get() { return _x; }
 typename tuple_type<A31>::const_reference get() const { return _x; }
private:
 typename tuple_type<A31>::reference _x;
};





template <typename A0>
struct const_tuple_element<tuple<A0>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};



template <typename A0, typename A1>
struct const_tuple_element<tuple<A0, A1>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1>
struct const_tuple_element<tuple<A0, A1>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};



template <typename A0, typename A1, typename A2>
struct const_tuple_element<tuple<A0, A1, A2>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2>
struct const_tuple_element<tuple<A0, A1, A2>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2>
struct const_tuple_element<tuple<A0, A1, A2>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3>
struct const_tuple_element<tuple<A0, A1, A2, A3>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3>
struct const_tuple_element<tuple<A0, A1, A2, A3>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3>
struct const_tuple_element<tuple<A0, A1, A2, A3>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3>
struct const_tuple_element<tuple<A0, A1, A2, A3>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>, 25> : tuple_type<A25> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& x) : _x(x.a25) {}
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 25> : tuple_type<A25> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a25) {}
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>, 26> : tuple_type<A26> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& x) : _x(x.a26) {}
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 25> : tuple_type<A25> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a25) {}
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 26> : tuple_type<A26> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a26) {}
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>, 27> : tuple_type<A27> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& x) : _x(x.a27) {}
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 25> : tuple_type<A25> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a25) {}
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 26> : tuple_type<A26> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a26) {}
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 27> : tuple_type<A27> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a27) {}
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>, 28> : tuple_type<A28> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& x) : _x(x.a28) {}
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 25> : tuple_type<A25> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a25) {}
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 26> : tuple_type<A26> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a26) {}
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 27> : tuple_type<A27> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a27) {}
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 28> : tuple_type<A28> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a28) {}
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>, 29> : tuple_type<A29> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& x) : _x(x.a29) {}
 typename tuple_type<A29>::const_reference get() const { return _x; }
private:
 typename tuple_type<A29>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 25> : tuple_type<A25> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a25) {}
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 26> : tuple_type<A26> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a26) {}
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 27> : tuple_type<A27> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a27) {}
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 28> : tuple_type<A28> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a28) {}
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 29> : tuple_type<A29> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a29) {}
 typename tuple_type<A29>::const_reference get() const { return _x; }
private:
 typename tuple_type<A29>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>, 30> : tuple_type<A30> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& x) : _x(x.a30) {}
 typename tuple_type<A30>::const_reference get() const { return _x; }
private:
 typename tuple_type<A30>::const_reference _x;
};



template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 0> : tuple_type<A0> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a0) {}
 typename tuple_type<A0>::const_reference get() const { return _x; }
private:
 typename tuple_type<A0>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 1> : tuple_type<A1> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a1) {}
 typename tuple_type<A1>::const_reference get() const { return _x; }
private:
 typename tuple_type<A1>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 2> : tuple_type<A2> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a2) {}
 typename tuple_type<A2>::const_reference get() const { return _x; }
private:
 typename tuple_type<A2>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 3> : tuple_type<A3> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a3) {}
 typename tuple_type<A3>::const_reference get() const { return _x; }
private:
 typename tuple_type<A3>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 4> : tuple_type<A4> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a4) {}
 typename tuple_type<A4>::const_reference get() const { return _x; }
private:
 typename tuple_type<A4>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 5> : tuple_type<A5> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a5) {}
 typename tuple_type<A5>::const_reference get() const { return _x; }
private:
 typename tuple_type<A5>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 6> : tuple_type<A6> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a6) {}
 typename tuple_type<A6>::const_reference get() const { return _x; }
private:
 typename tuple_type<A6>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 7> : tuple_type<A7> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a7) {}
 typename tuple_type<A7>::const_reference get() const { return _x; }
private:
 typename tuple_type<A7>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 8> : tuple_type<A8> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a8) {}
 typename tuple_type<A8>::const_reference get() const { return _x; }
private:
 typename tuple_type<A8>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 9> : tuple_type<A9> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a9) {}
 typename tuple_type<A9>::const_reference get() const { return _x; }
private:
 typename tuple_type<A9>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 10> : tuple_type<A10> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a10) {}
 typename tuple_type<A10>::const_reference get() const { return _x; }
private:
 typename tuple_type<A10>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 11> : tuple_type<A11> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a11) {}
 typename tuple_type<A11>::const_reference get() const { return _x; }
private:
 typename tuple_type<A11>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 12> : tuple_type<A12> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a12) {}
 typename tuple_type<A12>::const_reference get() const { return _x; }
private:
 typename tuple_type<A12>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 13> : tuple_type<A13> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a13) {}
 typename tuple_type<A13>::const_reference get() const { return _x; }
private:
 typename tuple_type<A13>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 14> : tuple_type<A14> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a14) {}
 typename tuple_type<A14>::const_reference get() const { return _x; }
private:
 typename tuple_type<A14>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 15> : tuple_type<A15> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a15) {}
 typename tuple_type<A15>::const_reference get() const { return _x; }
private:
 typename tuple_type<A15>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 16> : tuple_type<A16> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a16) {}
 typename tuple_type<A16>::const_reference get() const { return _x; }
private:
 typename tuple_type<A16>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 17> : tuple_type<A17> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a17) {}
 typename tuple_type<A17>::const_reference get() const { return _x; }
private:
 typename tuple_type<A17>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 18> : tuple_type<A18> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a18) {}
 typename tuple_type<A18>::const_reference get() const { return _x; }
private:
 typename tuple_type<A18>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 19> : tuple_type<A19> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a19) {}
 typename tuple_type<A19>::const_reference get() const { return _x; }
private:
 typename tuple_type<A19>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 20> : tuple_type<A20> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a20) {}
 typename tuple_type<A20>::const_reference get() const { return _x; }
private:
 typename tuple_type<A20>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 21> : tuple_type<A21> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a21) {}
 typename tuple_type<A21>::const_reference get() const { return _x; }
private:
 typename tuple_type<A21>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 22> : tuple_type<A22> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a22) {}
 typename tuple_type<A22>::const_reference get() const { return _x; }
private:
 typename tuple_type<A22>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 23> : tuple_type<A23> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a23) {}
 typename tuple_type<A23>::const_reference get() const { return _x; }
private:
 typename tuple_type<A23>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 24> : tuple_type<A24> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a24) {}
 typename tuple_type<A24>::const_reference get() const { return _x; }
private:
 typename tuple_type<A24>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 25> : tuple_type<A25> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a25) {}
 typename tuple_type<A25>::const_reference get() const { return _x; }
private:
 typename tuple_type<A25>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 26> : tuple_type<A26> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a26) {}
 typename tuple_type<A26>::const_reference get() const { return _x; }
private:
 typename tuple_type<A26>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 27> : tuple_type<A27> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a27) {}
 typename tuple_type<A27>::const_reference get() const { return _x; }
private:
 typename tuple_type<A27>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 28> : tuple_type<A28> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a28) {}
 typename tuple_type<A28>::const_reference get() const { return _x; }
private:
 typename tuple_type<A28>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 29> : tuple_type<A29> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a29) {}
 typename tuple_type<A29>::const_reference get() const { return _x; }
private:
 typename tuple_type<A29>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 30> : tuple_type<A30> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a30) {}
 typename tuple_type<A30>::const_reference get() const { return _x; }
private:
 typename tuple_type<A30>::const_reference _x;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct const_tuple_element<tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>, 31> : tuple_type<A31> {
 const_tuple_element(const tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& x) : _x(x.a31) {}
 typename tuple_type<A31>::const_reference get() const { return _x; }
private:
 typename tuple_type<A31>::const_reference _x;
};



template <>
struct tuple<> {
 tuple() {}
 tuple(object o) { o.convert(this); }
 typedef tuple<> value_type;
};

template <typename A0>
struct tuple<A0> {
 typedef tuple<A0> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0) :
  a0(_a0) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
};

template <typename A0, typename A1>
struct tuple<A0, A1> {
 typedef tuple<A0, A1> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1) :
  a0(_a0), a1(_a1) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
};

template <typename A0, typename A1, typename A2>
struct tuple<A0, A1, A2> {
 typedef tuple<A0, A1, A2> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2) :
  a0(_a0), a1(_a1), a2(_a2) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
};

template <typename A0, typename A1, typename A2, typename A3>
struct tuple<A0, A1, A2, A3> {
 typedef tuple<A0, A1, A2, A3> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct tuple<A0, A1, A2, A3, A4> {
 typedef tuple<A0, A1, A2, A3, A4> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct tuple<A0, A1, A2, A3, A4, A5> {
 typedef tuple<A0, A1, A2, A3, A4, A5> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct tuple<A0, A1, A2, A3, A4, A5, A6> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24, typename tuple_type<A25>::transparent_reference _a25) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
 A25 a25;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24, typename tuple_type<A25>::transparent_reference _a25, typename tuple_type<A26>::transparent_reference _a26) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
 A25 a25;
 A26 a26;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24, typename tuple_type<A25>::transparent_reference _a25, typename tuple_type<A26>::transparent_reference _a26, typename tuple_type<A27>::transparent_reference _a27) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
 A25 a25;
 A26 a26;
 A27 a27;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24, typename tuple_type<A25>::transparent_reference _a25, typename tuple_type<A26>::transparent_reference _a26, typename tuple_type<A27>::transparent_reference _a27, typename tuple_type<A28>::transparent_reference _a28) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
 A25 a25;
 A26 a26;
 A27 a27;
 A28 a28;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24, typename tuple_type<A25>::transparent_reference _a25, typename tuple_type<A26>::transparent_reference _a26, typename tuple_type<A27>::transparent_reference _a27, typename tuple_type<A28>::transparent_reference _a28, typename tuple_type<A29>::transparent_reference _a29) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28), a29(_a29) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
 A25 a25;
 A26 a26;
 A27 a27;
 A28 a28;
 A29 a29;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24, typename tuple_type<A25>::transparent_reference _a25, typename tuple_type<A26>::transparent_reference _a26, typename tuple_type<A27>::transparent_reference _a27, typename tuple_type<A28>::transparent_reference _a28, typename tuple_type<A29>::transparent_reference _a29, typename tuple_type<A30>::transparent_reference _a30) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28), a29(_a29), a30(_a30) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
 A25 a25;
 A26 a26;
 A27 a27;
 A28 a28;
 A29 a29;
 A30 a30;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31> {
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31> value_type;
 tuple() {}
 tuple(typename tuple_type<A0>::transparent_reference _a0, typename tuple_type<A1>::transparent_reference _a1, typename tuple_type<A2>::transparent_reference _a2, typename tuple_type<A3>::transparent_reference _a3, typename tuple_type<A4>::transparent_reference _a4, typename tuple_type<A5>::transparent_reference _a5, typename tuple_type<A6>::transparent_reference _a6, typename tuple_type<A7>::transparent_reference _a7, typename tuple_type<A8>::transparent_reference _a8, typename tuple_type<A9>::transparent_reference _a9, typename tuple_type<A10>::transparent_reference _a10, typename tuple_type<A11>::transparent_reference _a11, typename tuple_type<A12>::transparent_reference _a12, typename tuple_type<A13>::transparent_reference _a13, typename tuple_type<A14>::transparent_reference _a14, typename tuple_type<A15>::transparent_reference _a15, typename tuple_type<A16>::transparent_reference _a16, typename tuple_type<A17>::transparent_reference _a17, typename tuple_type<A18>::transparent_reference _a18, typename tuple_type<A19>::transparent_reference _a19, typename tuple_type<A20>::transparent_reference _a20, typename tuple_type<A21>::transparent_reference _a21, typename tuple_type<A22>::transparent_reference _a22, typename tuple_type<A23>::transparent_reference _a23, typename tuple_type<A24>::transparent_reference _a24, typename tuple_type<A25>::transparent_reference _a25, typename tuple_type<A26>::transparent_reference _a26, typename tuple_type<A27>::transparent_reference _a27, typename tuple_type<A28>::transparent_reference _a28, typename tuple_type<A29>::transparent_reference _a29, typename tuple_type<A30>::transparent_reference _a30, typename tuple_type<A31>::transparent_reference _a31) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28), a29(_a29), a30(_a30), a31(_a31) {}
 tuple(object o) { o.convert(this); }
 template <int N> typename tuple_element<value_type, N>::reference get()
  { return tuple_element<value_type, N>(*this).get(); }
 template <int N> typename const_tuple_element<value_type, N>::const_reference get() const
  { return const_tuple_element<value_type, N>(*this).get(); }

 A0 a0;
 A1 a1;
 A2 a2;
 A3 a3;
 A4 a4;
 A5 a5;
 A6 a6;
 A7 a7;
 A8 a8;
 A9 a9;
 A10 a10;
 A11 a11;
 A12 a12;
 A13 a13;
 A14 a14;
 A15 a15;
 A16 a16;
 A17 a17;
 A18 a18;
 A19 a19;
 A20 a20;
 A21 a21;
 A22 a22;
 A23 a23;
 A24 a24;
 A25 a25;
 A26 a26;
 A27 a27;
 A28 a28;
 A29 a29;
 A30 a30;
 A31 a31;
};


inline tuple<> make_tuple()
{
 return tuple<>();
}

template <typename A0>
tuple<A0> make_tuple(typename tuple_type<A0>::transparent_reference a0)
{
 return tuple<A0>(a0);
}

template <typename A0, typename A1>
tuple<A0, A1> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1)
{
 return tuple<A0, A1>(a0, a1);
}

template <typename A0, typename A1, typename A2>
tuple<A0, A1, A2> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2)
{
 return tuple<A0, A1, A2>(a0, a1, a2);
}

template <typename A0, typename A1, typename A2, typename A3>
tuple<A0, A1, A2, A3> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3)
{
 return tuple<A0, A1, A2, A3>(a0, a1, a2, a3);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4>
tuple<A0, A1, A2, A3, A4> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4)
{
 return tuple<A0, A1, A2, A3, A4>(a0, a1, a2, a3, a4);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
tuple<A0, A1, A2, A3, A4, A5> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5)
{
 return tuple<A0, A1, A2, A3, A4, A5>(a0, a1, a2, a3, a4, a5);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
tuple<A0, A1, A2, A3, A4, A5, A6> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6>(a0, a1, a2, a3, a4, a5, a6);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
tuple<A0, A1, A2, A3, A4, A5, A6, A7> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7>(a0, a1, a2, a3, a4, a5, a6, a7);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>(a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24, typename tuple_type<A25>::transparent_reference a25)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24, typename tuple_type<A25>::transparent_reference a25, typename tuple_type<A26>::transparent_reference a26)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24, typename tuple_type<A25>::transparent_reference a25, typename tuple_type<A26>::transparent_reference a26, typename tuple_type<A27>::transparent_reference a27)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24, typename tuple_type<A25>::transparent_reference a25, typename tuple_type<A26>::transparent_reference a26, typename tuple_type<A27>::transparent_reference a27, typename tuple_type<A28>::transparent_reference a28)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24, typename tuple_type<A25>::transparent_reference a25, typename tuple_type<A26>::transparent_reference a26, typename tuple_type<A27>::transparent_reference a27, typename tuple_type<A28>::transparent_reference a28, typename tuple_type<A29>::transparent_reference a29)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24, typename tuple_type<A25>::transparent_reference a25, typename tuple_type<A26>::transparent_reference a26, typename tuple_type<A27>::transparent_reference a27, typename tuple_type<A28>::transparent_reference a28, typename tuple_type<A29>::transparent_reference a29, typename tuple_type<A30>::transparent_reference a30)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31> make_tuple(typename tuple_type<A0>::transparent_reference a0, typename tuple_type<A1>::transparent_reference a1, typename tuple_type<A2>::transparent_reference a2, typename tuple_type<A3>::transparent_reference a3, typename tuple_type<A4>::transparent_reference a4, typename tuple_type<A5>::transparent_reference a5, typename tuple_type<A6>::transparent_reference a6, typename tuple_type<A7>::transparent_reference a7, typename tuple_type<A8>::transparent_reference a8, typename tuple_type<A9>::transparent_reference a9, typename tuple_type<A10>::transparent_reference a10, typename tuple_type<A11>::transparent_reference a11, typename tuple_type<A12>::transparent_reference a12, typename tuple_type<A13>::transparent_reference a13, typename tuple_type<A14>::transparent_reference a14, typename tuple_type<A15>::transparent_reference a15, typename tuple_type<A16>::transparent_reference a16, typename tuple_type<A17>::transparent_reference a17, typename tuple_type<A18>::transparent_reference a18, typename tuple_type<A19>::transparent_reference a19, typename tuple_type<A20>::transparent_reference a20, typename tuple_type<A21>::transparent_reference a21, typename tuple_type<A22>::transparent_reference a22, typename tuple_type<A23>::transparent_reference a23, typename tuple_type<A24>::transparent_reference a24, typename tuple_type<A25>::transparent_reference a25, typename tuple_type<A26>::transparent_reference a26, typename tuple_type<A27>::transparent_reference a27, typename tuple_type<A28>::transparent_reference a28, typename tuple_type<A29>::transparent_reference a29, typename tuple_type<A30>::transparent_reference a30, typename tuple_type<A31>::transparent_reference a31)
{
 return tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31);
}


}


inline type::tuple<>& operator>> (
  object o,
  type::tuple<>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 return v;
}

template <typename A0>
type::tuple<A0>& operator>> (
  object o,
  type::tuple<A0>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 1) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 return v;
}

template <typename A0, typename A1>
type::tuple<A0, A1>& operator>> (
  object o,
  type::tuple<A0, A1>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 2) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 return v;
}

template <typename A0, typename A1, typename A2>
type::tuple<A0, A1, A2>& operator>> (
  object o,
  type::tuple<A0, A1, A2>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 3) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3>
type::tuple<A0, A1, A2, A3>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 4) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4>
type::tuple<A0, A1, A2, A3, A4>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 5) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
type::tuple<A0, A1, A2, A3, A4, A5>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 6) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
type::tuple<A0, A1, A2, A3, A4, A5, A6>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 7) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 8) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 9) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 10) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 11) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 12) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 13) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 14) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 15) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 16) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 17) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 18) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 19) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 20) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 21) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 22) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 23) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 24) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 25) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 26) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 o.via.array.ptr[25].convert<typename type::tuple_type<A25>::type>(&v.template get<25>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 27) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 o.via.array.ptr[25].convert<typename type::tuple_type<A25>::type>(&v.template get<25>());
 o.via.array.ptr[26].convert<typename type::tuple_type<A26>::type>(&v.template get<26>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 28) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 o.via.array.ptr[25].convert<typename type::tuple_type<A25>::type>(&v.template get<25>());
 o.via.array.ptr[26].convert<typename type::tuple_type<A26>::type>(&v.template get<26>());
 o.via.array.ptr[27].convert<typename type::tuple_type<A27>::type>(&v.template get<27>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 29) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 o.via.array.ptr[25].convert<typename type::tuple_type<A25>::type>(&v.template get<25>());
 o.via.array.ptr[26].convert<typename type::tuple_type<A26>::type>(&v.template get<26>());
 o.via.array.ptr[27].convert<typename type::tuple_type<A27>::type>(&v.template get<27>());
 o.via.array.ptr[28].convert<typename type::tuple_type<A28>::type>(&v.template get<28>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 30) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 o.via.array.ptr[25].convert<typename type::tuple_type<A25>::type>(&v.template get<25>());
 o.via.array.ptr[26].convert<typename type::tuple_type<A26>::type>(&v.template get<26>());
 o.via.array.ptr[27].convert<typename type::tuple_type<A27>::type>(&v.template get<27>());
 o.via.array.ptr[28].convert<typename type::tuple_type<A28>::type>(&v.template get<28>());
 o.via.array.ptr[29].convert<typename type::tuple_type<A29>::type>(&v.template get<29>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 31) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 o.via.array.ptr[25].convert<typename type::tuple_type<A25>::type>(&v.template get<25>());
 o.via.array.ptr[26].convert<typename type::tuple_type<A26>::type>(&v.template get<26>());
 o.via.array.ptr[27].convert<typename type::tuple_type<A27>::type>(&v.template get<27>());
 o.via.array.ptr[28].convert<typename type::tuple_type<A28>::type>(&v.template get<28>());
 o.via.array.ptr[29].convert<typename type::tuple_type<A29>::type>(&v.template get<29>());
 o.via.array.ptr[30].convert<typename type::tuple_type<A30>::type>(&v.template get<30>());
 return v;
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& operator>> (
  object o,
  type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& v) {
 if(o.type != type::ARRAY) { throw type_error(); }
 if(o.via.array.size < 32) { throw type_error(); }

 o.via.array.ptr[0].convert<typename type::tuple_type<A0>::type>(&v.template get<0>());
 o.via.array.ptr[1].convert<typename type::tuple_type<A1>::type>(&v.template get<1>());
 o.via.array.ptr[2].convert<typename type::tuple_type<A2>::type>(&v.template get<2>());
 o.via.array.ptr[3].convert<typename type::tuple_type<A3>::type>(&v.template get<3>());
 o.via.array.ptr[4].convert<typename type::tuple_type<A4>::type>(&v.template get<4>());
 o.via.array.ptr[5].convert<typename type::tuple_type<A5>::type>(&v.template get<5>());
 o.via.array.ptr[6].convert<typename type::tuple_type<A6>::type>(&v.template get<6>());
 o.via.array.ptr[7].convert<typename type::tuple_type<A7>::type>(&v.template get<7>());
 o.via.array.ptr[8].convert<typename type::tuple_type<A8>::type>(&v.template get<8>());
 o.via.array.ptr[9].convert<typename type::tuple_type<A9>::type>(&v.template get<9>());
 o.via.array.ptr[10].convert<typename type::tuple_type<A10>::type>(&v.template get<10>());
 o.via.array.ptr[11].convert<typename type::tuple_type<A11>::type>(&v.template get<11>());
 o.via.array.ptr[12].convert<typename type::tuple_type<A12>::type>(&v.template get<12>());
 o.via.array.ptr[13].convert<typename type::tuple_type<A13>::type>(&v.template get<13>());
 o.via.array.ptr[14].convert<typename type::tuple_type<A14>::type>(&v.template get<14>());
 o.via.array.ptr[15].convert<typename type::tuple_type<A15>::type>(&v.template get<15>());
 o.via.array.ptr[16].convert<typename type::tuple_type<A16>::type>(&v.template get<16>());
 o.via.array.ptr[17].convert<typename type::tuple_type<A17>::type>(&v.template get<17>());
 o.via.array.ptr[18].convert<typename type::tuple_type<A18>::type>(&v.template get<18>());
 o.via.array.ptr[19].convert<typename type::tuple_type<A19>::type>(&v.template get<19>());
 o.via.array.ptr[20].convert<typename type::tuple_type<A20>::type>(&v.template get<20>());
 o.via.array.ptr[21].convert<typename type::tuple_type<A21>::type>(&v.template get<21>());
 o.via.array.ptr[22].convert<typename type::tuple_type<A22>::type>(&v.template get<22>());
 o.via.array.ptr[23].convert<typename type::tuple_type<A23>::type>(&v.template get<23>());
 o.via.array.ptr[24].convert<typename type::tuple_type<A24>::type>(&v.template get<24>());
 o.via.array.ptr[25].convert<typename type::tuple_type<A25>::type>(&v.template get<25>());
 o.via.array.ptr[26].convert<typename type::tuple_type<A26>::type>(&v.template get<26>());
 o.via.array.ptr[27].convert<typename type::tuple_type<A27>::type>(&v.template get<27>());
 o.via.array.ptr[28].convert<typename type::tuple_type<A28>::type>(&v.template get<28>());
 o.via.array.ptr[29].convert<typename type::tuple_type<A29>::type>(&v.template get<29>());
 o.via.array.ptr[30].convert<typename type::tuple_type<A30>::type>(&v.template get<30>());
 o.via.array.ptr[31].convert<typename type::tuple_type<A31>::type>(&v.template get<31>());
 return v;
}


template <typename Stream>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<>& v) {
 o.pack_array(0);
 return o;
}

template <typename Stream, typename A0>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0>& v) {
 o.pack_array(1);

 o.pack(v.template get<0>());
 return o;
}

template <typename Stream, typename A0, typename A1>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1>& v) {
 o.pack_array(2);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2>& v) {
 o.pack_array(3);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3>& v) {
 o.pack_array(4);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4>& v) {
 o.pack_array(5);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5>& v) {
 o.pack_array(6);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6>& v) {
 o.pack_array(7);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7>& v) {
 o.pack_array(8);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& v) {
 o.pack_array(9);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& v) {
 o.pack_array(10);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& v) {
 o.pack_array(11);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& v) {
 o.pack_array(12);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& v) {
 o.pack_array(13);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& v) {
 o.pack_array(14);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& v) {
 o.pack_array(15);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& v) {
 o.pack_array(16);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& v) {
 o.pack_array(17);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& v) {
 o.pack_array(18);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& v) {
 o.pack_array(19);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& v) {
 o.pack_array(20);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& v) {
 o.pack_array(21);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& v) {
 o.pack_array(22);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& v) {
 o.pack_array(23);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& v) {
 o.pack_array(24);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& v) {
 o.pack_array(25);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& v) {
 o.pack_array(26);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 o.pack(v.template get<25>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& v) {
 o.pack_array(27);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 o.pack(v.template get<25>());
 o.pack(v.template get<26>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& v) {
 o.pack_array(28);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 o.pack(v.template get<25>());
 o.pack(v.template get<26>());
 o.pack(v.template get<27>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& v) {
 o.pack_array(29);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 o.pack(v.template get<25>());
 o.pack(v.template get<26>());
 o.pack(v.template get<27>());
 o.pack(v.template get<28>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& v) {
 o.pack_array(30);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 o.pack(v.template get<25>());
 o.pack(v.template get<26>());
 o.pack(v.template get<27>());
 o.pack(v.template get<28>());
 o.pack(v.template get<29>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& v) {
 o.pack_array(31);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 o.pack(v.template get<25>());
 o.pack(v.template get<26>());
 o.pack(v.template get<27>());
 o.pack(v.template get<28>());
 o.pack(v.template get<29>());
 o.pack(v.template get<30>());
 return o;
}

template <typename Stream, typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
const packer<Stream>& operator<< (
  packer<Stream>& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& v) {
 o.pack_array(32);

 o.pack(v.template get<0>());
 o.pack(v.template get<1>());
 o.pack(v.template get<2>());
 o.pack(v.template get<3>());
 o.pack(v.template get<4>());
 o.pack(v.template get<5>());
 o.pack(v.template get<6>());
 o.pack(v.template get<7>());
 o.pack(v.template get<8>());
 o.pack(v.template get<9>());
 o.pack(v.template get<10>());
 o.pack(v.template get<11>());
 o.pack(v.template get<12>());
 o.pack(v.template get<13>());
 o.pack(v.template get<14>());
 o.pack(v.template get<15>());
 o.pack(v.template get<16>());
 o.pack(v.template get<17>());
 o.pack(v.template get<18>());
 o.pack(v.template get<19>());
 o.pack(v.template get<20>());
 o.pack(v.template get<21>());
 o.pack(v.template get<22>());
 o.pack(v.template get<23>());
 o.pack(v.template get<24>());
 o.pack(v.template get<25>());
 o.pack(v.template get<26>());
 o.pack(v.template get<27>());
 o.pack(v.template get<28>());
 o.pack(v.template get<29>());
 o.pack(v.template get<30>());
 o.pack(v.template get<31>());
 return o;
}


inline void operator<< (
  object::with_zone& o,
  const type::tuple<>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = __null;
 o.via.array.size = 0;
}

template <typename A0>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*1);
 o.via.array.size = 1;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
}

template <typename A0, typename A1>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*2);
 o.via.array.size = 2;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
}

template <typename A0, typename A1, typename A2>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*3);
 o.via.array.size = 3;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*4);
 o.via.array.size = 4;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*5);
 o.via.array.size = 5;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*6);
 o.via.array.size = 6;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*7);
 o.via.array.size = 7;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*8);
 o.via.array.size = 8;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*9);
 o.via.array.size = 9;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*10);
 o.via.array.size = 10;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*11);
 o.via.array.size = 11;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*12);
 o.via.array.size = 12;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*13);
 o.via.array.size = 13;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*14);
 o.via.array.size = 14;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*15);
 o.via.array.size = 15;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*16);
 o.via.array.size = 16;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*17);
 o.via.array.size = 17;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*18);
 o.via.array.size = 18;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*19);
 o.via.array.size = 19;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*20);
 o.via.array.size = 20;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*21);
 o.via.array.size = 21;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*22);
 o.via.array.size = 22;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*23);
 o.via.array.size = 23;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*24);
 o.via.array.size = 24;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*25);
 o.via.array.size = 25;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*26);
 o.via.array.size = 26;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
 o.via.array.ptr[25] = object(v.template get<25>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*27);
 o.via.array.size = 27;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
 o.via.array.ptr[25] = object(v.template get<25>(), o.zone);
 o.via.array.ptr[26] = object(v.template get<26>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*28);
 o.via.array.size = 28;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
 o.via.array.ptr[25] = object(v.template get<25>(), o.zone);
 o.via.array.ptr[26] = object(v.template get<26>(), o.zone);
 o.via.array.ptr[27] = object(v.template get<27>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*29);
 o.via.array.size = 29;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
 o.via.array.ptr[25] = object(v.template get<25>(), o.zone);
 o.via.array.ptr[26] = object(v.template get<26>(), o.zone);
 o.via.array.ptr[27] = object(v.template get<27>(), o.zone);
 o.via.array.ptr[28] = object(v.template get<28>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*30);
 o.via.array.size = 30;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
 o.via.array.ptr[25] = object(v.template get<25>(), o.zone);
 o.via.array.ptr[26] = object(v.template get<26>(), o.zone);
 o.via.array.ptr[27] = object(v.template get<27>(), o.zone);
 o.via.array.ptr[28] = object(v.template get<28>(), o.zone);
 o.via.array.ptr[29] = object(v.template get<29>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*31);
 o.via.array.size = 31;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
 o.via.array.ptr[25] = object(v.template get<25>(), o.zone);
 o.via.array.ptr[26] = object(v.template get<26>(), o.zone);
 o.via.array.ptr[27] = object(v.template get<27>(), o.zone);
 o.via.array.ptr[28] = object(v.template get<28>(), o.zone);
 o.via.array.ptr[29] = object(v.template get<29>(), o.zone);
 o.via.array.ptr[30] = object(v.template get<30>(), o.zone);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
inline void operator<< (
  object::with_zone& o,
  const type::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>& v) {
 o.type = type::ARRAY;
 o.via.array.ptr = (object*)o.zone->malloc(sizeof(object)*32);
 o.via.array.size = 32;

 o.via.array.ptr[0] = object(v.template get<0>(), o.zone);
 o.via.array.ptr[1] = object(v.template get<1>(), o.zone);
 o.via.array.ptr[2] = object(v.template get<2>(), o.zone);
 o.via.array.ptr[3] = object(v.template get<3>(), o.zone);
 o.via.array.ptr[4] = object(v.template get<4>(), o.zone);
 o.via.array.ptr[5] = object(v.template get<5>(), o.zone);
 o.via.array.ptr[6] = object(v.template get<6>(), o.zone);
 o.via.array.ptr[7] = object(v.template get<7>(), o.zone);
 o.via.array.ptr[8] = object(v.template get<8>(), o.zone);
 o.via.array.ptr[9] = object(v.template get<9>(), o.zone);
 o.via.array.ptr[10] = object(v.template get<10>(), o.zone);
 o.via.array.ptr[11] = object(v.template get<11>(), o.zone);
 o.via.array.ptr[12] = object(v.template get<12>(), o.zone);
 o.via.array.ptr[13] = object(v.template get<13>(), o.zone);
 o.via.array.ptr[14] = object(v.template get<14>(), o.zone);
 o.via.array.ptr[15] = object(v.template get<15>(), o.zone);
 o.via.array.ptr[16] = object(v.template get<16>(), o.zone);
 o.via.array.ptr[17] = object(v.template get<17>(), o.zone);
 o.via.array.ptr[18] = object(v.template get<18>(), o.zone);
 o.via.array.ptr[19] = object(v.template get<19>(), o.zone);
 o.via.array.ptr[20] = object(v.template get<20>(), o.zone);
 o.via.array.ptr[21] = object(v.template get<21>(), o.zone);
 o.via.array.ptr[22] = object(v.template get<22>(), o.zone);
 o.via.array.ptr[23] = object(v.template get<23>(), o.zone);
 o.via.array.ptr[24] = object(v.template get<24>(), o.zone);
 o.via.array.ptr[25] = object(v.template get<25>(), o.zone);
 o.via.array.ptr[26] = object(v.template get<26>(), o.zone);
 o.via.array.ptr[27] = object(v.template get<27>(), o.zone);
 o.via.array.ptr[28] = object(v.template get<28>(), o.zone);
 o.via.array.ptr[29] = object(v.template get<29>(), o.zone);
 o.via.array.ptr[30] = object(v.template get<30>(), o.zone);
 o.via.array.ptr[31] = object(v.template get<31>(), o.zone);
}


}
# 15 "/usr/include/msgpack/type.hpp" 2 3 4
# 1 "/usr/include/msgpack/type/define.hpp" 1 3 4
# 37 "/usr/include/msgpack/type/define.hpp" 3 4
namespace msgpack {
namespace type {



template <typename A0 = void, typename A1 = void, typename A2 = void, typename A3 = void, typename A4 = void, typename A5 = void, typename A6 = void, typename A7 = void, typename A8 = void, typename A9 = void, typename A10 = void, typename A11 = void, typename A12 = void, typename A13 = void, typename A14 = void, typename A15 = void, typename A16 = void, typename A17 = void, typename A18 = void, typename A19 = void, typename A20 = void, typename A21 = void, typename A22 = void, typename A23 = void, typename A24 = void, typename A25 = void, typename A26 = void, typename A27 = void, typename A28 = void, typename A29 = void, typename A30 = void, typename A31 = void, typename A32 = void>
struct define;


template <>
struct define<> {
 typedef define<> value_type;
 typedef tuple<> tuple_type;
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(1);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = __null;
  o->via.array.size = 0;
 }
};

template <typename A0>
struct define<A0> {
 typedef define<A0> value_type;
 typedef tuple<A0> tuple_type;
 define(A0& _a0) :
  a0(_a0) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(1);

  pk.pack(a0);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*1);
  o->via.array.size = 1;

  o->via.array.ptr[0] = object(a0, z);
 }

 A0& a0;
};

template <typename A0, typename A1>
struct define<A0, A1> {
 typedef define<A0, A1> value_type;
 typedef tuple<A0, A1> tuple_type;
 define(A0& _a0, A1& _a1) :
  a0(_a0), a1(_a1) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(2);

  pk.pack(a0);
  pk.pack(a1);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*2);
  o->via.array.size = 2;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
 }

 A0& a0;
 A1& a1;
};

template <typename A0, typename A1, typename A2>
struct define<A0, A1, A2> {
 typedef define<A0, A1, A2> value_type;
 typedef tuple<A0, A1, A2> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2) :
  a0(_a0), a1(_a1), a2(_a2) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(3);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*3);
  o->via.array.size = 3;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
};

template <typename A0, typename A1, typename A2, typename A3>
struct define<A0, A1, A2, A3> {
 typedef define<A0, A1, A2, A3> value_type;
 typedef tuple<A0, A1, A2, A3> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(4);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*4);
  o->via.array.size = 4;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4>
struct define<A0, A1, A2, A3, A4> {
 typedef define<A0, A1, A2, A3, A4> value_type;
 typedef tuple<A0, A1, A2, A3, A4> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(5);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*5);
  o->via.array.size = 5;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
struct define<A0, A1, A2, A3, A4, A5> {
 typedef define<A0, A1, A2, A3, A4, A5> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(6);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*6);
  o->via.array.size = 6;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
struct define<A0, A1, A2, A3, A4, A5, A6> {
 typedef define<A0, A1, A2, A3, A4, A5, A6> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(7);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*7);
  o->via.array.size = 7;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
struct define<A0, A1, A2, A3, A4, A5, A6, A7> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(8);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*8);
  o->via.array.size = 8;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(9);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*9);
  o->via.array.size = 9;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(10);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*10);
  o->via.array.size = 10;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(11);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*11);
  o->via.array.size = 11;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(12);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*12);
  o->via.array.size = 12;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(13);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*13);
  o->via.array.size = 13;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(14);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*14);
  o->via.array.size = 14;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(15);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*15);
  o->via.array.size = 15;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(16);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*16);
  o->via.array.size = 16;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(17);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*17);
  o->via.array.size = 17;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(18);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*18);
  o->via.array.size = 18;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(19);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*19);
  o->via.array.size = 19;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(20);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*20);
  o->via.array.size = 20;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(21);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*21);
  o->via.array.size = 21;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(22);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*22);
  o->via.array.size = 22;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(23);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*23);
  o->via.array.size = 23;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(24);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*24);
  o->via.array.size = 24;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(25);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*25);
  o->via.array.size = 25;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24, A25& _a25) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(26);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
  pk.pack(a25);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
  if(size <= 25) { return; } o.via.array.ptr[25].convert(&a25);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*26);
  o->via.array.size = 26;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
  o->via.array.ptr[25] = object(a25, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
 A25& a25;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24, A25& _a25, A26& _a26) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(27);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
  pk.pack(a25);
  pk.pack(a26);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
  if(size <= 25) { return; } o.via.array.ptr[25].convert(&a25);
  if(size <= 26) { return; } o.via.array.ptr[26].convert(&a26);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*27);
  o->via.array.size = 27;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
  o->via.array.ptr[25] = object(a25, z);
  o->via.array.ptr[26] = object(a26, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
 A25& a25;
 A26& a26;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24, A25& _a25, A26& _a26, A27& _a27) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(28);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
  pk.pack(a25);
  pk.pack(a26);
  pk.pack(a27);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
  if(size <= 25) { return; } o.via.array.ptr[25].convert(&a25);
  if(size <= 26) { return; } o.via.array.ptr[26].convert(&a26);
  if(size <= 27) { return; } o.via.array.ptr[27].convert(&a27);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*28);
  o->via.array.size = 28;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
  o->via.array.ptr[25] = object(a25, z);
  o->via.array.ptr[26] = object(a26, z);
  o->via.array.ptr[27] = object(a27, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
 A25& a25;
 A26& a26;
 A27& a27;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24, A25& _a25, A26& _a26, A27& _a27, A28& _a28) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(29);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
  pk.pack(a25);
  pk.pack(a26);
  pk.pack(a27);
  pk.pack(a28);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
  if(size <= 25) { return; } o.via.array.ptr[25].convert(&a25);
  if(size <= 26) { return; } o.via.array.ptr[26].convert(&a26);
  if(size <= 27) { return; } o.via.array.ptr[27].convert(&a27);
  if(size <= 28) { return; } o.via.array.ptr[28].convert(&a28);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*29);
  o->via.array.size = 29;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
  o->via.array.ptr[25] = object(a25, z);
  o->via.array.ptr[26] = object(a26, z);
  o->via.array.ptr[27] = object(a27, z);
  o->via.array.ptr[28] = object(a28, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
 A25& a25;
 A26& a26;
 A27& a27;
 A28& a28;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24, A25& _a25, A26& _a26, A27& _a27, A28& _a28, A29& _a29) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28), a29(_a29) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(30);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
  pk.pack(a25);
  pk.pack(a26);
  pk.pack(a27);
  pk.pack(a28);
  pk.pack(a29);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
  if(size <= 25) { return; } o.via.array.ptr[25].convert(&a25);
  if(size <= 26) { return; } o.via.array.ptr[26].convert(&a26);
  if(size <= 27) { return; } o.via.array.ptr[27].convert(&a27);
  if(size <= 28) { return; } o.via.array.ptr[28].convert(&a28);
  if(size <= 29) { return; } o.via.array.ptr[29].convert(&a29);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*30);
  o->via.array.size = 30;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
  o->via.array.ptr[25] = object(a25, z);
  o->via.array.ptr[26] = object(a26, z);
  o->via.array.ptr[27] = object(a27, z);
  o->via.array.ptr[28] = object(a28, z);
  o->via.array.ptr[29] = object(a29, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
 A25& a25;
 A26& a26;
 A27& a27;
 A28& a28;
 A29& a29;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24, A25& _a25, A26& _a26, A27& _a27, A28& _a28, A29& _a29, A30& _a30) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28), a29(_a29), a30(_a30) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(31);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
  pk.pack(a25);
  pk.pack(a26);
  pk.pack(a27);
  pk.pack(a28);
  pk.pack(a29);
  pk.pack(a30);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
  if(size <= 25) { return; } o.via.array.ptr[25].convert(&a25);
  if(size <= 26) { return; } o.via.array.ptr[26].convert(&a26);
  if(size <= 27) { return; } o.via.array.ptr[27].convert(&a27);
  if(size <= 28) { return; } o.via.array.ptr[28].convert(&a28);
  if(size <= 29) { return; } o.via.array.ptr[29].convert(&a29);
  if(size <= 30) { return; } o.via.array.ptr[30].convert(&a30);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*31);
  o->via.array.size = 31;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
  o->via.array.ptr[25] = object(a25, z);
  o->via.array.ptr[26] = object(a26, z);
  o->via.array.ptr[27] = object(a27, z);
  o->via.array.ptr[28] = object(a28, z);
  o->via.array.ptr[29] = object(a29, z);
  o->via.array.ptr[30] = object(a30, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
 A25& a25;
 A26& a26;
 A27& a27;
 A28& a28;
 A29& a29;
 A30& a30;
};

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
struct define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31> {
 typedef define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31> value_type;
 typedef tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31> tuple_type;
 define(A0& _a0, A1& _a1, A2& _a2, A3& _a3, A4& _a4, A5& _a5, A6& _a6, A7& _a7, A8& _a8, A9& _a9, A10& _a10, A11& _a11, A12& _a12, A13& _a13, A14& _a14, A15& _a15, A16& _a16, A17& _a17, A18& _a18, A19& _a19, A20& _a20, A21& _a21, A22& _a22, A23& _a23, A24& _a24, A25& _a25, A26& _a26, A27& _a27, A28& _a28, A29& _a29, A30& _a30, A31& _a31) :
  a0(_a0), a1(_a1), a2(_a2), a3(_a3), a4(_a4), a5(_a5), a6(_a6), a7(_a7), a8(_a8), a9(_a9), a10(_a10), a11(_a11), a12(_a12), a13(_a13), a14(_a14), a15(_a15), a16(_a16), a17(_a17), a18(_a18), a19(_a19), a20(_a20), a21(_a21), a22(_a22), a23(_a23), a24(_a24), a25(_a25), a26(_a26), a27(_a27), a28(_a28), a29(_a29), a30(_a30), a31(_a31) {}
 template <typename Packer>
 void msgpack_pack(Packer& pk) const
 {
  pk.pack_array(32);

  pk.pack(a0);
  pk.pack(a1);
  pk.pack(a2);
  pk.pack(a3);
  pk.pack(a4);
  pk.pack(a5);
  pk.pack(a6);
  pk.pack(a7);
  pk.pack(a8);
  pk.pack(a9);
  pk.pack(a10);
  pk.pack(a11);
  pk.pack(a12);
  pk.pack(a13);
  pk.pack(a14);
  pk.pack(a15);
  pk.pack(a16);
  pk.pack(a17);
  pk.pack(a18);
  pk.pack(a19);
  pk.pack(a20);
  pk.pack(a21);
  pk.pack(a22);
  pk.pack(a23);
  pk.pack(a24);
  pk.pack(a25);
  pk.pack(a26);
  pk.pack(a27);
  pk.pack(a28);
  pk.pack(a29);
  pk.pack(a30);
  pk.pack(a31);
 }
 void msgpack_unpack(msgpack::object o)
 {
  if(o.type != type::ARRAY) { throw type_error(); }
  const size_t size = o.via.array.size;

  if(size <= 0) { return; } o.via.array.ptr[0].convert(&a0);
  if(size <= 1) { return; } o.via.array.ptr[1].convert(&a1);
  if(size <= 2) { return; } o.via.array.ptr[2].convert(&a2);
  if(size <= 3) { return; } o.via.array.ptr[3].convert(&a3);
  if(size <= 4) { return; } o.via.array.ptr[4].convert(&a4);
  if(size <= 5) { return; } o.via.array.ptr[5].convert(&a5);
  if(size <= 6) { return; } o.via.array.ptr[6].convert(&a6);
  if(size <= 7) { return; } o.via.array.ptr[7].convert(&a7);
  if(size <= 8) { return; } o.via.array.ptr[8].convert(&a8);
  if(size <= 9) { return; } o.via.array.ptr[9].convert(&a9);
  if(size <= 10) { return; } o.via.array.ptr[10].convert(&a10);
  if(size <= 11) { return; } o.via.array.ptr[11].convert(&a11);
  if(size <= 12) { return; } o.via.array.ptr[12].convert(&a12);
  if(size <= 13) { return; } o.via.array.ptr[13].convert(&a13);
  if(size <= 14) { return; } o.via.array.ptr[14].convert(&a14);
  if(size <= 15) { return; } o.via.array.ptr[15].convert(&a15);
  if(size <= 16) { return; } o.via.array.ptr[16].convert(&a16);
  if(size <= 17) { return; } o.via.array.ptr[17].convert(&a17);
  if(size <= 18) { return; } o.via.array.ptr[18].convert(&a18);
  if(size <= 19) { return; } o.via.array.ptr[19].convert(&a19);
  if(size <= 20) { return; } o.via.array.ptr[20].convert(&a20);
  if(size <= 21) { return; } o.via.array.ptr[21].convert(&a21);
  if(size <= 22) { return; } o.via.array.ptr[22].convert(&a22);
  if(size <= 23) { return; } o.via.array.ptr[23].convert(&a23);
  if(size <= 24) { return; } o.via.array.ptr[24].convert(&a24);
  if(size <= 25) { return; } o.via.array.ptr[25].convert(&a25);
  if(size <= 26) { return; } o.via.array.ptr[26].convert(&a26);
  if(size <= 27) { return; } o.via.array.ptr[27].convert(&a27);
  if(size <= 28) { return; } o.via.array.ptr[28].convert(&a28);
  if(size <= 29) { return; } o.via.array.ptr[29].convert(&a29);
  if(size <= 30) { return; } o.via.array.ptr[30].convert(&a30);
  if(size <= 31) { return; } o.via.array.ptr[31].convert(&a31);
 }
 void msgpack_object(msgpack::object* o, msgpack::zone* z) const
 {
  o->type = type::ARRAY;
  o->via.array.ptr = (object*)z->malloc(sizeof(object)*32);
  o->via.array.size = 32;

  o->via.array.ptr[0] = object(a0, z);
  o->via.array.ptr[1] = object(a1, z);
  o->via.array.ptr[2] = object(a2, z);
  o->via.array.ptr[3] = object(a3, z);
  o->via.array.ptr[4] = object(a4, z);
  o->via.array.ptr[5] = object(a5, z);
  o->via.array.ptr[6] = object(a6, z);
  o->via.array.ptr[7] = object(a7, z);
  o->via.array.ptr[8] = object(a8, z);
  o->via.array.ptr[9] = object(a9, z);
  o->via.array.ptr[10] = object(a10, z);
  o->via.array.ptr[11] = object(a11, z);
  o->via.array.ptr[12] = object(a12, z);
  o->via.array.ptr[13] = object(a13, z);
  o->via.array.ptr[14] = object(a14, z);
  o->via.array.ptr[15] = object(a15, z);
  o->via.array.ptr[16] = object(a16, z);
  o->via.array.ptr[17] = object(a17, z);
  o->via.array.ptr[18] = object(a18, z);
  o->via.array.ptr[19] = object(a19, z);
  o->via.array.ptr[20] = object(a20, z);
  o->via.array.ptr[21] = object(a21, z);
  o->via.array.ptr[22] = object(a22, z);
  o->via.array.ptr[23] = object(a23, z);
  o->via.array.ptr[24] = object(a24, z);
  o->via.array.ptr[25] = object(a25, z);
  o->via.array.ptr[26] = object(a26, z);
  o->via.array.ptr[27] = object(a27, z);
  o->via.array.ptr[28] = object(a28, z);
  o->via.array.ptr[29] = object(a29, z);
  o->via.array.ptr[30] = object(a30, z);
  o->via.array.ptr[31] = object(a31, z);
 }

 A0& a0;
 A1& a1;
 A2& a2;
 A3& a3;
 A4& a4;
 A5& a5;
 A6& a6;
 A7& a7;
 A8& a8;
 A9& a9;
 A10& a10;
 A11& a11;
 A12& a12;
 A13& a13;
 A14& a14;
 A15& a15;
 A16& a16;
 A17& a17;
 A18& a18;
 A19& a19;
 A20& a20;
 A21& a21;
 A22& a22;
 A23& a23;
 A24& a24;
 A25& a25;
 A26& a26;
 A27& a27;
 A28& a28;
 A29& a29;
 A30& a30;
 A31& a31;
};


inline define<> make_define()
{
 return define<>();
}

template <typename A0>
define<A0> make_define(A0& a0)
{
 return define<A0>(a0);
}

template <typename A0, typename A1>
define<A0, A1> make_define(A0& a0, A1& a1)
{
 return define<A0, A1>(a0, a1);
}

template <typename A0, typename A1, typename A2>
define<A0, A1, A2> make_define(A0& a0, A1& a1, A2& a2)
{
 return define<A0, A1, A2>(a0, a1, a2);
}

template <typename A0, typename A1, typename A2, typename A3>
define<A0, A1, A2, A3> make_define(A0& a0, A1& a1, A2& a2, A3& a3)
{
 return define<A0, A1, A2, A3>(a0, a1, a2, a3);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4>
define<A0, A1, A2, A3, A4> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4)
{
 return define<A0, A1, A2, A3, A4>(a0, a1, a2, a3, a4);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5>
define<A0, A1, A2, A3, A4, A5> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5)
{
 return define<A0, A1, A2, A3, A4, A5>(a0, a1, a2, a3, a4, a5);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
define<A0, A1, A2, A3, A4, A5, A6> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6)
{
 return define<A0, A1, A2, A3, A4, A5, A6>(a0, a1, a2, a3, a4, a5, a6);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
define<A0, A1, A2, A3, A4, A5, A6, A7> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7>(a0, a1, a2, a3, a4, a5, a6, a7);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8>(a0, a1, a2, a3, a4, a5, a6, a7, a8);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24, A25& a25)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24, A25& a25, A26& a26)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24, A25& a25, A26& a26, A27& a27)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24, A25& a25, A26& a26, A27& a27, A28& a28)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24, A25& a25, A26& a26, A27& a27, A28& a28, A29& a29)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24, A25& a25, A26& a26, A27& a27, A28& a28, A29& a29, A30& a30)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30);
}

template <typename A0, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21, typename A22, typename A23, typename A24, typename A25, typename A26, typename A27, typename A28, typename A29, typename A30, typename A31>
define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31> make_define(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5, A6& a6, A7& a7, A8& a8, A9& a9, A10& a10, A11& a11, A12& a12, A13& a13, A14& a14, A15& a15, A16& a16, A17& a17, A18& a18, A19& a19, A20& a20, A21& a21, A22& a22, A23& a23, A24& a24, A25& a25, A26& a26, A27& a27, A28& a28, A29& a29, A30& a30, A31& a31)
{
 return define<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31>(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31);
}


}
}
# 16 "/usr/include/msgpack/type.hpp" 2 3 4
# 410 "/usr/include/msgpack/object.hpp" 2 3 4
# 19 "/usr/include/msgpack.hpp" 2 3 4
# 1 "/usr/include/msgpack/zone.hpp" 1 3 4
# 20 "/usr/include/msgpack.hpp" 2 3 4
# 1 "/usr/include/msgpack/pack.hpp" 1 3 4
# 21 "/usr/include/msgpack.hpp" 2 3 4
# 1 "/usr/include/msgpack/unpack.hpp" 1 3 4
# 21 "/usr/include/msgpack/unpack.hpp" 3 4
# 1 "/usr/include/msgpack/unpack.h" 1 3 4
# 26 "/usr/include/msgpack/unpack.h" 3 4
extern "C" {
# 36 "/usr/include/msgpack/unpack.h" 3 4
typedef struct msgpack_unpacked {
 msgpack_zone* zone;
 msgpack_object data;
} msgpack_unpacked;

bool msgpack_unpack_next(msgpack_unpacked* result,
  const char* data, size_t len, size_t* off);
# 53 "/usr/include/msgpack/unpack.h" 3 4
typedef struct msgpack_unpacker {
 char* buffer;
 size_t used;
 size_t free;
 size_t off;
 size_t parsed;
 msgpack_zone* z;
 size_t initial_buffer_size;
 void* ctx;
} msgpack_unpacker;
# 73 "/usr/include/msgpack/unpack.h" 3 4
bool msgpack_unpacker_init(msgpack_unpacker* mpac, size_t initial_buffer_size);




void msgpack_unpacker_destroy(msgpack_unpacker* mpac);






msgpack_unpacker* msgpack_unpacker_new(size_t initial_buffer_size);




void msgpack_unpacker_free(msgpack_unpacker* mpac);
# 104 "/usr/include/msgpack/unpack.h" 3 4
static inline bool msgpack_unpacker_reserve_buffer(msgpack_unpacker* mpac, size_t size);
# 113 "/usr/include/msgpack/unpack.h" 3 4
static inline char* msgpack_unpacker_buffer(msgpack_unpacker* mpac);
# 122 "/usr/include/msgpack/unpack.h" 3 4
static inline size_t msgpack_unpacker_buffer_capacity(const msgpack_unpacker* mpac);
# 131 "/usr/include/msgpack/unpack.h" 3 4
static inline void msgpack_unpacker_buffer_consumed(msgpack_unpacker* mpac, size_t size);







bool msgpack_unpacker_next(msgpack_unpacker* mpac, msgpack_unpacked* pac);







static inline void msgpack_unpacked_init(msgpack_unpacked* result);




static inline void msgpack_unpacked_destroy(msgpack_unpacked* result);





static inline msgpack_zone* msgpack_unpacked_release_zone(msgpack_unpacked* result);


int msgpack_unpacker_execute(msgpack_unpacker* mpac);

msgpack_object msgpack_unpacker_data(msgpack_unpacker* mpac);

msgpack_zone* msgpack_unpacker_release_zone(msgpack_unpacker* mpac);

void msgpack_unpacker_reset_zone(msgpack_unpacker* mpac);

void msgpack_unpacker_reset(msgpack_unpacker* mpac);

static inline size_t msgpack_unpacker_message_size(const msgpack_unpacker* mpac);






typedef enum {
 MSGPACK_UNPACK_SUCCESS = 2,
 MSGPACK_UNPACK_EXTRA_BYTES = 1,
 MSGPACK_UNPACK_CONTINUE = 0,
 MSGPACK_UNPACK_PARSE_ERROR = -1,
} msgpack_unpack_return;


msgpack_unpack_return
msgpack_unpack(const char* data, size_t len, size_t* off,
  msgpack_zone* result_zone, msgpack_object* result);


static inline size_t msgpack_unpacker_parsed_size(const msgpack_unpacker* mpac);

bool msgpack_unpacker_flush_zone(msgpack_unpacker* mpac);

bool msgpack_unpacker_expand_buffer(msgpack_unpacker* mpac, size_t size);

bool msgpack_unpacker_reserve_buffer(msgpack_unpacker* mpac, size_t size)
{
 if(mpac->free >= size) { return true; }
 return msgpack_unpacker_expand_buffer(mpac, size);
}

char* msgpack_unpacker_buffer(msgpack_unpacker* mpac)
{
 return mpac->buffer + mpac->used;
}

size_t msgpack_unpacker_buffer_capacity(const msgpack_unpacker* mpac)
{
 return mpac->free;
}

void msgpack_unpacker_buffer_consumed(msgpack_unpacker* mpac, size_t size)
{
 mpac->used += size;
 mpac->free -= size;
}

size_t msgpack_unpacker_message_size(const msgpack_unpacker* mpac)
{
 return mpac->parsed - mpac->off + mpac->used;
}

size_t msgpack_unpacker_parsed_size(const msgpack_unpacker* mpac)
{
 return mpac->parsed;
}


void msgpack_unpacked_init(msgpack_unpacked* result)
{
 memset(result, 0, sizeof(msgpack_unpacked));
}

void msgpack_unpacked_destroy(msgpack_unpacked* result)
{
 if(result->zone != __null) {
  msgpack_zone_free(result->zone);
  result->zone = __null;
  memset(&result->data, 0, sizeof(msgpack_object));
 }
}

msgpack_zone* msgpack_unpacked_release_zone(msgpack_unpacked* result)
{
 if(result->zone != __null) {
  msgpack_zone* z = result->zone;
  result->zone = __null;
  return z;
 }
 return __null;
}



}
# 22 "/usr/include/msgpack/unpack.hpp" 2 3 4
# 1 "/usr/include/msgpack/object.hpp" 1 3 4
# 23 "/usr/include/msgpack/unpack.hpp" 2 3 4
# 32 "/usr/include/msgpack/unpack.hpp" 3 4
namespace msgpack {


struct unpack_error : public std::runtime_error {
 unpack_error(const std::string& msg) :
  std::runtime_error(msg) { }
};


class unpacked {
public:
 unpacked() { }

 unpacked(object obj, std::auto_ptr<msgpack::zone> z) :
  m_obj(obj), m_zone(z) { }

 object& get()
  { return m_obj; }

 const object& get() const
  { return m_obj; }

 std::auto_ptr<msgpack::zone>& zone()
  { return m_zone; }

 const std::auto_ptr<msgpack::zone>& zone() const
  { return m_zone; }

private:
 object m_obj;
 std::auto_ptr<msgpack::zone> m_zone;
};


class unpacker : public msgpack_unpacker {
public:
 unpacker(size_t init_buffer_size = (64*1024));
 ~unpacker();

public:

 void reserve_buffer(size_t size = (32*1024));


 char* buffer();
 size_t buffer_capacity() const;


 void buffer_consumed(size_t size);


 bool next(unpacked* result);


 size_t message_size() const;
# 125 "/usr/include/msgpack/unpack.hpp" 3 4
 bool execute();


 object data();


 zone* release_zone();


 void reset_zone();


 void reset();

public:


 size_t parsed_size() const;


 char* nonparsed_buffer();
 size_t nonparsed_size() const;



 void skip_nonparsed_buffer(size_t size);



 void remove_nonparsed_buffer();

private:
 typedef msgpack_unpacker base;

private:
 unpacker(const unpacker&);
};


static void unpack(unpacked* result,
  const char* data, size_t len, size_t* offset = __null);



typedef enum {
 UNPACK_SUCCESS = 2,
 UNPACK_EXTRA_BYTES = 1,
 UNPACK_CONTINUE = 0,
 UNPACK_PARSE_ERROR = -1,
} unpack_return;


static unpack_return unpack(const char* data, size_t len, size_t* off,
  zone* z, object* result);



static object unpack(const char* data, size_t len, zone& z, size_t* off = __null);


inline unpacker::unpacker(size_t initial_buffer_size)
{
 if(!msgpack_unpacker_init(this, initial_buffer_size)) {
  throw std::bad_alloc();
 }
}

inline unpacker::~unpacker()
{
 msgpack_unpacker_destroy(this);
}


inline void unpacker::reserve_buffer(size_t size)
{
 if(!msgpack_unpacker_reserve_buffer(this, size)) {
  throw std::bad_alloc();
 }
}

inline char* unpacker::buffer()
{
 return msgpack_unpacker_buffer(this);
}

inline size_t unpacker::buffer_capacity() const
{
 return msgpack_unpacker_buffer_capacity(this);
}

inline void unpacker::buffer_consumed(size_t size)
{
 return msgpack_unpacker_buffer_consumed(this, size);
}

inline bool unpacker::next(unpacked* result)
{
 int ret = msgpack_unpacker_execute(this);

 if(ret < 0) {
  throw unpack_error("parse error");
 }

 if(ret == 0) {
  result->zone().reset();
  result->get() = object();
  return false;

 } else {
  result->zone().reset( release_zone() );
  result->get() = data();
  reset();
  return true;
 }
}


inline bool unpacker::execute()
{
 int ret = msgpack_unpacker_execute(this);
 if(ret < 0) {
  throw unpack_error("parse error");
 } else if(ret == 0) {
  return false;
 } else {
  return true;
 }
}

inline object unpacker::data()
{
 return msgpack_unpacker_data(this);
}

inline zone* unpacker::release_zone()
{
 if(!msgpack_unpacker_flush_zone(this)) {
  throw std::bad_alloc();
 }

 zone* r = new zone();

 msgpack_zone old = *base::z;
 *base::z = *r;
 *static_cast<msgpack_zone*>(r) = old;

 return r;
}

inline void unpacker::reset_zone()
{
 msgpack_unpacker_reset_zone(this);
}

inline void unpacker::reset()
{
 msgpack_unpacker_reset(this);
}


inline size_t unpacker::message_size() const
{
 return msgpack_unpacker_message_size(this);
}

inline size_t unpacker::parsed_size() const
{
 return msgpack_unpacker_parsed_size(this);
}

inline char* unpacker::nonparsed_buffer()
{
 return base::buffer + base::off;
}

inline size_t unpacker::nonparsed_size() const
{
 return base::used - base::off;
}

inline void unpacker::skip_nonparsed_buffer(size_t size)
{
 base::off += size;
}

inline void unpacker::remove_nonparsed_buffer()
{
 base::used = base::off;
}


inline void unpack(unpacked* result,
  const char* data, size_t len, size_t* offset)
{
 msgpack::object obj;
 std::auto_ptr<msgpack::zone> z(new zone());

 unpack_return ret = (unpack_return)msgpack_unpack(
   data, len, offset, z.get(),
   reinterpret_cast<msgpack_object*>(&obj));

 switch(ret) {
 case UNPACK_SUCCESS:
  result->get() = obj;
  result->zone() = z;
  return;

 case UNPACK_EXTRA_BYTES:
  result->get() = obj;
  result->zone() = z;
  return;

 case UNPACK_CONTINUE:
  throw unpack_error("insufficient bytes");

 case UNPACK_PARSE_ERROR:
 default:
  throw unpack_error("parse error");
 }
}



inline unpack_return unpack(const char* data, size_t len, size_t* off,
  zone* z, object* result)
{
 return (unpack_return)msgpack_unpack(data, len, off,
   z, reinterpret_cast<msgpack_object*>(result));
}


inline object unpack(const char* data, size_t len, zone& z, size_t* off)
{
 object result;

 switch( msgpack::unpack(data, len, off, &z, &result) ) {
 case UNPACK_SUCCESS:
  return result;

 case UNPACK_EXTRA_BYTES:
  if(off) {
   return result;
  } else {
   throw unpack_error("extra bytes");
  }

 case UNPACK_CONTINUE:
  throw unpack_error("insufficient bytes");

 case UNPACK_PARSE_ERROR:
 default:
  throw unpack_error("parse error");
 }
}


}
# 22 "/usr/include/msgpack.hpp" 2 3 4
# 1 "/usr/include/msgpack/sbuffer.hpp" 1 3 4
# 21 "/usr/include/msgpack/sbuffer.hpp" 3 4
# 1 "/usr/include/msgpack/sbuffer.h" 1 3 4
# 25 "/usr/include/msgpack/sbuffer.h" 3 4
extern "C" {
# 35 "/usr/include/msgpack/sbuffer.h" 3 4
typedef struct msgpack_sbuffer {
 size_t size;
 char* data;
 size_t alloc;
} msgpack_sbuffer;

static inline void msgpack_sbuffer_init(msgpack_sbuffer* sbuf)
{
 memset(sbuf, 0, sizeof(msgpack_sbuffer));
}

static inline void msgpack_sbuffer_destroy(msgpack_sbuffer* sbuf)
{
 free(sbuf->data);
}

static inline msgpack_sbuffer* msgpack_sbuffer_new(void)
{
 return (msgpack_sbuffer*)calloc(1, sizeof(msgpack_sbuffer));
}

static inline void msgpack_sbuffer_free(msgpack_sbuffer* sbuf)
{
 if(sbuf == __null) { return; }
 msgpack_sbuffer_destroy(sbuf);
 free(sbuf);
}





static inline int msgpack_sbuffer_write(void* data, const char* buf, unsigned int len)
{
 msgpack_sbuffer* sbuf = (msgpack_sbuffer*)data;

 if(sbuf->alloc - sbuf->size < len) {
  size_t nsize = (sbuf->alloc) ?
    sbuf->alloc * 2 : 8192;

  while(nsize < sbuf->size + len) { nsize *= 2; }

  void* tmp = realloc(sbuf->data, nsize);
  if(!tmp) { return -1; }

  sbuf->data = (char*)tmp;
  sbuf->alloc = nsize;
 }

 memcpy(sbuf->data + sbuf->size, buf, len);
 sbuf->size += len;
 return 0;
}

static inline char* msgpack_sbuffer_release(msgpack_sbuffer* sbuf)
{
 char* tmp = sbuf->data;
 sbuf->size = 0;
 sbuf->data = __null;
 sbuf->alloc = 0;
 return tmp;
}

static inline void msgpack_sbuffer_clear(msgpack_sbuffer* sbuf)
{
 sbuf->size = 0;
}





}
# 22 "/usr/include/msgpack/sbuffer.hpp" 2 3 4


namespace msgpack {


class sbuffer : public msgpack_sbuffer {
public:
 sbuffer(size_t initsz = 8192)
 {
  base::data = (char*)::malloc(initsz);
  if(!base::data) {
   throw std::bad_alloc();
  }

  base::size = 0;
  base::alloc = initsz;
 }

 ~sbuffer()
 {
  ::free(base::data);
 }

public:
 void write(const char* buf, unsigned int len)
 {
  if(base::alloc - base::size < len) {
   expand_buffer(len);
  }
  memcpy(base::data + base::size, buf, len);
  base::size += len;
 }

 char* data()
 {
  return base::data;
 }

 const char* data() const
 {
  return base::data;
 }

 size_t size() const
 {
  return base::size;
 }

 char* release()
 {
  return msgpack_sbuffer_release(this);
 }

 void clear()
 {
  msgpack_sbuffer_clear(this);
 }

private:
 void expand_buffer(size_t len)
 {
  size_t nsize = (base::alloc) ?
    base::alloc * 2 : 8192;

  while(nsize < base::size + len) { nsize *= 2; }

  void* tmp = realloc(base::data, nsize);
  if(!tmp) {
   throw std::bad_alloc();
  }

  base::data = (char*)tmp;
  base::alloc = nsize;
 }

private:
 typedef msgpack_sbuffer base;

private:
 sbuffer(const sbuffer&);
};


}
# 23 "/usr/include/msgpack.hpp" 2 3 4
# 1 "/usr/include/msgpack/vrefbuffer.hpp" 1 3 4
# 21 "/usr/include/msgpack/vrefbuffer.hpp" 3 4
# 1 "/usr/include/msgpack/vrefbuffer.h" 1 3 4
# 34 "/usr/include/msgpack/vrefbuffer.h" 3 4
extern "C" {
# 44 "/usr/include/msgpack/vrefbuffer.h" 3 4
struct msgpack_vrefbuffer_chunk;
typedef struct msgpack_vrefbuffer_chunk msgpack_vrefbuffer_chunk;

typedef struct msgpack_vrefbuffer_inner_buffer {
 size_t free;
 char* ptr;
 msgpack_vrefbuffer_chunk* head;
} msgpack_vrefbuffer_inner_buffer;

typedef struct msgpack_vrefbuffer {
 struct iovec* tail;
 struct iovec* end;
 struct iovec* array;

 size_t chunk_size;
 size_t ref_size;

 msgpack_vrefbuffer_inner_buffer inner_buffer;
} msgpack_vrefbuffer;
# 73 "/usr/include/msgpack/vrefbuffer.h" 3 4
bool msgpack_vrefbuffer_init(msgpack_vrefbuffer* vbuf,
  size_t ref_size, size_t chunk_size);
void msgpack_vrefbuffer_destroy(msgpack_vrefbuffer* vbuf);

static inline msgpack_vrefbuffer* msgpack_vrefbuffer_new(size_t ref_size, size_t chunk_size);
static inline void msgpack_vrefbuffer_free(msgpack_vrefbuffer* vbuf);

static inline int msgpack_vrefbuffer_write(void* data, const char* buf, unsigned int len);

static inline const struct iovec* msgpack_vrefbuffer_vec(const msgpack_vrefbuffer* vref);
static inline size_t msgpack_vrefbuffer_veclen(const msgpack_vrefbuffer* vref);

int msgpack_vrefbuffer_append_copy(msgpack_vrefbuffer* vbuf,
  const char* buf, unsigned int len);

int msgpack_vrefbuffer_append_ref(msgpack_vrefbuffer* vbuf,
  const char* buf, unsigned int len);

int msgpack_vrefbuffer_migrate(msgpack_vrefbuffer* vbuf, msgpack_vrefbuffer* to);

void msgpack_vrefbuffer_clear(msgpack_vrefbuffer* vref);




msgpack_vrefbuffer* msgpack_vrefbuffer_new(size_t ref_size, size_t chunk_size)
{
 msgpack_vrefbuffer* vbuf = (msgpack_vrefbuffer*)malloc(sizeof(msgpack_vrefbuffer));
 if(!msgpack_vrefbuffer_init(vbuf, ref_size, chunk_size)) {
  free(vbuf);
  return __null;
 }
 return vbuf;
}

void msgpack_vrefbuffer_free(msgpack_vrefbuffer* vbuf)
{
 if(vbuf == __null) { return; }
 msgpack_vrefbuffer_destroy(vbuf);
 free(vbuf);
}

int msgpack_vrefbuffer_write(void* data, const char* buf, unsigned int len)
{
 msgpack_vrefbuffer* vbuf = (msgpack_vrefbuffer*)data;

 if(len < vbuf->ref_size) {
  return msgpack_vrefbuffer_append_copy(vbuf, buf, len);
 } else {
  return msgpack_vrefbuffer_append_ref(vbuf, buf, len);
 }
}

const struct iovec* msgpack_vrefbuffer_vec(const msgpack_vrefbuffer* vref)
{
 return vref->array;
}

size_t msgpack_vrefbuffer_veclen(const msgpack_vrefbuffer* vref)
{
 return vref->tail - vref->array;
}



}
# 22 "/usr/include/msgpack/vrefbuffer.hpp" 2 3 4


namespace msgpack {


class vrefbuffer : public msgpack_vrefbuffer {
public:
 vrefbuffer(size_t ref_size = 32,
   size_t chunk_size = 8192)
 {
  msgpack_vrefbuffer_init(this, ref_size, chunk_size);
 }

 ~vrefbuffer()
 {
  msgpack_vrefbuffer_destroy(this);
 }

public:
 void write(const char* buf, unsigned int len)
 {
  if(len < base::ref_size) {
   append_copy(buf, len);
  } else {
   append_ref(buf, len);
  }
 }

 void append_ref(const char* buf, size_t len)
 {
  if(msgpack_vrefbuffer_append_ref(this, buf, len) < 0) {
   throw std::bad_alloc();
  }
 }

 void append_copy(const char* buf, size_t len)
 {
  if(msgpack_vrefbuffer_append_copy(this, buf, len) < 0) {
   throw std::bad_alloc();
  }
 }

 const struct iovec* vector() const
 {
  return msgpack_vrefbuffer_vec(this);
 }

 size_t vector_size() const
 {
  return msgpack_vrefbuffer_veclen(this);
 }

 void migrate(vrefbuffer* to)
 {
  if(msgpack_vrefbuffer_migrate(this, to) < 0) {
   throw std::bad_alloc();
  }
 }

 void clear()
 {
  msgpack_vrefbuffer_clear(this);
 }

private:
 typedef msgpack_vrefbuffer base;

private:
 vrefbuffer(const vrefbuffer&);
};


}
# 24 "/usr/include/msgpack.hpp" 2 3 4
# 1 "/usr/include/msgpack.h" 1 3 4
# 23 "/usr/include/msgpack.h" 3 4
# 1 "/usr/include/msgpack/object.h" 1 3 4
# 24 "/usr/include/msgpack.h" 2 3 4
# 1 "/usr/include/msgpack/zone.h" 1 3 4
# 25 "/usr/include/msgpack.h" 2 3 4
# 1 "/usr/include/msgpack/pack.h" 1 3 4
# 26 "/usr/include/msgpack/pack.h" 3 4
extern "C" {
# 43 "/usr/include/msgpack/pack.h" 3 4
typedef int (*msgpack_packer_write)(void* data, const char* buf, unsigned int len);

typedef struct msgpack_packer {
 void* data;
 msgpack_packer_write callback;
} msgpack_packer;

static void msgpack_packer_init(msgpack_packer* pk, void* data, msgpack_packer_write callback);

static msgpack_packer* msgpack_packer_new(void* data, msgpack_packer_write callback);
static void msgpack_packer_free(msgpack_packer* pk);

static int msgpack_pack_short(msgpack_packer* pk, short d);
static int msgpack_pack_int(msgpack_packer* pk, int d);
static int msgpack_pack_long(msgpack_packer* pk, long d);
static int msgpack_pack_long_long(msgpack_packer* pk, long long d);
static int msgpack_pack_unsigned_short(msgpack_packer* pk, unsigned short d);
static int msgpack_pack_unsigned_int(msgpack_packer* pk, unsigned int d);
static int msgpack_pack_unsigned_long(msgpack_packer* pk, unsigned long d);
static int msgpack_pack_unsigned_long_long(msgpack_packer* pk, unsigned long long d);

static int msgpack_pack_uint8(msgpack_packer* pk, uint8_t d);
static int msgpack_pack_uint16(msgpack_packer* pk, uint16_t d);
static int msgpack_pack_uint32(msgpack_packer* pk, uint32_t d);
static int msgpack_pack_uint64(msgpack_packer* pk, uint64_t d);
static int msgpack_pack_int8(msgpack_packer* pk, int8_t d);
static int msgpack_pack_int16(msgpack_packer* pk, int16_t d);
static int msgpack_pack_int32(msgpack_packer* pk, int32_t d);
static int msgpack_pack_int64(msgpack_packer* pk, int64_t d);

static int msgpack_pack_fix_uint8(msgpack_packer* pk, uint8_t d);
static int msgpack_pack_fix_uint16(msgpack_packer* pk, uint16_t d);
static int msgpack_pack_fix_uint32(msgpack_packer* pk, uint32_t d);
static int msgpack_pack_fix_uint64(msgpack_packer* pk, uint64_t d);
static int msgpack_pack_fix_int8(msgpack_packer* pk, int8_t d);
static int msgpack_pack_fix_int16(msgpack_packer* pk, int16_t d);
static int msgpack_pack_fix_int32(msgpack_packer* pk, int32_t d);
static int msgpack_pack_fix_int64(msgpack_packer* pk, int64_t d);

static int msgpack_pack_float(msgpack_packer* pk, float d);
static int msgpack_pack_double(msgpack_packer* pk, double d);

static int msgpack_pack_nil(msgpack_packer* pk);
static int msgpack_pack_true(msgpack_packer* pk);
static int msgpack_pack_false(msgpack_packer* pk);

static int msgpack_pack_array(msgpack_packer* pk, unsigned int n);

static int msgpack_pack_map(msgpack_packer* pk, unsigned int n);

static int msgpack_pack_raw(msgpack_packer* pk, size_t l);
static int msgpack_pack_raw_body(msgpack_packer* pk, const void* b, size_t l);

int msgpack_pack_object(msgpack_packer* pk, msgpack_object d);
# 119 "/usr/include/msgpack/pack.h" 3 4
# 1 "/usr/include/msgpack/pack_template.h" 1 3 4
# 277 "/usr/include/msgpack/pack_template.h" 3 4
inline int msgpack_pack_fix_uint8(msgpack_packer* x, uint8_t d)
{
 unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]};
 return (*(x)->callback)((x)->data, (const char*)buf, 2);
}

inline int msgpack_pack_fix_uint16(msgpack_packer* x, uint16_t d)
{
 unsigned char buf[3];
 buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 3);
}

inline int msgpack_pack_fix_uint32(msgpack_packer* x, uint32_t d)
{
 unsigned char buf[5];
 buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_fix_uint64(msgpack_packer* x, uint64_t d)
{
 unsigned char buf[9];
 buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 9);
}

inline int msgpack_pack_fix_int8(msgpack_packer* x, int8_t d)
{
 unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]};
 return (*(x)->callback)((x)->data, (const char*)buf, 2);
}

inline int msgpack_pack_fix_int16(msgpack_packer* x, int16_t d)
{
 unsigned char buf[3];
 buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 3);
}

inline int msgpack_pack_fix_int32(msgpack_packer* x, int32_t d)
{
 unsigned char buf[5];
 buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_fix_int64(msgpack_packer* x, int64_t d)
{
 unsigned char buf[9];
 buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 9);
}





inline int msgpack_pack_uint8(msgpack_packer* x, uint8_t d)
{
 do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } while(0);
}

inline int msgpack_pack_uint16(msgpack_packer* x, uint16_t d)
{
 do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } } while(0);
}

inline int msgpack_pack_uint32(msgpack_packer* x, uint32_t d)
{
 do { if(d < (1<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
}

inline int msgpack_pack_uint64(msgpack_packer* x, uint64_t d)
{
 do { if(d < (1ULL<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
}

inline int msgpack_pack_int8(msgpack_packer* x, int8_t d)
{
 do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } } while(0);
}

inline int msgpack_pack_int16(msgpack_packer* x, int16_t d)
{
 do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } } } while(0);
}

inline int msgpack_pack_int32(msgpack_packer* x, int32_t d)
{
 do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
}

inline int msgpack_pack_int64(msgpack_packer* x, int64_t d)
{
 do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
}




inline int msgpack_pack_short(msgpack_packer* x, short d)
{
# 391 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } } } while(0);
# 407 "/usr/include/msgpack/pack_template.h" 3 4
}

inline int msgpack_pack_int(msgpack_packer* x, int d)
{
# 424 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
# 438 "/usr/include/msgpack/pack_template.h" 3 4
}

inline int msgpack_pack_long(msgpack_packer* x, long d)
{
# 457 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
# 469 "/usr/include/msgpack/pack_template.h" 3 4
}

inline int msgpack_pack_long_long(msgpack_packer* x, long long d)
{
# 488 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
# 500 "/usr/include/msgpack/pack_template.h" 3 4
}

inline int msgpack_pack_unsigned_short(msgpack_packer* x, unsigned short d)
{
# 515 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } } while(0);
# 531 "/usr/include/msgpack/pack_template.h" 3 4
}

inline int msgpack_pack_unsigned_int(msgpack_packer* x, unsigned int d)
{
# 548 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
# 562 "/usr/include/msgpack/pack_template.h" 3 4
}

inline int msgpack_pack_unsigned_long(msgpack_packer* x, unsigned long d)
{
# 581 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1ULL<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
# 593 "/usr/include/msgpack/pack_template.h" 3 4
}

inline int msgpack_pack_unsigned_long_long(msgpack_packer* x, unsigned long long d)
{
# 612 "/usr/include/msgpack/pack_template.h" 3 4
 do { if(d < (1ULL<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = ntohs(d); memcpy(&buf[1], &val, 2); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = ntohl(d); memcpy(&buf[1], &val, 4); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = ( ((((uint64_t)d) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)d) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)d) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)d) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)d) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)d) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)d) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)d) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);; return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
# 624 "/usr/include/msgpack/pack_template.h" 3 4
}
# 635 "/usr/include/msgpack/pack_template.h" 3 4
inline int msgpack_pack_float(msgpack_packer* x, float d)
{
 union { float f; uint32_t i; } mem;
 mem.f = d;
 unsigned char buf[5];
 buf[0] = 0xca; do { uint32_t val = ntohl(mem.i); memcpy(&buf[1], &val, 4); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_double(msgpack_packer* x, double d)
{
 union { double f; uint64_t i; } mem;
 mem.f = d;
 unsigned char buf[9];
 buf[0] = 0xcb; do { uint64_t val = ( ((((uint64_t)mem.i) << 56) & 0xff00000000000000ULL ) | ((((uint64_t)mem.i) << 40) & 0x00ff000000000000ULL ) | ((((uint64_t)mem.i) << 24) & 0x0000ff0000000000ULL ) | ((((uint64_t)mem.i) << 8) & 0x000000ff00000000ULL ) | ((((uint64_t)mem.i) >> 8) & 0x00000000ff000000ULL ) | ((((uint64_t)mem.i) >> 24) & 0x0000000000ff0000ULL ) | ((((uint64_t)mem.i) >> 40) & 0x000000000000ff00ULL ) | ((((uint64_t)mem.i) >> 56) & 0x00000000000000ffULL ) ); memcpy(&buf[1], &val, 8); } while(0);;
 return (*(x)->callback)((x)->data, (const char*)buf, 9);
}






inline int msgpack_pack_nil(msgpack_packer* x)
{
 static const unsigned char d = 0xc0;
 return (*(x)->callback)((x)->data, (const char*)&d, 1);
}






inline int msgpack_pack_true(msgpack_packer* x)
{
 static const unsigned char d = 0xc3;
 return (*(x)->callback)((x)->data, (const char*)&d, 1);
}

inline int msgpack_pack_false(msgpack_packer* x)
{
 static const unsigned char d = 0xc2;
 return (*(x)->callback)((x)->data, (const char*)&d, 1);
}






inline int msgpack_pack_array(msgpack_packer* x, unsigned int n)
{
 if(n < 16) {
  unsigned char d = 0x90 | n;
  return (*(x)->callback)((x)->data, (const char*)&d, 1);
 } else if(n < 65536) {
  unsigned char buf[3];
  buf[0] = 0xdc; do { uint16_t val = ntohs(n); memcpy(&buf[1], &val, 2); } while(0);;
  return (*(x)->callback)((x)->data, (const char*)buf, 3);
 } else {
  unsigned char buf[5];
  buf[0] = 0xdd; do { uint32_t val = ntohl(n); memcpy(&buf[1], &val, 4); } while(0);;
  return (*(x)->callback)((x)->data, (const char*)buf, 5);
 }
}






inline int msgpack_pack_map(msgpack_packer* x, unsigned int n)
{
 if(n < 16) {
  unsigned char d = 0x80 | n;
  return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
 } else if(n < 65536) {
  unsigned char buf[3];
  buf[0] = 0xde; do { uint16_t val = ntohs(n); memcpy(&buf[1], &val, 2); } while(0);;
  return (*(x)->callback)((x)->data, (const char*)buf, 3);
 } else {
  unsigned char buf[5];
  buf[0] = 0xdf; do { uint32_t val = ntohl(n); memcpy(&buf[1], &val, 4); } while(0);;
  return (*(x)->callback)((x)->data, (const char*)buf, 5);
 }
}






inline int msgpack_pack_raw(msgpack_packer* x, size_t l)
{
 if(l < 32) {
  unsigned char d = 0xa0 | l;
  return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
 } else if(l < 65536) {
  unsigned char buf[3];
  buf[0] = 0xda; do { uint16_t val = ntohs(l); memcpy(&buf[1], &val, 2); } while(0);;
  return (*(x)->callback)((x)->data, (const char*)buf, 3);
 } else {
  unsigned char buf[5];
  buf[0] = 0xdb; do { uint32_t val = ntohl(l); memcpy(&buf[1], &val, 4); } while(0);;
  return (*(x)->callback)((x)->data, (const char*)buf, 5);
 }
}

inline int msgpack_pack_raw_body(msgpack_packer* x, const void* b, size_t l)
{
 return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}
# 120 "/usr/include/msgpack/pack.h" 2 3 4

inline void msgpack_packer_init(msgpack_packer* pk, void* data, msgpack_packer_write callback)
{
 pk->data = data;
 pk->callback = callback;
}

inline msgpack_packer* msgpack_packer_new(void* data, msgpack_packer_write callback)
{
 msgpack_packer* pk = (msgpack_packer*)calloc(1, sizeof(msgpack_packer));
 if(!pk) { return __null; }
 msgpack_packer_init(pk, data, callback);
 return pk;
}

inline void msgpack_packer_free(msgpack_packer* pk)
{
 free(pk);
}



}
# 26 "/usr/include/msgpack.h" 2 3 4
# 1 "/usr/include/msgpack/unpack.h" 1 3 4
# 27 "/usr/include/msgpack.h" 2 3 4
# 1 "/usr/include/msgpack/sbuffer.h" 1 3 4
# 28 "/usr/include/msgpack.h" 2 3 4
# 1 "/usr/include/msgpack/vrefbuffer.h" 1 3 4
# 29 "/usr/include/msgpack.h" 2 3 4
# 1 "/usr/include/msgpack/version.h" 1 3 4
# 22 "/usr/include/msgpack/version.h" 3 4
extern "C" {



const char* msgpack_version(void);
int msgpack_version_major(void);
int msgpack_version_minor(void);







}
# 30 "/usr/include/msgpack.h" 2 3 4
# 24 "/usr/include/msgpack.hpp" 2 3 4
# 33 "/usr/include/cocaine/traits.hpp" 2 3 4

namespace cocaine { namespace io {

template<class T, class U = void>
struct type_traits {
    template<class Stream>
    static inline
    void
    pack(msgpack::packer<Stream>& packer,
         const T& object)
    {
        packer << object;
    }

    static inline
    void
    unpack(const msgpack::object& packed,
           T& object)
    {
        packed >> object;
    }
};
# 67 "/usr/include/cocaine/traits.hpp" 3 4
template<class T>
struct type_traits<
    T,
    typename std::enable_if<boost::mpl::is_sequence<T>::value>::type
>
{
    template<class Stream, typename... Args>
    static inline
    void
    pack(Stream& stream,
         const Args&... sequence)
    {
        static_assert(
            sizeof...(sequence) == boost::mpl::size<T>::value,
            "sequence length mismatch"
        );

        msgpack::packer<Stream> packer(stream);


        packer.pack_array(sizeof...(sequence));


        pack_sequence<typename boost::mpl::begin<T>::type>(
            packer,
            sequence...
        );
    }

    template<typename... Args>
    static inline
    void
    unpack(const msgpack::object& packed,
           Args&... sequence)
    {
        static_assert(
            sizeof...(sequence) == boost::mpl::size<T>::value,
            "sequence length mismatch"
        );

        if(packed.type != msgpack::type::ARRAY ||
           packed.via.array.size != sizeof...(sequence))
        {
            throw msgpack::type_error();
        }


        unpack_sequence<typename boost::mpl::begin<T>::type>(
            packed.via.array.ptr,
            sequence...
        );
    }

private:
    template<class It, class Stream>
    static inline
    void
    pack_sequence(msgpack::packer<Stream>& packer) {
        return;
    }

    template<class It, class Stream, class Head, typename... Tail>
    static inline
    void
    pack_sequence(msgpack::packer<Stream>& packer,
                  const Head& head,
                  const Tail&... tail)
    {

        typedef typename std::remove_const<
            typename std::remove_reference<Head>::type
        >::type type;

        static_assert(
            std::is_same<typename boost::mpl::deref<It>::type, type>::value,
            "sequence element type mismatch"
        );


        type_traits<type>::pack(packer, head);


        return pack_sequence<typename boost::mpl::next<It>::type>(
            packer,
            tail...
        );
    }

    template<class It>
    static inline
    void
    unpack_sequence(const msgpack::object * packed) {
        return;
    }

    template<class It, class Head, typename... Tail>
    static inline
    void
    unpack_sequence(const msgpack::object * packed,
                    Head& head,
                    Tail&... tail)
    {

        typedef typename std::remove_const<
            typename std::remove_reference<Head>::type
        >::type type;

        static_assert(
            std::is_same<typename boost::mpl::deref<It>::type, type>::value,
            "sequence element type mismatch"
        );


        type_traits<type>::unpack(*packed, head);


        return unpack_sequence<typename boost::mpl::next<It>::type>(
            ++packed,
            tail...
        );
    }
};

}}
# 26 "/usr/include/cocaine/io.hpp" 2 3 4

# 1 "/usr/include/cocaine/helpers/birth_control.hpp" 1 3 4
# 24 "/usr/include/cocaine/helpers/birth_control.hpp" 3 4
# 1 "/usr/include/cocaine/helpers/atomic.hpp" 1 3 4
# 27 "/usr/include/cocaine/helpers/atomic.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstdatomic" 1 3 4
# 42 "/usr/include/c++/4.4/cstdatomic" 3 4
       
# 43 "/usr/include/c++/4.4/cstdatomic" 3





# 1 "/usr/include/c++/4.4/stdatomic.h" 1 3
# 30 "/usr/include/c++/4.4/stdatomic.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 31 "/usr/include/c++/4.4/stdatomic.h" 2 3





namespace std __attribute__ ((__visibility__ ("default"))) {
extern "C" {
# 47 "/usr/include/c++/4.4/stdatomic.h" 3
  typedef enum memory_order
    {
      memory_order_relaxed,
      memory_order_consume,
      memory_order_acquire,
      memory_order_release,
      memory_order_acq_rel,
      memory_order_seq_cst
    } memory_order;


  typedef struct __atomic_flag_base
  {
    bool _M_i;
  } __atomic_flag_base;
# 86 "/usr/include/c++/4.4/stdatomic.h" 3
  inline namespace __atomic2 { }
# 1 "/usr/include/c++/4.4/bits/atomicfwd_cxx.h" 1 3
# 35 "/usr/include/c++/4.4/bits/atomicfwd_cxx.h" 3
}

  namespace __atomic0
  {
    template<typename _IntTp>
      struct __atomic_base;

    struct atomic_flag;
    struct atomic_address;
    struct atomic_bool;
  }

  namespace __atomic2
  {
    template<typename _IntTp>
      struct __atomic_base;

    struct atomic_flag;
    struct atomic_address;
    struct atomic_bool;
  }

  namespace __atomic1
  {
    using __atomic2::atomic_flag;
    using __atomic2::atomic_bool;
    using __atomic0::atomic_address;
    using __atomic0::__atomic_base;
  }


  typedef __atomic_base<char> atomic_char;


  typedef __atomic_base<signed char> atomic_schar;


  typedef __atomic_base<unsigned char> atomic_uchar;


  typedef __atomic_base<short> atomic_short;


  typedef __atomic_base<unsigned short> atomic_ushort;


  typedef __atomic_base<int> atomic_int;


  typedef __atomic_base<unsigned int> atomic_uint;


  typedef __atomic_base<long> atomic_long;


  typedef __atomic_base<unsigned long> atomic_ulong;


  typedef __atomic_base<long long> atomic_llong;


  typedef __atomic_base<unsigned long long> atomic_ullong;


  typedef __atomic_base<wchar_t> atomic_wchar_t;


  typedef __atomic_base<char16_t> atomic_char16_t;


  typedef __atomic_base<char32_t> atomic_char32_t;

  template<typename _Tp>
    struct atomic;
extern "C" {
# 88 "/usr/include/c++/4.4/stdatomic.h" 2 3





  typedef atomic_schar atomic_int_least8_t;
  typedef atomic_uchar atomic_uint_least8_t;
  typedef atomic_short atomic_int_least16_t;
  typedef atomic_ushort atomic_uint_least16_t;
  typedef atomic_int atomic_int_least32_t;
  typedef atomic_uint atomic_uint_least32_t;
  typedef atomic_llong atomic_int_least64_t;
  typedef atomic_ullong atomic_uint_least64_t;

  typedef atomic_schar atomic_int_fast8_t;
  typedef atomic_uchar atomic_uint_fast8_t;
  typedef atomic_short atomic_int_fast16_t;
  typedef atomic_ushort atomic_uint_fast16_t;
  typedef atomic_int atomic_int_fast32_t;
  typedef atomic_uint atomic_uint_fast32_t;
  typedef atomic_llong atomic_int_fast64_t;
  typedef atomic_ullong atomic_uint_fast64_t;

  typedef atomic_long atomic_intptr_t;
  typedef atomic_ulong atomic_uintptr_t;

  typedef atomic_long atomic_ssize_t;
  typedef atomic_ulong atomic_size_t;

  typedef atomic_llong atomic_intmax_t;
  typedef atomic_ullong atomic_uintmax_t;

  typedef atomic_long atomic_ptrdiff_t;


  bool
  atomic_flag_test_and_set_explicit(volatile __atomic_flag_base*, memory_order);

  inline bool
  atomic_flag_test_and_set(volatile __atomic_flag_base* __a)
  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }

  void
  atomic_flag_clear_explicit(volatile __atomic_flag_base*, memory_order);

  inline void
  atomic_flag_clear(volatile __atomic_flag_base* __a)
  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }

  void
  __atomic_flag_wait_explicit(volatile __atomic_flag_base*, memory_order);

  volatile __atomic_flag_base*
  __atomic_flag_for_address(const volatile void* __z) __attribute__((const));
# 186 "/usr/include/c++/4.4/stdatomic.h" 3
}
}




# 1 "/usr/include/c++/4.4/cstdatomic" 1 3
# 193 "/usr/include/c++/4.4/stdatomic.h" 2 3

using std::memory_order;
using std::memory_order_relaxed;
using std::memory_order_consume;
using std::memory_order_acquire;
using std::memory_order_release;
using std::memory_order_acq_rel;
using std::memory_order_seq_cst;
using std::atomic_flag;
using std::atomic_bool;
using std::atomic_char;
using std::atomic_schar;
using std::atomic_uchar;
using std::atomic_short;
using std::atomic_ushort;
using std::atomic_int;
using std::atomic_uint;
using std::atomic_long;
using std::atomic_ulong;
using std::atomic_llong;
using std::atomic_ullong;
using std::atomic_wchar_t;
using std::atomic_char16_t;
using std::atomic_char32_t;
using std::atomic_address;
using std::atomic;
# 49 "/usr/include/c++/4.4/cstdatomic" 2 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 50 "/usr/include/c++/4.4/cstdatomic" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y)
    {
      _Tp ret(__y);
      return ret;
    }

  inline memory_order
  __calculate_memory_order(memory_order __m)
  {
    const bool __cond1 = __m == memory_order_release;
    const bool __cond2 = __m == memory_order_acq_rel;
    memory_order __mo1(__cond1 ? memory_order_relaxed : __m);
    memory_order __mo2(__cond2 ? memory_order_acquire : __mo1);
    return __mo2;
  }
# 87 "/usr/include/c++/4.4/cstdatomic" 3
# 1 "/usr/include/c++/4.4/bits/atomic_0.h" 1 3
# 34 "/usr/include/c++/4.4/bits/atomic_0.h" 3
       
# 35 "/usr/include/c++/4.4/bits/atomic_0.h" 3




namespace __atomic0
{
  struct atomic_flag;
# 85 "/usr/include/c++/4.4/bits/atomic_0.h" 3
  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() = default;
    ~atomic_flag() = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;


    atomic_flag(bool __i): __atomic_flag_base({ __i }) { }

    bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile;

    void
    clear(memory_order __m = memory_order_seq_cst) volatile;
  };


  struct atomic_address
  {
  private:
    void* _M_i;

  public:
    atomic_address() = default;
    ~atomic_address() = default;
    atomic_address(const atomic_address&) = delete;
    atomic_address& operator=(const atomic_address&) = delete;

    atomic_address(void* __v) { _M_i = __v; }

    bool
    is_lock_free() const volatile
    { return false; }

    void
    store(void* __v, memory_order __m = memory_order_seq_cst) volatile
    {
      ;
      ;
      ;
      ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__v) __v = (__v); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); *__p = __v; atomic_flag_clear_explicit(__g, __m); __v; });
    }

    void*
    load(memory_order __m = memory_order_seq_cst) const volatile
    {
      ;
      ;
      return ({ volatile __typeof__ _M_i* __p = &_M_i; volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; atomic_flag_clear_explicit(__g, __m); __r; });
    }

    void*
    exchange(void* __v, memory_order __m = memory_order_seq_cst) volatile
    { return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__v) __v = (__v); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; *__p = __v; atomic_flag_clear_explicit(__g, __m); __r; }); }

    bool
    compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,
     memory_order __m2) volatile
    {
      ;
      ;
      ;
      return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(&__v1) __q = (&__v1); __typeof__(__v2) __v = (__v2); bool __r; volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m1); __typeof__ _M_i __t__ = *__p; if (__t__ == *__q) { *__p = __v; __r = true; } else { *__q = __t__; __r = false; } atomic_flag_clear_explicit(__g, __m1); __r; });
    }

    bool
    compare_exchange_weak(void*& __v1, void* __v2,
     memory_order __m = memory_order_seq_cst) volatile
    {
      return compare_exchange_weak(__v1, __v2, __m,
       __calculate_memory_order(__m));
    }

    bool
    compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,
       memory_order __m2) volatile
    {
      ;
      ;
      ;
      return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(&__v1) __q = (&__v1); __typeof__(__v2) __v = (__v2); bool __r; volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m1); __typeof__ _M_i __t__ = *__p; if (__t__ == *__q) { *__p = __v; __r = true; } else { *__q = __t__; __r = false; } atomic_flag_clear_explicit(__g, __m1); __r; });
    }

    bool
    compare_exchange_strong(void*& __v1, void* __v2,
     memory_order __m = memory_order_seq_cst) volatile
    {
      return compare_exchange_strong(__v1, __v2, __m,
         __calculate_memory_order(__m));
    }

    void*
    fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile
    {
      void* volatile* __p = &(_M_i);
      volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);
      __atomic_flag_wait_explicit(__g, __m);
      void* __r = *__p;
      *__p = (void*)((char*)(*__p) + __d);
      atomic_flag_clear_explicit(__g, __m);
      return __r;
    }

    void*
    fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile
    {
      void* volatile* __p = &(_M_i);
      volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);
      __atomic_flag_wait_explicit(__g, __m);
      void* __r = *__p;
      *__p = (void*)((char*)(*__p) - __d);
      atomic_flag_clear_explicit(__g, __m);
      return __r;
    }

    operator void*() const volatile
    { return load(); }

    void*
    operator=(void* __v)
    {
      store(__v);
      return __v;
    }

    void*
    operator+=(ptrdiff_t __d) volatile
    { return fetch_add(__d) + __d; }

    void*
    operator-=(ptrdiff_t __d) volatile
    { return fetch_sub(__d) - __d; }
  };
# 243 "/usr/include/c++/4.4/bits/atomic_0.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
    private:
      typedef _ITp __integral_type;

      __integral_type _M_i;

    public:
      __atomic_base() = default;
      ~__atomic_base() = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;


      __atomic_base(__integral_type __i) { _M_i = __i; }

      operator __integral_type() const volatile
      { return load(); }

      __integral_type
      operator=(__integral_type __i)
      {
 store(__i);
 return __i;
      }

      __integral_type
      operator++(int) volatile
      { return fetch_add(1); }

      __integral_type
      operator--(int) volatile
      { return fetch_sub(1); }

      __integral_type
      operator++() volatile
      { return fetch_add(1) + 1; }

      __integral_type
      operator--() volatile
      { return fetch_sub(1) - 1; }

      __integral_type
      operator+=(__integral_type __i) volatile
      { return fetch_add(__i) + __i; }

      __integral_type
      operator-=(__integral_type __i) volatile
      { return fetch_sub(__i) - __i; }

      __integral_type
      operator&=(__integral_type __i) volatile
      { return fetch_and(__i) & __i; }

      __integral_type
      operator|=(__integral_type __i) volatile
      { return fetch_or(__i) | __i; }

      __integral_type
      operator^=(__integral_type __i) volatile
      { return fetch_xor(__i) ^ __i; }

      bool
      is_lock_free() const volatile
      { return false; }

      void
      store(__integral_type __i,
     memory_order __m = memory_order_seq_cst) volatile
      {
 ;
 ;
 ;
 ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__i) __v = (__i); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); *__p = __v; atomic_flag_clear_explicit(__g, __m); __v; });
      }

      __integral_type
      load(memory_order __m = memory_order_seq_cst) const volatile
      {
 ;
 ;
 return ({ volatile __typeof__ _M_i* __p = &_M_i; volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; atomic_flag_clear_explicit(__g, __m); __r; });
      }

      __integral_type
      exchange(__integral_type __i,
        memory_order __m = memory_order_seq_cst) volatile
      { return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__i) __v = (__i); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; *__p = __v; atomic_flag_clear_explicit(__g, __m); __r; }); }

      bool
      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,
       memory_order __m1, memory_order __m2) volatile
      {
 ;
 ;
 ;
 return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(&__i1) __q = (&__i1); __typeof__(__i2) __v = (__i2); bool __r; volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m1); __typeof__ _M_i __t__ = *__p; if (__t__ == *__q) { *__p = __v; __r = true; } else { *__q = __t__; __r = false; } atomic_flag_clear_explicit(__g, __m1); __r; });
      }

      bool
      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,
       memory_order __m = memory_order_seq_cst) volatile
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __calculate_memory_order(__m));
      }

      bool
      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,
         memory_order __m1, memory_order __m2) volatile
      {
 ;
 ;
 ;
 return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(&__i1) __q = (&__i1); __typeof__(__i2) __v = (__i2); bool __r; volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m1); __typeof__ _M_i __t__ = *__p; if (__t__ == *__q) { *__p = __v; __r = true; } else { *__q = __t__; __r = false; } atomic_flag_clear_explicit(__g, __m1); __r; });
      }

      bool
      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,
         memory_order __m = memory_order_seq_cst) volatile
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __calculate_memory_order(__m));
      }

      __integral_type
      fetch_add(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__i) __v = (__i); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; *__p += __v; atomic_flag_clear_explicit(__g, __m); __r; }); }

      __integral_type
      fetch_sub(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__i) __v = (__i); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; *__p -= __v; atomic_flag_clear_explicit(__g, __m); __r; }); }

      __integral_type
      fetch_and(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__i) __v = (__i); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; *__p &= __v; atomic_flag_clear_explicit(__g, __m); __r; }); }

      __integral_type
      fetch_or(__integral_type __i,
        memory_order __m = memory_order_seq_cst) volatile
      { return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__i) __v = (__i); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; *__p |= __v; atomic_flag_clear_explicit(__g, __m); __r; }); }

      __integral_type
      fetch_xor(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return ({ volatile __typeof__ _M_i* __p = &_M_i; __typeof__(__i) __v = (__i); volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p); __atomic_flag_wait_explicit(__g, __m); __typeof__ _M_i __r = *__p; *__p ^= __v; atomic_flag_clear_explicit(__g, __m); __r; }); }
    };




  struct atomic_bool
  {
  private:
    __atomic_base<bool> _M_base;

  public:
    atomic_bool() = default;
    ~atomic_bool() = default;
    atomic_bool(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) = delete;

    atomic_bool(bool __i) : _M_base(__i) { }

    bool
    operator=(bool __i)
    { return _M_base.operator=(__i); }

    operator bool() const volatile
    { return _M_base.load(); }

    bool
    is_lock_free() const volatile
    { return _M_base.is_lock_free(); }

    void
    store(bool __i, memory_order __m = memory_order_seq_cst) volatile
    { _M_base.store(__i, __m); }

    bool
    load(memory_order __m = memory_order_seq_cst) const volatile
    { return _M_base.load(__m); }

    bool
    exchange(bool __i, memory_order __m = memory_order_seq_cst) volatile
    { return _M_base.exchange(__i, __m); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
     memory_order __m2) volatile
    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2,
     memory_order __m = memory_order_seq_cst) volatile
    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
       memory_order __m2) volatile
    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }


    bool
    compare_exchange_strong(bool& __i1, bool __i2,
       memory_order __m = memory_order_seq_cst) volatile
    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
  };





}
# 88 "/usr/include/c++/4.4/cstdatomic" 2 3
# 1 "/usr/include/c++/4.4/bits/atomic_2.h" 1 3
# 34 "/usr/include/c++/4.4/bits/atomic_2.h" 3
       
# 35 "/usr/include/c++/4.4/bits/atomic_2.h" 3
# 44 "/usr/include/c++/4.4/bits/atomic_2.h" 3
namespace __atomic2
{

  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() = default;
    ~atomic_flag() = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;


    atomic_flag(bool __i): __atomic_flag_base({ __i }) { }

    bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile
    {

      if (__m != memory_order_acquire && __m != memory_order_acq_rel)
 __sync_synchronize();
      return __sync_lock_test_and_set(&_M_i, 1);
    }

    void
    clear(memory_order __m = memory_order_seq_cst) volatile
    {
      ;
      ;
      ;

      __sync_lock_release(&_M_i);
      if (__m != memory_order_acquire && __m != memory_order_acq_rel)
 __sync_synchronize();
    }
  };



  struct atomic_address
  {
  private:
    void* _M_i;

  public:
    atomic_address() = default;
    ~atomic_address() = default;
    atomic_address(const atomic_address&) = delete;
    atomic_address& operator=(const atomic_address&) = delete;

    atomic_address(void* __v) { _M_i = __v; }

    bool
    is_lock_free() const volatile
    { return true; }

    void
    store(void* __v, memory_order __m = memory_order_seq_cst) volatile
    {
      ;
      ;
      ;

      if (__m == memory_order_relaxed)
 _M_i = __v;
      else
 {

   _M_i = __v;
   if (__m == memory_order_seq_cst)
     __sync_synchronize();
 }
    }

    void*
    load(memory_order __m = memory_order_seq_cst) const volatile
    {
      ;
      ;

      __sync_synchronize();
      void* __ret = _M_i;
      __sync_synchronize();
      return __ret;
    }

    void*
    exchange(void* __v, memory_order __m = memory_order_seq_cst) volatile
    {

      return __sync_lock_test_and_set(&_M_i, __v);
    }

    bool
    compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,
     memory_order __m2) volatile
    { return compare_exchange_strong(__v1, __v2, __m1, __m2); }

    bool
    compare_exchange_weak(void*& __v1, void* __v2,
     memory_order __m = memory_order_seq_cst) volatile
    {
      return compare_exchange_weak(__v1, __v2, __m,
       __calculate_memory_order(__m));
    }

    bool
    compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,
       memory_order __m2) volatile
    {
      ;
      ;
      ;

      void* __v1o = __v1;
      void* __v1n = __sync_val_compare_and_swap(&_M_i, __v1o, __v2);


      __v1 = __v1n;
      return __v1o == __v1n;
    }

    bool
    compare_exchange_strong(void*& __v1, void* __v2,
     memory_order __m = memory_order_seq_cst) volatile
    {
      return compare_exchange_strong(__v1, __v2, __m,
         __calculate_memory_order(__m));
    }

    void*
    fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile
    { return __sync_fetch_and_add(&_M_i, __d); }

    void*
    fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile
    { return __sync_fetch_and_sub(&_M_i, __d); }

    operator void*() const volatile
    { return load(); }

    void*
    operator=(void* __v)
    {
      store(__v);
      return __v;
    }

    void*
    operator+=(ptrdiff_t __d) volatile
    { return __sync_add_and_fetch(&_M_i, __d); }

    void*
    operator-=(ptrdiff_t __d) volatile
    { return __sync_sub_and_fetch(&_M_i, __d); }
  };
# 221 "/usr/include/c++/4.4/bits/atomic_2.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
    private:
      typedef _ITp __integral_type;

      __integral_type _M_i;

    public:
      __atomic_base() = default;
      ~__atomic_base() = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;


      __atomic_base(__integral_type __i) { _M_i = __i; }

      operator __integral_type() const volatile
      { return load(); }

      __integral_type
      operator=(__integral_type __i)
      {
 store(__i);
 return __i;
      }

      __integral_type
      operator++(int) volatile
      { return fetch_add(1); }

      __integral_type
      operator--(int) volatile
      { return fetch_sub(1); }

      __integral_type
      operator++() volatile
      { return __sync_add_and_fetch(&_M_i, 1); }

      __integral_type
      operator--() volatile
      { return __sync_sub_and_fetch(&_M_i, 1); }

      __integral_type
      operator+=(__integral_type __i) volatile
      { return __sync_add_and_fetch(&_M_i, __i); }

      __integral_type
      operator-=(__integral_type __i) volatile
      { return __sync_sub_and_fetch(&_M_i, __i); }

      __integral_type
      operator&=(__integral_type __i) volatile
      { return __sync_and_and_fetch(&_M_i, __i); }

      __integral_type
      operator|=(__integral_type __i) volatile
      { return __sync_or_and_fetch(&_M_i, __i); }

      __integral_type
      operator^=(__integral_type __i) volatile
      { return __sync_xor_and_fetch(&_M_i, __i); }

      bool
      is_lock_free() const volatile
      { return true; }

      void
      store(__integral_type __i,
     memory_order __m = memory_order_seq_cst) volatile
      {
 ;
 ;
 ;

 if (__m == memory_order_relaxed)
   _M_i = __i;
 else
   {

     _M_i = __i;
     if (__m == memory_order_seq_cst)
       __sync_synchronize();
   }
      }

      __integral_type
      load(memory_order __m = memory_order_seq_cst) const volatile
      {
 ;
 ;

 __sync_synchronize();
 __integral_type __ret = _M_i;
 __sync_synchronize();
 return __ret;
      }

      __integral_type
      exchange(__integral_type __i,
        memory_order __m = memory_order_seq_cst) volatile
      {

 return __sync_lock_test_and_set(&_M_i, __i);
      }

      bool
      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,
       memory_order __m1, memory_order __m2) volatile
      { return compare_exchange_strong(__i1, __i2, __m1, __m2); }

      bool
      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,
       memory_order __m = memory_order_seq_cst) volatile
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __calculate_memory_order(__m));
      }

      bool
      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,
         memory_order __m1, memory_order __m2) volatile
      {
 ;
 ;
 ;

 __integral_type __i1o = __i1;
 __integral_type __i1n = __sync_val_compare_and_swap(&_M_i, __i1o, __i2);


 __i1 = __i1n;
 return __i1o == __i1n;
      }

      bool
      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,
         memory_order __m = memory_order_seq_cst) volatile
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __calculate_memory_order(__m));
      }

      __integral_type
      fetch_add(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return __sync_fetch_and_add(&_M_i, __i); }

      __integral_type
      fetch_sub(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return __sync_fetch_and_sub(&_M_i, __i); }

      __integral_type
      fetch_and(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return __sync_fetch_and_and(&_M_i, __i); }

      __integral_type
      fetch_or(__integral_type __i,
        memory_order __m = memory_order_seq_cst) volatile
      { return __sync_fetch_and_or(&_M_i, __i); }

      __integral_type
      fetch_xor(__integral_type __i,
  memory_order __m = memory_order_seq_cst) volatile
      { return __sync_fetch_and_xor(&_M_i, __i); }
    };




  struct atomic_bool
  {
  private:
    __atomic_base<bool> _M_base;

  public:
    atomic_bool() = default;
    ~atomic_bool() = default;
    atomic_bool(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) = delete;

    atomic_bool(bool __i) : _M_base(__i) { }

    bool
    operator=(bool __i)
    { return _M_base.operator=(__i); }

    operator bool() const volatile
    { return _M_base.load(); }

    bool
    is_lock_free() const volatile
    { return _M_base.is_lock_free(); }

    void
    store(bool __i, memory_order __m = memory_order_seq_cst) volatile
    { _M_base.store(__i, __m); }

    bool
    load(memory_order __m = memory_order_seq_cst) const volatile
    { return _M_base.load(__m); }

    bool
    exchange(bool __i, memory_order __m = memory_order_seq_cst) volatile
    { return _M_base.exchange(__i, __m); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,
     memory_order __m2) volatile
    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }

    bool
    compare_exchange_weak(bool& __i1, bool __i2,
     memory_order __m = memory_order_seq_cst) volatile
    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }

    bool
    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,
       memory_order __m2) volatile
    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }


    bool
    compare_exchange_strong(bool& __i1, bool __i2,
       memory_order __m = memory_order_seq_cst) volatile
    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }
  };
}
# 89 "/usr/include/c++/4.4/cstdatomic" 2 3



  template<typename _Tp>
    struct atomic
    {
    private:
      _Tp _M_i;

    public:
      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(_Tp __i) : _M_i(__i) { }

      operator _Tp() const volatile;

      _Tp
      operator=(_Tp __i) volatile { store(__i); return __i; }

      bool
      is_lock_free() const volatile;

      void
      store(_Tp, memory_order = memory_order_seq_cst) volatile;

      _Tp
      load(memory_order = memory_order_seq_cst) const volatile;

      _Tp
      exchange(_Tp __i, memory_order = memory_order_seq_cst) volatile;

      bool
      compare_exchange_weak(_Tp&, _Tp, memory_order, memory_order) volatile;

      bool
      compare_exchange_strong(_Tp&, _Tp, memory_order, memory_order) volatile;

      bool
      compare_exchange_weak(_Tp&, _Tp,
       memory_order = memory_order_seq_cst) volatile;

      bool
      compare_exchange_strong(_Tp&, _Tp,
         memory_order = memory_order_seq_cst) volatile;
    };



  template<typename _Tp>
    struct atomic<_Tp*> : atomic_address
    {
      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(_Tp* __v) : atomic_address(__v) { }

      void
      store(_Tp*, memory_order = memory_order_seq_cst) volatile;

      _Tp*
      load(memory_order = memory_order_seq_cst) const volatile;

      _Tp*
      exchange(_Tp*, memory_order = memory_order_seq_cst) volatile;

      bool
      compare_exchange_weak(_Tp*&, _Tp*, memory_order, memory_order) volatile;

      bool
      compare_exchange_strong(_Tp*&, _Tp*, memory_order, memory_order) volatile;

      bool
      compare_exchange_weak(_Tp*&, _Tp*,
       memory_order = memory_order_seq_cst) volatile;

      bool
      compare_exchange_strong(_Tp*&, _Tp*,
         memory_order = memory_order_seq_cst) volatile;

      _Tp*
      fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;

      _Tp*
      fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;

      operator _Tp*() const volatile
      { return load(); }

      _Tp*
      operator=(_Tp* __v) volatile
      {
 store(__v);
 return __v;
      }

      _Tp*
      operator++(int) volatile { return fetch_add(1); }

      _Tp*
      operator--(int) volatile { return fetch_sub(1); }

      _Tp*
      operator++() volatile { return fetch_add(1) + 1; }

      _Tp*
      operator--() volatile { return fetch_sub(1) - 1; }

      _Tp*
      operator+=(ptrdiff_t __d) volatile
      { return fetch_add(__d) + __d; }

      _Tp*
      operator-=(ptrdiff_t __d) volatile
      { return fetch_sub(__d) - __d; }
    };



  template<>
    struct atomic<void*> : public atomic_address
    {
      typedef void* __integral_type;
      typedef atomic_address __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<bool> : public atomic_bool
    {
      typedef bool __integral_type;
      typedef atomic_bool __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<char> : public atomic_char
    {
      typedef char __integral_type;
      typedef atomic_char __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<signed char> : public atomic_schar
    {
      typedef signed char __integral_type;
      typedef atomic_schar __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<unsigned char> : public atomic_uchar
    {
      typedef unsigned char __integral_type;
      typedef atomic_uchar __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<short> : public atomic_short
    {
      typedef short __integral_type;
      typedef atomic_short __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<unsigned short> : public atomic_ushort
    {
      typedef unsigned short __integral_type;
      typedef atomic_ushort __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<int> : atomic_int
    {
      typedef int __integral_type;
      typedef atomic_int __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<unsigned int> : public atomic_uint
    {
      typedef unsigned int __integral_type;
      typedef atomic_uint __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<long> : public atomic_long
    {
      typedef long __integral_type;
      typedef atomic_long __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<unsigned long> : public atomic_ulong
    {
      typedef unsigned long __integral_type;
      typedef atomic_ulong __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<long long> : public atomic_llong
    {
      typedef long long __integral_type;
      typedef atomic_llong __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<unsigned long long> : public atomic_ullong
    {
      typedef unsigned long long __integral_type;
      typedef atomic_ullong __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<wchar_t> : public atomic_wchar_t
    {
      typedef wchar_t __integral_type;
      typedef atomic_wchar_t __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<char16_t> : public atomic_char16_t
    {
      typedef char16_t __integral_type;
      typedef atomic_char16_t __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<>
    struct atomic<char32_t> : public atomic_char32_t
    {
      typedef char32_t __integral_type;
      typedef atomic_char32_t __base_type;

      atomic() = default;
      ~atomic() = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;

      atomic(__integral_type __i) : __base_type(__i) { }

      using __base_type::operator __integral_type;
      using __base_type::operator=;
    };


  template<typename _Tp>
    _Tp*
    atomic<_Tp*>::load(memory_order __m) const volatile
    { return static_cast<_Tp*>(atomic_address::load(__m)); }

  template<typename _Tp>
    _Tp*
    atomic<_Tp*>::exchange(_Tp* __v, memory_order __m) volatile
    { return static_cast<_Tp*>(atomic_address::exchange(__v, __m)); }

  template<typename _Tp>
    bool
    atomic<_Tp*>::compare_exchange_weak(_Tp*& __r, _Tp* __v, memory_order __m1,
     memory_order __m2) volatile
    {
      void** __vr = reinterpret_cast<void**>(&__r);
      void* __vv = static_cast<void*>(__v);
      return atomic_address::compare_exchange_weak(*__vr, __vv, __m1, __m2);
    }

  template<typename _Tp>
    bool
    atomic<_Tp*>::compare_exchange_strong(_Tp*& __r, _Tp* __v,
       memory_order __m1,
       memory_order __m2) volatile
    {
      void** __vr = reinterpret_cast<void**>(&__r);
      void* __vv = static_cast<void*>(__v);
      return atomic_address::compare_exchange_strong(*__vr, __vv, __m1, __m2);
    }

  template<typename _Tp>
    bool
    atomic<_Tp*>::compare_exchange_weak(_Tp*& __r, _Tp* __v,
     memory_order __m) volatile
    {
      return compare_exchange_weak(__r, __v, __m,
       __calculate_memory_order(__m));
    }

  template<typename _Tp>
    bool
    atomic<_Tp*>::compare_exchange_strong(_Tp*& __r, _Tp* __v,
     memory_order __m) volatile
    {
      return compare_exchange_strong(__r, __v, __m,
         __calculate_memory_order(__m));
    }

  template<typename _Tp>
    _Tp*
    atomic<_Tp*>::fetch_add(ptrdiff_t __d, memory_order __m) volatile
    {
      void* __p = atomic_fetch_add_explicit(this, sizeof(_Tp) * __d, __m);
      return static_cast<_Tp*>(__p);
    }

  template<typename _Tp>
    _Tp*
    atomic<_Tp*>::fetch_sub(ptrdiff_t __d, memory_order __m) volatile
    {
      void* __p = atomic_fetch_sub_explicit(this, sizeof(_Tp) * __d, __m);
      return static_cast<_Tp*>(__p);
    }


  inline bool
  atomic_flag_test_and_set_explicit(volatile atomic_flag* __a, memory_order __m)
  { return __a->test_and_set(__m); }

  inline void
  atomic_flag_clear_explicit(volatile atomic_flag* __a, memory_order __m)
  { return __a->clear(__m); }



  inline bool
  atomic_is_lock_free(const volatile atomic_address* __a)
  { return __a->is_lock_free(); }

  inline void
  atomic_store(volatile atomic_address* __a, void* __v)
  { __a->store(__v); }

  inline void
  atomic_store_explicit(volatile atomic_address* __a, void* __v,
   memory_order __m)
  { __a->store(__v, __m); }

  inline void*
  atomic_load(const volatile atomic_address* __a)
  { return __a->load(); }

  inline void*
  atomic_load_explicit(const volatile atomic_address* __a, memory_order __m)
  { return __a->load(__m); }

  inline void*
  atomic_exchange(volatile atomic_address* __a, void* __v)
  { return __a->exchange(__v); }

  inline void*
  atomic_exchange_explicit(volatile atomic_address* __a, void* __v,
      memory_order __m)
  { return __a->exchange(__v, __m); }

  inline bool
  atomic_compare_exchange_weak(volatile atomic_address* __a,
          void** __v1, void* __v2)
  {
    return __a->compare_exchange_weak(*__v1, __v2, memory_order_seq_cst,
          memory_order_seq_cst);
  }

  inline bool
  atomic_compare_exchange_strong(volatile atomic_address* __a,
          void** __v1, void* __v2)
  {
    return __a->compare_exchange_strong(*__v1, __v2, memory_order_seq_cst,
          memory_order_seq_cst);
  }

  inline bool
  atomic_compare_exchange_weak_explicit(volatile atomic_address* __a,
     void** __v1, void* __v2,
     memory_order __m1, memory_order __m2)
  { return __a->compare_exchange_weak(*__v1, __v2, __m1, __m2); }

  inline bool
  atomic_compare_exchange_strong_explicit(volatile atomic_address* __a,
     void** __v1, void* __v2,
     memory_order __m1, memory_order __m2)
  { return __a->compare_exchange_strong(*__v1, __v2, __m1, __m2); }

  inline void*
  atomic_fetch_add_explicit(volatile atomic_address* __a, ptrdiff_t __d,
       memory_order __m)
  { return __a->fetch_add(__d, __m); }

  inline void*
  atomic_fetch_add(volatile atomic_address* __a, ptrdiff_t __d)
  { return __a->fetch_add(__d); }

  inline void*
  atomic_fetch_sub_explicit(volatile atomic_address* __a, ptrdiff_t __d,
       memory_order __m)
  { return __a->fetch_sub(__d, __m); }

  inline void*
  atomic_fetch_sub(volatile atomic_address* __a, ptrdiff_t __d)
  { return __a->fetch_sub(__d); }



  inline bool
  atomic_is_lock_free(const volatile atomic_bool* __a)
  { return __a->is_lock_free(); }

  inline void
  atomic_store(volatile atomic_bool* __a, bool __i)
  { __a->store(__i); }

  inline void
  atomic_store_explicit(volatile atomic_bool* __a, bool __i, memory_order __m)
  { __a->store(__i, __m); }

  inline bool
  atomic_load(const volatile atomic_bool* __a)
  { return __a->load(); }

  inline bool
  atomic_load_explicit(const volatile atomic_bool* __a, memory_order __m)
  { return __a->load(__m); }

  inline bool
  atomic_exchange(volatile atomic_bool* __a, bool __i)
  { return __a->exchange(__i); }

  inline bool
  atomic_exchange_explicit(volatile atomic_bool* __a, bool __i,
      memory_order __m)
  { return __a->exchange(__i, __m); }

  inline bool
  atomic_compare_exchange_weak(volatile atomic_bool* __a, bool* __i1, bool __i2)
  {
    return __a->compare_exchange_weak(*__i1, __i2, memory_order_seq_cst,
          memory_order_seq_cst);
  }

  inline bool
  atomic_compare_exchange_strong(volatile atomic_bool* __a,
     bool* __i1, bool __i2)
  {
    return __a->compare_exchange_strong(*__i1, __i2, memory_order_seq_cst,
     memory_order_seq_cst);
  }

  inline bool
  atomic_compare_exchange_weak_explicit(volatile atomic_bool* __a, bool* __i1,
     bool __i2, memory_order __m1,
     memory_order __m2)
  { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }

  inline bool
  atomic_compare_exchange_strong_explicit(volatile atomic_bool* __a,
       bool* __i1, bool __i2,
       memory_order __m1, memory_order __m2)
  { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }





  template<typename _ITp>
    inline void
    atomic_store_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
     memory_order __m)
    { __a->store(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_load_explicit(const volatile __atomic_base<_ITp>* __a,
    memory_order __m)
    { return __a->load(__m); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange_explicit(volatile __atomic_base<_ITp>* __a,
        _ITp __i, memory_order __m)
    { return __a->exchange(__i, __m); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak_explicit(volatile __atomic_base<_ITp>* __a,
       _ITp* __i1, _ITp __i2,
       memory_order __m1, memory_order __m2)
    { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong_explicit(volatile __atomic_base<_ITp>* __a,
         _ITp* __i1, _ITp __i2,
         memory_order __m1,
         memory_order __m2)
    { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m)
    { return __a->fetch_add(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m)
    { return __a->fetch_sub(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m)
    { return __a->fetch_and(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
        memory_order __m)
    { return __a->fetch_or(__i, __m); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,
         memory_order __m)
    { return __a->fetch_xor(__i, __m); }

  template<typename _ITp>
    inline bool
    atomic_is_lock_free(const volatile __atomic_base<_ITp>* __a)
    { return __a->is_lock_free(); }

  template<typename _ITp>
    inline void
    atomic_store(volatile __atomic_base<_ITp>* __a, _ITp __i)
    { atomic_store_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_load(const volatile __atomic_base<_ITp>* __a)
    { return atomic_load_explicit(__a, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_exchange(volatile __atomic_base<_ITp>* __a, _ITp __i)
    { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_weak(volatile __atomic_base<_ITp>* __a,
     _ITp* __i1, _ITp __i2)
    {
      return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,
         memory_order_seq_cst,
         memory_order_seq_cst);
    }

  template<typename _ITp>
    inline bool
    atomic_compare_exchange_strong(volatile __atomic_base<_ITp>* __a,
       _ITp* __i1, _ITp __i2)
    {
      return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,
           memory_order_seq_cst,
           memory_order_seq_cst);
    }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_add(volatile __atomic_base<_ITp>* __a, _ITp __i)
    { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_sub(volatile __atomic_base<_ITp>* __a, _ITp __i)
    { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_and(volatile __atomic_base<_ITp>* __a, _ITp __i)
    { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_or(volatile __atomic_base<_ITp>* __a, _ITp __i)
    { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }

  template<typename _ITp>
    inline _ITp
    atomic_fetch_xor(volatile __atomic_base<_ITp>* __a, _ITp __i)
    { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }



}
# 28 "/usr/include/cocaine/helpers/atomic.hpp" 2 3 4
# 25 "/usr/include/cocaine/helpers/birth_control.hpp" 2 3 4

namespace cocaine {

template<class T>
class birth_control {
    public:
        birth_control() {
            ++g_objects_alive;
            ++g_objects_created;
        }

        static inline
        uint64_t
        objects_alive() {
            return g_objects_alive;
        }

        static inline
        uint64_t
        objects_created() {
            return g_objects_created;
        }

    protected:
        ~birth_control() {
            --g_objects_alive;
        }

    private:
        static std::atomic<uint64_t> g_objects_alive;
        static std::atomic<uint64_t> g_objects_created;
};

template<class T>
std::atomic<uint64_t>
birth_control<T>::g_objects_alive(0);

template<class T>
std::atomic<uint64_t>
birth_control<T>::g_objects_created(0);

}
# 28 "/usr/include/cocaine/io.hpp" 2 3 4



# 1 "/usr/include/boost/thread/mutex.hpp" 1 3 4
# 12 "/usr/include/boost/thread/mutex.hpp" 3 4
# 1 "/usr/include/boost/thread/detail/platform.hpp" 1 3 4
# 17 "/usr/include/boost/thread/detail/platform.hpp" 3 4
# 1 "/usr/include/boost/config/requires_threads.hpp" 1 3 4
# 18 "/usr/include/boost/thread/detail/platform.hpp" 2 3 4
# 13 "/usr/include/boost/thread/mutex.hpp" 2 3 4



# 1 "/usr/include/boost/thread/pthread/mutex.hpp" 1 3 4
# 9 "/usr/include/boost/thread/pthread/mutex.hpp" 3 4
# 1 "/usr/include/boost/utility.hpp" 1 3 4
# 12 "/usr/include/boost/utility.hpp" 3 4
# 1 "/usr/include/boost/utility/addressof.hpp" 1 3 4
# 18 "/usr/include/boost/utility/addressof.hpp" 3 4
namespace boost
{

namespace detail
{

template<class T> struct addr_impl_ref
{
    T & v_;

    inline addr_impl_ref( T & v ): v_( v ) {}
    inline operator T& () const { return v_; }

private:
    addr_impl_ref & operator=(const addr_impl_ref &);
};

template<class T> struct addressof_impl
{
    static inline T * f( T & v, long )
    {
        return reinterpret_cast<T*>(
            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }

    static inline T * f( T * v, int )
    {
        return v;
    }
};

}

template<class T> T * addressof( T & v )
{






    return boost::detail::addressof_impl<T>::f( boost::detail::addr_impl_ref<T>( v ), 0 );


}
# 100 "/usr/include/boost/utility/addressof.hpp" 3 4
}
# 13 "/usr/include/boost/utility.hpp" 2 3 4

# 1 "/usr/include/boost/utility/binary.hpp" 1 3 4
# 26 "/usr/include/boost/utility/binary.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/control/deduce_d.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/control/deduce_d.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/control/deduce_d.hpp" 2 3 4
# 27 "/usr/include/boost/utility/binary.hpp" 2 3 4


# 1 "/usr/include/boost/preprocessor/seq/cat.hpp" 1 3 4
# 18 "/usr/include/boost/preprocessor/seq/cat.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/seq/fold_left.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/seq/fold_left.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/detail/auto_rec.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/seq/fold_left.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/seq/seq.hpp" 1 3 4
# 16 "/usr/include/boost/preprocessor/seq/seq.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/seq/elem.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/seq/seq.hpp" 2 3 4
# 21 "/usr/include/boost/preprocessor/seq/fold_left.hpp" 2 3 4
# 19 "/usr/include/boost/preprocessor/seq/cat.hpp" 2 3 4
# 30 "/usr/include/boost/utility/binary.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/seq/transform.hpp" 1 3 4
# 31 "/usr/include/boost/utility/binary.hpp" 2 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/mod.hpp" 1 3 4
# 17 "/usr/include/boost/preprocessor/arithmetic/mod.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/comparison/less_equal.hpp" 1 3 4
# 19 "/usr/include/boost/preprocessor/comparison/less_equal.hpp" 3 4
# 1 "/usr/include/boost/preprocessor/logical/not.hpp" 1 3 4
# 20 "/usr/include/boost/preprocessor/comparison/less_equal.hpp" 2 3 4
# 20 "/usr/include/boost/preprocessor/arithmetic/detail/div_base.hpp" 2 3 4
# 18 "/usr/include/boost/preprocessor/arithmetic/mod.hpp" 2 3 4
# 32 "/usr/include/boost/utility/binary.hpp" 2 3 4
# 15 "/usr/include/boost/utility.hpp" 2 3 4
# 1 "/usr/include/boost/utility/enable_if.hpp" 1 3 4
# 24 "/usr/include/boost/utility/enable_if.hpp" 3 4
namespace boost
{

  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };

  template <class T>
  struct enable_if_c<false, T> {};

  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_enable_if_c<false, T> {};

  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};


  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };

  template <class T>
  struct disable_if_c<true, T> {};

  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};

  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };

  template <class T>
  struct lazy_disable_if_c<true, T> {};

  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};

}
# 16 "/usr/include/boost/utility.hpp" 2 3 4

# 1 "/usr/include/boost/next_prior.hpp" 1 3 4
# 17 "/usr/include/boost/next_prior.hpp" 3 4
namespace boost {
# 29 "/usr/include/boost/next_prior.hpp" 3 4
template <class T>
inline T next(T x) { return ++x; }

template <class T, class Distance>
inline T next(T x, Distance n)
{
    std::advance(x, n);
    return x;
}

template <class T>
inline T prior(T x) { return --x; }

template <class T, class Distance>
inline T prior(T x, Distance n)
{
    std::advance(x, -n);
    return x;
}

}
# 18 "/usr/include/boost/utility.hpp" 2 3 4
# 10 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4
# 1 "/usr/include/boost/thread/exceptions.hpp" 1 3 4
# 11 "/usr/include/boost/thread/exceptions.hpp" 3 4
# 1 "/usr/include/boost/thread/detail/config.hpp" 1 3 4
# 20 "/usr/include/boost/thread/detail/config.hpp" 3 4
# 1 "/usr/include/boost/thread/detail/platform.hpp" 1 3 4
# 21 "/usr/include/boost/thread/detail/config.hpp" 2 3 4
# 85 "/usr/include/boost/thread/detail/config.hpp" 3 4
# 1 "/usr/include/boost/config/auto_link.hpp" 1 3 4
# 86 "/usr/include/boost/thread/detail/config.hpp" 2 3 4
# 12 "/usr/include/boost/thread/exceptions.hpp" 2 3 4
# 22 "/usr/include/boost/thread/exceptions.hpp" 3 4
# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 23 "/usr/include/boost/thread/exceptions.hpp" 2 3 4

namespace boost
{

    class thread_interrupted
    {};

class thread_exception : public std::exception
{
protected:
    thread_exception();
    thread_exception(int sys_err_code);

public:
    ~thread_exception() throw();

    int native_error() const;

private:
    int m_sys_err;
};

    class condition_error:
        public std::exception
    {
    public:
        const char* what() const throw()
        {
            return "Condition error";
        }
    };


class lock_error : public thread_exception
{
public:
    lock_error();
    lock_error(int sys_err_code);
    ~lock_error() throw();

    virtual const char* what() const throw();
};

class thread_resource_error : public thread_exception
{
public:
    thread_resource_error();
    thread_resource_error(int sys_err_code);
    ~thread_resource_error() throw();

    virtual const char* what() const throw();
};

class unsupported_thread_option : public thread_exception
{
public:
    unsupported_thread_option();
    unsupported_thread_option(int sys_err_code);
    ~unsupported_thread_option() throw();

    virtual const char* what() const throw();
};

class invalid_thread_argument : public thread_exception
{
public:
    invalid_thread_argument();
    invalid_thread_argument(int sys_err_code);
    ~invalid_thread_argument() throw();

    virtual const char* what() const throw();
};

class thread_permission_error : public thread_exception
{
public:
    thread_permission_error();
    thread_permission_error(int sys_err_code);
    ~thread_permission_error() throw();

    virtual const char* what() const throw();
};

}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 109 "/usr/include/boost/thread/exceptions.hpp" 2 3 4
# 11 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4
# 1 "/usr/include/boost/thread/locks.hpp" 1 3 4
# 9 "/usr/include/boost/thread/locks.hpp" 3 4
# 1 "/usr/include/boost/thread/detail/move.hpp" 1 3 4
# 14 "/usr/include/boost/thread/detail/move.hpp" 3 4
# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 15 "/usr/include/boost/thread/detail/move.hpp" 2 3 4

namespace boost
{
    namespace detail
    {
        template<typename T>
        struct thread_move_t
        {
            T& t;
            explicit thread_move_t(T& t_):
                t(t_)
            {}

            T& operator*() const
            {
                return t;
            }

            T* operator->() const
            {
                return &t;
            }
        private:
            void operator=(thread_move_t&);
        };
    }


    template<typename T>
    typename enable_if<boost::is_convertible<T&,detail::thread_move_t<T> >, T >::type move(T& t)
    {
        return T(detail::thread_move_t<T>(t));
    }


    template<typename T>
    detail::thread_move_t<T> move(detail::thread_move_t<T> t)
    {
        return t;
    }

}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 59 "/usr/include/boost/thread/detail/move.hpp" 2 3 4
# 10 "/usr/include/boost/thread/locks.hpp" 2 3 4


# 1 "/usr/include/boost/thread/thread_time.hpp" 1 3 4
# 9 "/usr/include/boost/thread/thread_time.hpp" 3 4
# 1 "/usr/include/boost/date_time/microsec_time_clock.hpp" 1 3 4
# 17 "/usr/include/boost/date_time/microsec_time_clock.hpp" 3 4
# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 18 "/usr/include/boost/date_time/microsec_time_clock.hpp" 2 3 4


# 1 "/usr/include/boost/date_time/compiler_config.hpp" 1 3 4
# 11 "/usr/include/boost/date_time/compiler_config.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstdlib" 1 3 4
# 41 "/usr/include/c++/4.4/cstdlib" 3 4
       
# 42 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstdlib" 2 3
# 12 "/usr/include/boost/date_time/compiler_config.hpp" 2 3 4
# 31 "/usr/include/boost/date_time/compiler_config.hpp" 3 4
# 1 "/usr/include/boost/date_time/locale_config.hpp" 1 3 4
# 32 "/usr/include/boost/date_time/compiler_config.hpp" 2 3 4
# 54 "/usr/include/boost/date_time/compiler_config.hpp" 3 4
# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 55 "/usr/include/boost/date_time/compiler_config.hpp" 2 3 4
# 159 "/usr/include/boost/date_time/compiler_config.hpp" 3 4
# 1 "/usr/include/boost/config/auto_link.hpp" 1 3 4
# 160 "/usr/include/boost/date_time/compiler_config.hpp" 2 3 4
# 21 "/usr/include/boost/date_time/microsec_time_clock.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/c_time.hpp" 1 3 4
# 17 "/usr/include/boost/date_time/c_time.hpp" 3 4
# 1 "/usr/include/c++/4.4/ctime" 1 3 4
# 41 "/usr/include/c++/4.4/ctime" 3 4
       
# 42 "/usr/include/c++/4.4/ctime" 3

# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/ctime" 2 3
# 18 "/usr/include/boost/date_time/c_time.hpp" 2 3 4
# 31 "/usr/include/boost/date_time/c_time.hpp" 3 4
# 1 "/usr/include/sys/time.h" 1 3 4
# 29 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/sys/time.h" 2 3 4
# 39 "/usr/include/sys/time.h" 3 4
extern "C" {
# 57 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 73 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz)
     throw () __attribute__ ((__nonnull__ (1)));





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, __const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, __const char *__file,
        __const struct timeval __tvp[2]) throw ();
# 191 "/usr/include/sys/time.h" 3 4
}
# 32 "/usr/include/boost/date_time/c_time.hpp" 2 3 4






namespace boost {
namespace date_time {
# 50 "/usr/include/boost/date_time/c_time.hpp" 3 4
  struct c_time {
    public:


      inline
      static std::tm* localtime(const std::time_t* t, std::tm* result)
      {

        result = localtime_r(t, result);
        if (!result)
          boost::throw_exception(std::runtime_error("could not convert calendar time to local time"));
        return result;
      }

      inline
      static std::tm* gmtime(const std::time_t* t, std::tm* result)
      {

        result = gmtime_r(t, result);
        if (!result)
          boost::throw_exception(std::runtime_error("could not convert calendar time to UTC time"));
        return result;
      }
# 102 "/usr/include/boost/date_time/c_time.hpp" 3 4
  };
}}
# 22 "/usr/include/boost/date_time/microsec_time_clock.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/time_clock.hpp" 1 3 4
# 19 "/usr/include/boost/date_time/time_clock.hpp" 3 4
namespace boost {
namespace date_time {





  template<class time_type>
  class second_clock
  {
  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;

    static time_type local_time()
    {
      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;

      curr_ptr = c_time::localtime(&t, &curr);
      return create_time(curr_ptr);
    }



    static time_type universal_time()
    {

      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;

      curr_ptr = c_time::gmtime(&t, &curr);
      return create_time(curr_ptr);
    }

    template<class time_zone_type>
    static time_type local_time(boost::shared_ptr<time_zone_type> tz_ptr)
    {
      typedef typename time_type::utc_time_type utc_time_type;
      utc_time_type utc_time = second_clock<utc_time_type>::universal_time();
      return time_type(utc_time, tz_ptr);
    }


  private:
    static time_type create_time(::std::tm* current)
    {
      date_type d(static_cast<unsigned short>(current->tm_year + 1900),
                  static_cast<unsigned short>(current->tm_mon + 1),
                  static_cast<unsigned short>(current->tm_mday));
      time_duration_type td(current->tm_hour,
                            current->tm_min,
                            current->tm_sec);
      return time_type(d,td);
    }

  };


} }
# 23 "/usr/include/boost/date_time/microsec_time_clock.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/filetime_functions.hpp" 1 3 4
# 24 "/usr/include/boost/date_time/microsec_time_clock.hpp" 2 3 4



namespace boost {
namespace date_time {
# 38 "/usr/include/boost/date_time/microsec_time_clock.hpp" 3 4
  template<class time_type>
  class microsec_clock
  {
  private:

    typedef std::tm* (*time_converter)(const std::time_t*, std::tm*);

  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::rep_type resolution_traits_type;



    template<class time_zone_type>
    static time_type local_time(shared_ptr<time_zone_type> tz_ptr)
    {
      typedef typename time_type::utc_time_type utc_time_type;
      typedef second_clock<utc_time_type> second_clock;


      utc_time_type utc_time = second_clock::universal_time();
      time_duration_type utc_offset = second_clock::local_time() - utc_time;


      utc_time = microsec_clock<utc_time_type>::local_time() - utc_offset;
      return time_type(utc_time, tz_ptr);
    }


    static time_type local_time()
    {
      return create_time(&c_time::localtime);
    }


    static time_type universal_time()
    {
      return create_time(&c_time::gmtime);
    }

  private:
    static time_type create_time(time_converter converter)
    {

      timeval tv;
      gettimeofday(&tv, 0);
      std::time_t t = tv.tv_sec;
      boost::uint32_t sub_sec = tv.tv_usec;
# 99 "/usr/include/boost/date_time/microsec_time_clock.hpp" 3 4
      std::tm curr;
      std::tm* curr_ptr = converter(&t, &curr);
      date_type d(curr_ptr->tm_year + 1900,
                  curr_ptr->tm_mon + 1,
                  curr_ptr->tm_mday);





      int adjust = static_cast< int >(resolution_traits_type::res_adjust() / 1000000);

      time_duration_type td(curr_ptr->tm_hour,
                            curr_ptr->tm_min,
                            curr_ptr->tm_sec,
                            sub_sec * adjust);

      return time_type(d,td);
    }
  };


} }
# 10 "/usr/include/boost/thread/thread_time.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 3 4
# 1 "/usr/include/boost/date_time/posix_time/ptime.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/posix_time/ptime.hpp" 3 4
# 1 "/usr/include/boost/date_time/posix_time/posix_time_system.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/posix_time/posix_time_system.hpp" 3 4
# 1 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 3 4
# 1 "/usr/include/c++/4.4/cstdlib" 1 3 4
# 41 "/usr/include/c++/4.4/cstdlib" 3 4
       
# 42 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstdlib" 2 3
# 13 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3 4

# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 15 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/time_duration.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/time_duration.hpp" 3 4
# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/time_duration.hpp" 2 3 4
# 1 "/usr/include/boost/operators.hpp" 1 3 4
# 95 "/usr/include/boost/operators.hpp" 3 4
namespace boost {
namespace detail {

template <typename T> class empty_base {






};

}
}
# 118 "/usr/include/boost/operators.hpp" 3 4
namespace boost
{







template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable2 : B
{
     friend bool operator<=(const T& x, const U& y) { return !static_cast<bool>(x > y); }
     friend bool operator>=(const T& x, const U& y) { return !static_cast<bool>(x < y); }
     friend bool operator>(const U& x, const T& y) { return y < x; }
     friend bool operator<(const U& x, const T& y) { return y > x; }
     friend bool operator<=(const U& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const U& x, const T& y) { return !static_cast<bool>(y > x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable1 : B
{
     friend bool operator>(const T& x, const T& y) { return y < x; }
     friend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }
};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equality_comparable2 : B
{
     friend bool operator==(const U& y, const T& x) { return x == y; }
     friend bool operator!=(const U& y, const T& x) { return !static_cast<bool>(x == y); }
     friend bool operator!=(const T& y, const U& x) { return !static_cast<bool>(y == x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct equality_comparable1 : B
{
     friend bool operator!=(const T& x, const T& y) { return !static_cast<bool>(x == y); }
};
# 254 "/usr/include/boost/operators.hpp" 3 4
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct multipliable2 : B { friend T operator *( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } friend T operator *( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv *= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct multipliable1 : B { friend T operator *( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct addable2 : B { friend T operator +( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } friend T operator +( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv += lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct addable1 : B { friend T operator +( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2 : B { friend T operator -( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2_left : B { friend T operator -( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct subtractable1 : B { friend T operator -( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2 : B { friend T operator /( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2_left : B { friend T operator /( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct dividable1 : B { friend T operator /( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2 : B { friend T operator %( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2_left : B { friend T operator %( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct modable1 : B { friend T operator %( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct xorable2 : B { friend T operator ^( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } friend T operator ^( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv ^= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct xorable1 : B { friend T operator ^( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct andable2 : B { friend T operator &( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } friend T operator &( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv &= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct andable1 : B { friend T operator &( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct orable2 : B { friend T operator |( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } friend T operator |( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv |= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct orable1 : B { friend T operator |( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } };







template <class T, class B = ::boost::detail::empty_base<T> >
struct incrementable : B
{
  friend T operator++(T& x, int)
  {
    incrementable_type nrv(x);
    ++x;
    return nrv;
  }
private:
  typedef T incrementable_type;
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct decrementable : B
{
  friend T operator--(T& x, int)
  {
    decrementable_type nrv(x);
    --x;
    return nrv;
  }
private:
  typedef T decrementable_type;
};



template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct dereferenceable : B
{
  P operator->() const
  {
    return &*static_cast<const T&>(*this);
  }
};

template <class T, class I, class R, class B = ::boost::detail::empty_base<T> >
struct indexable : B
{
  R operator[](I n) const
  {
    return *(static_cast<const T&>(*this) + n);
  }
};
# 352 "/usr/include/boost/operators.hpp" 3 4
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct left_shiftable2 : B { friend T operator <<( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct left_shiftable1 : B { friend T operator <<( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct right_shiftable2 : B { friend T operator >>( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct right_shiftable1 : B { friend T operator >>( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } };



template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equivalent2 : B
{
  friend bool operator==(const T& x, const U& y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(x > y);
  }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct equivalent1 : B
{
  friend bool operator==(const T&x, const T&y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(y < x);
  }
};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct partially_ordered2 : B
{
  friend bool operator<=(const T& x, const U& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const U& y)
    { return static_cast<bool>(x > y) || static_cast<bool>(x == y); }
  friend bool operator>(const U& x, const T& y)
    { return y < x; }
  friend bool operator<(const U& x, const T& y)
    { return y > x; }
  friend bool operator<=(const U& x, const T& y)
    { return static_cast<bool>(y > x) || static_cast<bool>(y == x); }
  friend bool operator>=(const U& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(y == x); }
};

template <class T, class B = ::boost::detail::empty_base<T> >
struct partially_ordered1 : B
{
  friend bool operator>(const T& x, const T& y)
    { return y < x; }
  friend bool operator<=(const T& x, const T& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(x == y); }
};



template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct totally_ordered2
    : less_than_comparable2<T, U
    , equality_comparable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct totally_ordered1
    : less_than_comparable1<T
    , equality_comparable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct additive2
    : addable2<T, U
    , subtractable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct additive1
    : addable1<T
    , subtractable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct multiplicative2
    : multipliable2<T, U
    , dividable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct multiplicative1
    : multipliable1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative2
    : multiplicative2<T, U
    , modable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative1
    : multiplicative1<T
    , modable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct arithmetic2
    : additive2<T, U
    , multiplicative2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct arithmetic1
    : additive1<T
    , multiplicative1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic2
    : additive2<T, U
    , integer_multiplicative2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic1
    : additive1<T
    , integer_multiplicative1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct bitwise2
    : xorable2<T, U
    , andable2<T, U
    , orable2<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct bitwise1
    : xorable1<T
    , andable1<T
    , orable1<T, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct unit_steppable
    : incrementable<T
    , decrementable<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct shiftable2
    : left_shiftable2<T, U
    , right_shiftable2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct shiftable1
    : left_shiftable1<T
    , right_shiftable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ring_operators2
    : additive2<T, U
    , subtractable2_left<T, U
    , multipliable2<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ring_operators1
    : additive1<T
    , multipliable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators2
    : ring_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators1
    : ring_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct field_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct field_operators1
    : ring_operators1<T
    , dividable1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators2
    : field_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators1
    : field_operators1<T
    , totally_ordered1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators2
    : totally_ordered2<T, U
    , euclidian_ring_operators2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators1
    : totally_ordered1<T
    , euclidian_ring_operators1<T, B
      > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct euclidean_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct euclidean_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};

template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidean_ring_operators2
    : totally_ordered2<T, U
    , euclidean_ring_operators2<T, U, B
      > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidean_ring_operators1
    : totally_ordered1<T
    , euclidean_ring_operators1<T, B
      > > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct input_iteratable
    : equality_comparable1<T
    , incrementable<T
    , dereferenceable<T, P, B
      > > > {};

template <class T, class B = ::boost::detail::empty_base<T> >
struct output_iteratable
    : incrementable<T, B
      > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct forward_iteratable
    : input_iteratable<T, P, B
      > {};

template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct bidirectional_iteratable
    : forward_iteratable<T, P
    , decrementable<T, B
      > > {};





template <class T, class P, class D, class R, class B = ::boost::detail::empty_base<T> >
struct random_access_iteratable
    : bidirectional_iteratable<T, P
    , less_than_comparable1<T
    , additive2<T, D
    , indexable<T, D, R, B
      > > > > {};


}
# 718 "/usr/include/boost/operators.hpp" 3 4
namespace boost {


namespace detail {
  struct true_t {};
  struct false_t {};
}




template<class T> struct is_chained_base {
  typedef ::boost::detail::false_t value;
};

}
# 829 "/usr/include/boost/operators.hpp" 3 4
namespace boost {

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct less_than_comparable : less_than_comparable2<T, U, B> {}; template<class T, class U, class B> struct less_than_comparable<T, U, B, ::boost::detail::true_t> : less_than_comparable1<T, U> {}; template <class T, class B> struct less_than_comparable<T, T, B, ::boost::detail::false_t> : less_than_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::less_than_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::less_than_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::less_than_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equality_comparable : equality_comparable2<T, U, B> {}; template<class T, class U, class B> struct equality_comparable<T, U, B, ::boost::detail::true_t> : equality_comparable1<T, U> {}; template <class T, class B> struct equality_comparable<T, T, B, ::boost::detail::false_t> : equality_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equality_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equality_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equality_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multipliable : multipliable2<T, U, B> {}; template<class T, class U, class B> struct multipliable<T, U, B, ::boost::detail::true_t> : multipliable1<T, U> {}; template <class T, class B> struct multipliable<T, T, B, ::boost::detail::false_t> : multipliable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multipliable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multipliable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multipliable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct addable : addable2<T, U, B> {}; template<class T, class U, class B> struct addable<T, U, B, ::boost::detail::true_t> : addable1<T, U> {}; template <class T, class B> struct addable<T, T, B, ::boost::detail::false_t> : addable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::addable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::addable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::addable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct subtractable : subtractable2<T, U, B> {}; template<class T, class U, class B> struct subtractable<T, U, B, ::boost::detail::true_t> : subtractable1<T, U> {}; template <class T, class B> struct subtractable<T, T, B, ::boost::detail::false_t> : subtractable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::subtractable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::subtractable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct dividable : dividable2<T, U, B> {}; template<class T, class U, class B> struct dividable<T, U, B, ::boost::detail::true_t> : dividable1<T, U> {}; template <class T, class B> struct dividable<T, T, B, ::boost::detail::false_t> : dividable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::dividable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::dividable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::dividable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::dividable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct modable : modable2<T, U, B> {}; template<class T, class U, class B> struct modable<T, U, B, ::boost::detail::true_t> : modable1<T, U> {}; template <class T, class B> struct modable<T, T, B, ::boost::detail::false_t> : modable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::modable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::modable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::modable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::modable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct xorable : xorable2<T, U, B> {}; template<class T, class U, class B> struct xorable<T, U, B, ::boost::detail::true_t> : xorable1<T, U> {}; template <class T, class B> struct xorable<T, T, B, ::boost::detail::false_t> : xorable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::xorable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::xorable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::xorable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct andable : andable2<T, U, B> {}; template<class T, class U, class B> struct andable<T, U, B, ::boost::detail::true_t> : andable1<T, U> {}; template <class T, class B> struct andable<T, T, B, ::boost::detail::false_t> : andable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::andable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::andable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::andable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct orable : orable2<T, U, B> {}; template<class T, class U, class B> struct orable<T, U, B, ::boost::detail::true_t> : orable1<T, U> {}; template <class T, class B> struct orable<T, T, B, ::boost::detail::false_t> : orable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::orable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::orable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::orable1<T, B> > { typedef ::boost::detail::true_t value; };

 template<class T, class B> struct is_chained_base< ::boost::incrementable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::decrementable<T, B> > { typedef ::boost::detail::true_t value; };

 template<class T, class U, class B> struct is_chained_base< ::boost::dereferenceable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class B> struct is_chained_base< ::boost::indexable<T, U, V, B> > { typedef ::boost::detail::true_t value; };

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct left_shiftable : left_shiftable2<T, U, B> {}; template<class T, class U, class B> struct left_shiftable<T, U, B, ::boost::detail::true_t> : left_shiftable1<T, U> {}; template <class T, class B> struct left_shiftable<T, T, B, ::boost::detail::false_t> : left_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::left_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::left_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::left_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct right_shiftable : right_shiftable2<T, U, B> {}; template<class T, class U, class B> struct right_shiftable<T, U, B, ::boost::detail::true_t> : right_shiftable1<T, U> {}; template <class T, class B> struct right_shiftable<T, T, B, ::boost::detail::false_t> : right_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::right_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::right_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::right_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equivalent : equivalent2<T, U, B> {}; template<class T, class U, class B> struct equivalent<T, U, B, ::boost::detail::true_t> : equivalent1<T, U> {}; template <class T, class B> struct equivalent<T, T, B, ::boost::detail::false_t> : equivalent1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equivalent<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equivalent2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equivalent1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct partially_ordered : partially_ordered2<T, U, B> {}; template<class T, class U, class B> struct partially_ordered<T, U, B, ::boost::detail::true_t> : partially_ordered1<T, U> {}; template <class T, class B> struct partially_ordered<T, T, B, ::boost::detail::false_t> : partially_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::partially_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::partially_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::partially_ordered1<T, B> > { typedef ::boost::detail::true_t value; };

template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct totally_ordered : totally_ordered2<T, U, B> {}; template<class T, class U, class B> struct totally_ordered<T, U, B, ::boost::detail::true_t> : totally_ordered1<T, U> {}; template <class T, class B> struct totally_ordered<T, T, B, ::boost::detail::false_t> : totally_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::totally_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::totally_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::totally_ordered1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct additive : additive2<T, U, B> {}; template<class T, class U, class B> struct additive<T, U, B, ::boost::detail::true_t> : additive1<T, U> {}; template <class T, class B> struct additive<T, T, B, ::boost::detail::false_t> : additive1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::additive<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::additive2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::additive1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multiplicative : multiplicative2<T, U, B> {}; template<class T, class U, class B> struct multiplicative<T, U, B, ::boost::detail::true_t> : multiplicative1<T, U> {}; template <class T, class B> struct multiplicative<T, T, B, ::boost::detail::false_t> : multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_multiplicative : integer_multiplicative2<T, U, B> {}; template<class T, class U, class B> struct integer_multiplicative<T, U, B, ::boost::detail::true_t> : integer_multiplicative1<T, U> {}; template <class T, class B> struct integer_multiplicative<T, T, B, ::boost::detail::false_t> : integer_multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct arithmetic : arithmetic2<T, U, B> {}; template<class T, class U, class B> struct arithmetic<T, U, B, ::boost::detail::true_t> : arithmetic1<T, U> {}; template <class T, class B> struct arithmetic<T, T, B, ::boost::detail::false_t> : arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_arithmetic : integer_arithmetic2<T, U, B> {}; template<class T, class U, class B> struct integer_arithmetic<T, U, B, ::boost::detail::true_t> : integer_arithmetic1<T, U> {}; template <class T, class B> struct integer_arithmetic<T, T, B, ::boost::detail::false_t> : integer_arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct bitwise : bitwise2<T, U, B> {}; template<class T, class U, class B> struct bitwise<T, U, B, ::boost::detail::true_t> : bitwise1<T, U> {}; template <class T, class B> struct bitwise<T, T, B, ::boost::detail::false_t> : bitwise1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::bitwise<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::bitwise2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::bitwise1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::unit_steppable<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct shiftable : shiftable2<T, U, B> {}; template<class T, class U, class B> struct shiftable<T, U, B, ::boost::detail::true_t> : shiftable1<T, U> {}; template <class T, class B> struct shiftable<T, T, B, ::boost::detail::false_t> : shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ring_operators : ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ring_operators<T, U, B, ::boost::detail::true_t> : ring_operators1<T, U> {}; template <class T, class B> struct ring_operators<T, T, B, ::boost::detail::false_t> : ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_ring_operators : ordered_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_ring_operators1<T, U> {}; template <class T, class B> struct ordered_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct field_operators : field_operators2<T, U, B> {}; template<class T, class U, class B> struct field_operators<T, U, B, ::boost::detail::true_t> : field_operators1<T, U> {}; template <class T, class B> struct field_operators<T, T, B, ::boost::detail::false_t> : field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_field_operators : ordered_field_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_field_operators<T, U, B, ::boost::detail::true_t> : ordered_field_operators1<T, U> {}; template <class T, class B> struct ordered_field_operators<T, T, B, ::boost::detail::false_t> : ordered_field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidian_ring_operators : euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : euclidian_ring_operators1<T, U> {}; template <class T, class B> struct euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidian_ring_operators : ordered_euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_euclidian_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidean_ring_operators : euclidean_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : euclidean_ring_operators1<T, U> {}; template <class T, class B> struct euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::euclidean_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::euclidean_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::euclidean_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidean_ring_operators : ordered_euclidean_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_euclidean_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_euclidean_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_euclidean_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_euclidean_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::input_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::output_iteratable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::forward_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::bidirectional_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class W, class B> struct is_chained_base< ::boost::random_access_iteratable<T, U, V, W, B> > { typedef ::boost::detail::true_t value; };
# 891 "/usr/include/boost/operators.hpp" 3 4
template <class T, class U>
struct operators2
    : totally_ordered2<T,U
    , integer_arithmetic2<T,U
    , bitwise2<T,U
      > > > {};


template <class T, class U = T>
struct operators : operators2<T, U> {};

template <class T> struct operators<T, T>



    : totally_ordered<T
    , integer_arithmetic<T
    , bitwise<T
    , unit_steppable<T
      > > > > {};




template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &>
struct input_iterator_helper
  : input_iteratable<T, P
  , boost::iterator<std::input_iterator_tag, V, D, P, R
    > > {};

template<class T>
struct output_iterator_helper
  : output_iteratable<T
  , boost::iterator<std::output_iterator_tag, void, void, void, void
  > >
{
  T& operator*() { return static_cast<T&>(*this); }
  T& operator++() { return static_cast<T&>(*this); }
};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct forward_iterator_helper
  : forward_iteratable<T, P
  , boost::iterator<std::forward_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct bidirectional_iterator_helper
  : bidirectional_iteratable<T, P
  , boost::iterator<std::bidirectional_iterator_tag, V, D, P, R
    > > {};

template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct random_access_iterator_helper
  : random_access_iteratable<T, P, D, R
  , boost::iterator<std::random_access_iterator_tag, V, D, P, R
    > >
{
  friend D requires_difference_operator(const T& x, const T& y) {
    return x - y;
  }
};

}
# 14 "/usr/include/boost/date_time/time_duration.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/time_defs.hpp" 1 3 4
# 19 "/usr/include/boost/date_time/time_defs.hpp" 3 4
namespace boost {
namespace date_time {


  enum time_resolutions {
    sec,
    tenth,
    hundreth,
    hundredth = hundreth,
    milli,
    ten_thousandth,
    micro,
    nano,
    NumResolutions
  };


  enum dst_flags {not_dst, is_dst, calculate};


} }
# 15 "/usr/include/boost/date_time/time_duration.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/special_defs.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/special_defs.hpp" 3 4
namespace boost {
namespace date_time {

    enum special_values {not_a_date_time,
                         neg_infin, pos_infin,
                         min_date_time, max_date_time,
                         not_special, NumSpecialValues};


} }
# 16 "/usr/include/boost/date_time/time_duration.hpp" 2 3 4


namespace boost {
namespace date_time {
# 32 "/usr/include/boost/date_time/time_duration.hpp" 3 4
  template<class T, typename rep_type>
  class time_duration : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
    > >





  {
  public:
    typedef T duration_type;
    typedef rep_type traits_type;
    typedef typename rep_type::day_type day_type;
    typedef typename rep_type::hour_type hour_type;
    typedef typename rep_type::min_type min_type;
    typedef typename rep_type::sec_type sec_type;
    typedef typename rep_type::fractional_seconds_type fractional_seconds_type;
    typedef typename rep_type::tick_type tick_type;
    typedef typename rep_type::impl_type impl_type;

    time_duration() : ticks_(0) {}
    time_duration(hour_type hours_in,
                  min_type minutes_in,
                  sec_type seconds_in=0,
                  fractional_seconds_type frac_sec_in = 0) :
      ticks_(rep_type::to_tick_count(hours_in,minutes_in,seconds_in,frac_sec_in))
    {}


    time_duration(const time_duration<T, rep_type>& other)
      : ticks_(other.ticks_)
    {}

    time_duration(special_values sv) : ticks_(impl_type::from_special(sv))
    {}

    static duration_type unit()
    {
      return duration_type(0,0,0,1);
    }

    static tick_type ticks_per_second()
    {
      return rep_type::res_adjust();
    }

    static time_resolutions resolution()
    {
      return rep_type::resolution();
    }

    hour_type hours() const
    {
      return static_cast<hour_type>(ticks() / (3600*ticks_per_second()));
    }

    min_type minutes() const
    {
      return static_cast<min_type>((ticks() / (60*ticks_per_second())) % 60);
    }

    sec_type seconds() const
    {
      return static_cast<sec_type>((ticks()/ticks_per_second()) % 60);
    }

    sec_type total_seconds() const
    {
      return static_cast<sec_type>(ticks() / ticks_per_second());
    }

    tick_type total_milliseconds() const
    {
      if (ticks_per_second() < 1000) {
        return ticks() * (static_cast<tick_type>(1000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000)) ;
    }

    tick_type total_nanoseconds() const
    {
      if (ticks_per_second() < 1000000000) {
        return ticks() * (static_cast<tick_type>(1000000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000000)) ;
    }

    tick_type total_microseconds() const
    {
      if (ticks_per_second() < 1000000) {
        return ticks() * (static_cast<tick_type>(1000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000)) ;
    }

    fractional_seconds_type fractional_seconds() const
    {
      return (ticks() % ticks_per_second());
    }

    static unsigned short num_fractional_digits()
    {
      return rep_type::num_fractional_digits();
    }
    duration_type invert_sign() const
    {
      return duration_type(ticks_ * (-1));
    }
    bool is_negative() const
    {
      return ticks_ < 0;
    }
    bool operator<(const time_duration& rhs) const
    {
      return ticks_ < rhs.ticks_;
    }
    bool operator==(const time_duration& rhs) const
    {
      return ticks_ == rhs.ticks_;
    }

    duration_type operator-()const
    {
      return duration_type(ticks_ * (-1));
    }
    duration_type operator-(const duration_type& d) const
    {
      return duration_type(ticks_ - d.ticks_);
    }
    duration_type operator+(const duration_type& d) const
    {
      return duration_type(ticks_ + d.ticks_);
    }
    duration_type operator/(int divisor) const
    {
      return duration_type(ticks_ / divisor);
    }
    duration_type operator-=(const duration_type& d)
    {
      ticks_ = ticks_ - d.ticks_;
      return duration_type(ticks_);
    }
    duration_type operator+=(const duration_type& d)
    {
      ticks_ = ticks_ + d.ticks_;
      return duration_type(ticks_);
    }

    duration_type operator/=(int divisor)
    {
      ticks_ = ticks_ / divisor;
      return duration_type(ticks_);
    }

    duration_type operator*(int rhs) const
    {
      return duration_type(ticks_ * rhs);
    }
    duration_type operator*=(int divisor)
    {
      ticks_ = ticks_ * divisor;
      return duration_type(ticks_);
    }
    tick_type ticks() const
    {
      return traits_type::as_number(ticks_);
    }


    bool is_special()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_special();
      }
      else{
        return false;
      }
    }

    bool is_pos_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_pos_infinity();
      }
      else{
        return false;
      }
    }

    bool is_neg_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_neg_infinity();
      }
      else{
        return false;
      }
    }

    bool is_not_a_date_time()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_nan();
      }
      else{
        return false;
      }
    }


    impl_type get_rep()const
    {
      return ticks_;
    }

  protected:
    explicit time_duration(impl_type in) : ticks_(in) {};
    impl_type ticks_;
  };







  template<class base_duration, boost::int64_t frac_of_second>
  class subsecond_duration : public base_duration
  {
  public:
    typedef typename base_duration::traits_type traits_type;
    explicit subsecond_duration(boost::int64_t ss) :
      base_duration(0,0,0,ss*traits_type::res_adjust()/frac_of_second)
    {}
  };



} }
# 17 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/time_resolution_traits.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/time_resolution_traits.hpp" 3 4
# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 14 "/usr/include/boost/date_time/time_resolution_traits.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/int_adapter.hpp" 1 3 4
# 21 "/usr/include/boost/date_time/int_adapter.hpp" 3 4
namespace boost {
namespace date_time {
# 39 "/usr/include/boost/date_time/int_adapter.hpp" 3 4
template<typename int_type_>
class int_adapter {
public:
  typedef int_type_ int_type;
  int_adapter(int_type v) :
    value_(v)
  {}
  static bool has_infinity()
  {
    return true;
  }
  static const int_adapter pos_infinity()
  {
    return (::std::numeric_limits<int_type>::max)();
  }
  static const int_adapter neg_infinity()
  {
    return (::std::numeric_limits<int_type>::min)();
  }
  static const int_adapter not_a_number()
  {
    return (::std::numeric_limits<int_type>::max)()-1;
  }
  static int_adapter max ()
  {
    return (::std::numeric_limits<int_type>::max)()-2;
  }
  static int_adapter min ()
  {
    return (::std::numeric_limits<int_type>::min)()+1;
  }
  static int_adapter from_special(special_values sv)
  {
    switch (sv) {
    case not_a_date_time: return not_a_number();
    case neg_infin: return neg_infinity();
    case pos_infin: return pos_infinity();
    case max_date_time: return (max)();
    case min_date_time: return (min)();
    default: return not_a_number();
    }
  }
  static bool is_inf(int_type v)
  {
    return (v == neg_infinity().as_number() ||
            v == pos_infinity().as_number());
  }
  static bool is_neg_inf(int_type v)
  {
    return (v == neg_infinity().as_number());
  }
  static bool is_pos_inf(int_type v)
  {
    return (v == pos_infinity().as_number());
  }
  static bool is_not_a_number(int_type v)
  {
    return (v == not_a_number().as_number());
  }

  static special_values to_special(int_type v)
  {
    if (is_not_a_number(v)) return not_a_date_time;
    if (is_neg_inf(v)) return neg_infin;
    if (is_pos_inf(v)) return pos_infin;
    return not_special;
  }


  static int_type maxcount()
  {
    return (::std::numeric_limits<int_type>::max)()-3;
  }
  bool is_infinity() const
  {
    return (value_ == neg_infinity().as_number() ||
            value_ == pos_infinity().as_number());
  }
  bool is_pos_infinity()const
  {
    return(value_ == pos_infinity().as_number());
  }
  bool is_neg_infinity()const
  {
    return(value_ == neg_infinity().as_number());
  }
  bool is_nan() const
  {
    return (value_ == not_a_number().as_number());
  }
  bool is_special() const
  {
    return(is_infinity() || is_nan());
  }
  bool operator==(const int_adapter& rhs) const
  {
    return (compare(rhs) == 0);
  }
  bool operator==(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return false;
      }
    }
    return (compare(rhs) == 0);
  }
  bool operator!=(const int_adapter& rhs) const
  {
    return (compare(rhs) != 0);
  }
  bool operator!=(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) != 0);
  }
  bool operator<(const int_adapter& rhs) const
  {
    return (compare(rhs) == -1);
  }
  bool operator<(const int& rhs) const
  {

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) == -1);
  }
  bool operator>(const int_adapter& rhs) const
  {
    return (compare(rhs) == 1);
  }
  int_type as_number() const
  {
    return value_;
  }

  special_values as_special() const
  {
    return int_adapter::to_special(value_);
  }
# 205 "/usr/include/boost/date_time/int_adapter.hpp" 3 4
  template<class rhs_type>
  inline
  int_adapter operator+(const int_adapter<rhs_type>& rhs) const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_neg_inf(rhs.as_number())) ||
      (is_neg_inf(value_) && rhs.is_pos_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
    }
    return int_adapter<int_type>(value_ + rhs.as_number());
  }

  int_adapter operator+(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ + rhs);
  }



  template<class rhs_type>
  inline
  int_adapter operator-(const int_adapter<rhs_type>& rhs)const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_pos_inf(rhs.as_number())) ||
         (is_neg_inf(value_) && rhs.is_neg_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
    }
    return int_adapter<int_type>(value_ - rhs.as_number());
  }
  int_adapter operator-(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ - rhs);
  }


  int_adapter operator*(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs.value_);
  }


  int_adapter operator*(const int rhs) const
  {
    if(is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs);
  }


  int_adapter operator/(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ / rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ / rhs.value_);
  }


  int_adapter operator/(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ / rhs);
  }


  int_adapter operator%(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ % rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ % rhs.value_);
  }


  int_adapter operator%(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ % rhs);
  }
private:
  int_type value_;


  int compare(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(this->is_nan() || rhs.is_nan()) {
        if(this->is_nan() && rhs.is_nan()) {
          return 0;
        }
        else {
          return 2;
        }
      }
      if((is_neg_inf(value_) && !is_neg_inf(rhs.value_)) ||
         (is_pos_inf(rhs.value_) && !is_pos_inf(value_)) )
        {
          return -1;
        }
      if((is_pos_inf(value_) && !is_pos_inf(rhs.value_)) ||
         (is_neg_inf(rhs.value_) && !is_neg_inf(value_)) ) {
        return 1;
      }
    }
    if(value_ < rhs.value_) return -1;
    if(value_ > rhs.value_) return 1;

    return 0;
  }





  int_adapter mult_div_specials(const int_adapter& rhs)const
  {
    int min_value;

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan() || rhs.is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < min_value)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < min_value) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }

    return int_adapter<int_type>(not_a_number());
  }






  int_adapter mult_div_specials(const int& rhs) const
  {
    int min_value;

    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < 0)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < 0) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }

    return int_adapter<int_type>(not_a_number());
  }

};






  template<class charT, class traits, typename int_type>
  inline
  std::basic_ostream<charT, traits>&
  operator<<(std::basic_ostream<charT, traits>& os, const int_adapter<int_type>& ia)
  {
    if(ia.is_special()) {

      switch(ia.as_special())
        {
      case not_a_date_time:
        os << "not-a-number";
        break;
      case pos_infin:
        os << "+infinity";
        break;
      case neg_infin:
        os << "-infinity";
        break;
      default:
        os << "";
      }
    }
    else {
      os << ia.as_number();
    }
    return os;
  }



} }
# 16 "/usr/include/boost/date_time/time_resolution_traits.hpp" 2 3 4


namespace boost {
namespace date_time {


  template <typename T>


  inline T absolute_value(T x)
  {
    return x < 0 ? -x : x;
  }


  struct time_resolution_traits_bi32_impl {
    typedef boost::int32_t int_type;
    typedef boost::int32_t impl_type;
    static int_type as_number(impl_type i){ return i;}

    static bool is_adapted() { return false;}
  };

  struct time_resolution_traits_adapted32_impl {
    typedef boost::int32_t int_type;
    typedef boost::date_time::int_adapter<boost::int32_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}

    static bool is_adapted() { return true;}
  };

  struct time_resolution_traits_bi64_impl {
    typedef boost::int64_t int_type;
    typedef boost::int64_t impl_type;
    static int_type as_number(impl_type i){ return i;}

    static bool is_adapted() { return false;}
  };

  struct time_resolution_traits_adapted64_impl {
    typedef boost::int64_t int_type;
    typedef boost::date_time::int_adapter<boost::int64_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}

    static bool is_adapted() { return true;}
  };

  template<typename frac_sec_type,
           time_resolutions res,



           typename frac_sec_type::int_type resolution_adjust,

           unsigned short frac_digits,
           typename v_type = boost::int32_t >
  class time_resolution_traits {
  public:
    typedef typename frac_sec_type::int_type fractional_seconds_type;
    typedef typename frac_sec_type::int_type tick_type;
    typedef typename frac_sec_type::impl_type impl_type;
    typedef v_type day_type;
    typedef v_type hour_type;
    typedef v_type min_type;
    typedef v_type sec_type;


    static fractional_seconds_type as_number(impl_type i)
    {
      return frac_sec_type::as_number(i);
    }
    static bool is_adapted()
    {
      return frac_sec_type::is_adapted();
    }





    static const fractional_seconds_type ticks_per_second = resolution_adjust;


    static time_resolutions resolution()
    {
      return res;
    }
    static unsigned short num_fractional_digits()
    {
      return frac_digits;
    }
    static fractional_seconds_type res_adjust()
    {
      return resolution_adjust;
    }

    static tick_type to_tick_count(hour_type hours,
                                   min_type minutes,
                                   sec_type seconds,
                                   fractional_seconds_type fs)
    {
      if(hours < 0 || minutes < 0 || seconds < 0 || fs < 0)
      {
        hours = absolute_value(hours);
        minutes = absolute_value(minutes);
        seconds = absolute_value(seconds);
        fs = absolute_value(fs);
        return (((((fractional_seconds_type(hours)*3600)
                   + (fractional_seconds_type(minutes)*60)
                   + seconds)*res_adjust()) + fs) * -1);
      }

      return (((fractional_seconds_type(hours)*3600)
               + (fractional_seconds_type(minutes)*60)
               + seconds)*res_adjust()) + fs;
    }

  };

  typedef time_resolution_traits<time_resolution_traits_adapted32_impl, milli, 1000, 3 > milli_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, micro, 1000000, 6 > micro_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, nano, 1000000000, 9 > nano_res;


} }
# 18 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 1 3 4
# 17 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 3 4
# 1 "/usr/include/boost/date_time/date.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/date.hpp" 3 4
# 1 "/usr/include/boost/date_time/year_month_day.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/year_month_day.hpp" 3 4
namespace boost {
namespace date_time {


  template<typename YearType, typename MonthType, typename DayType>
  struct year_month_day_base {
    year_month_day_base(YearType year,
                        MonthType month,
                        DayType day);
    YearType year;
    MonthType month;
    DayType day;
    typedef YearType year_type;
    typedef MonthType month_type;
    typedef DayType day_type;
  };



  template<typename YearType, typename MonthType, typename DayType>
  inline
  year_month_day_base<YearType,MonthType,DayType>::year_month_day_base(YearType y,
                                                                       MonthType m,
                                                                       DayType d) :
    year(y),
    month(m),
    day(d)
  {}

} }
# 13 "/usr/include/boost/date_time/date.hpp" 2 3 4



namespace boost {
namespace date_time {
# 52 "/usr/include/boost/date_time/date.hpp" 3 4
  template<class T, class calendar, class duration_type_>
  class date : private
       boost::less_than_comparable<T
     , boost::equality_comparable<T
    > >
  {
  public:
    typedef T date_type;
    typedef calendar calendar_type;
    typedef typename calendar::date_traits_type traits_type;
    typedef duration_type_ duration_type;
    typedef typename calendar::year_type year_type;
    typedef typename calendar::month_type month_type;
    typedef typename calendar::day_type day_type;
    typedef typename calendar::ymd_type ymd_type;
    typedef typename calendar::date_rep_type date_rep_type;
    typedef typename calendar::date_int_type date_int_type;
    typedef typename calendar::day_of_week_type day_of_week_type;
    date(year_type y, month_type m, day_type d)
      : days_(calendar::day_number(ymd_type(y, m, d)))
    {}
    date(const ymd_type& ymd)
      : days_(calendar::day_number(ymd))
      {}

    year_type year() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.year;
    }
    month_type month() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.month;
    }
    day_type day() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.day;
    }
    day_of_week_type day_of_week() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return calendar::day_of_week(ymd);
    }
    ymd_type year_month_day() const
    {
      return calendar::from_day_number(days_);
    }
    bool operator<(const date_type& rhs) const
    {
      return days_ < rhs.days_;
    }
    bool operator==(const date_type& rhs) const
    {
      return days_ == rhs.days_;
    }

    bool is_special()const
    {
      return(is_not_a_date() || is_infinity());
    }

    bool is_not_a_date() const
    {
      return traits_type::is_not_a_number(days_);
    }

    bool is_infinity() const
    {
      return traits_type::is_inf(days_);
    }

    bool is_pos_infinity() const
    {
      return traits_type::is_pos_inf(days_);
    }

    bool is_neg_infinity() const
    {
      return traits_type::is_neg_inf(days_);
    }

    special_values as_special() const
    {
      return traits_type::to_special(days_);
    }
    duration_type operator-(const date_type& d) const
    {
      date_rep_type val = date_rep_type(days_) - date_rep_type(d.days_);
      return duration_type(val.as_number());
    }

    date_type operator-(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) - dd.get_rep());
      }
      return date_type(date_rep_type(days_) - dd.days());
    }
    date_type operator-=(const duration_type& dd)
    {
      *this = *this - dd;
      return date_type(days_);
    }
    date_rep_type day_count() const
    {
      return days_;
    };

    date_type operator+(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) + dd.get_rep());
      }
      return date_type(date_rep_type(days_) + dd.days());
    }
    date_type operator+=(const duration_type& dd)
    {
      *this = *this + dd;
      return date_type(days_);
    }


  protected:




    explicit date(date_int_type days) : days_(days) {};
    explicit date(date_rep_type days) : days_(days.as_number()) {};
    date_int_type days_;

  };




} }
# 18 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/period.hpp" 1 3 4
# 23 "/usr/include/boost/date_time/period.hpp" 3 4
namespace boost {
namespace date_time {
# 50 "/usr/include/boost/date_time/period.hpp" 3 4
  template<class point_rep, class duration_rep>
  class period : private
      boost::less_than_comparable<period<point_rep, duration_rep>
    , boost::equality_comparable< period<point_rep, duration_rep>
    > >
  {
  public:
    typedef point_rep point_type;
    typedef duration_rep duration_type;

    period(point_rep first_point, point_rep end_point);
    period(point_rep first_point, duration_rep len);
    point_rep begin() const;
    point_rep end() const;
    point_rep last() const;
    duration_rep length() const;
    bool is_null() const;
    bool operator==(const period& rhs) const;
    bool operator<(const period& rhs) const;
    void shift(const duration_rep& d);
    void expand(const duration_rep& d);
    bool contains(const point_rep& point) const;
    bool contains(const period& other) const;
    bool intersects(const period& other) const;
    bool is_adjacent(const period& other) const;
    bool is_before(const point_rep& point) const;
    bool is_after(const point_rep& point) const;
    period intersection(const period& other) const;
    period merge(const period& other) const;
    period span(const period& other) const;
  private:
    point_rep begin_;
    point_rep last_;
  };




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point,
                                         point_rep end_point) :
    begin_(first_point),
    last_(end_point - duration_rep::unit())
  {}




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point, duration_rep len) :
    begin_(first_point),
    last_(first_point + len-duration_rep::unit())
  { }



  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::begin() const
  {
    return begin_;
  }


  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::end() const
  {
    return last_ + duration_rep::unit();
  }


  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::last() const
  {
    return last_;
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::is_null() const
  {
    return end() <= begin_;
  }


  template<class point_rep, class duration_rep>
  inline
  duration_rep period<point_rep,duration_rep>::length() const
  {
    if(last_ < begin_){
      return last_+duration_rep::unit() - begin_;
    }
    else{
      return end() - begin_;
    }
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator==(const period& rhs) const
  {
    return ((begin_ == rhs.begin_) &&
             (last_ == rhs.last_));
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator<(const period& rhs) const
  {
    return (last_ < rhs.begin_);
  }



  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::shift(const duration_rep& d)
  {
    begin_ = begin_ + d;
    last_ = last_ + d;
  }
# 198 "/usr/include/boost/date_time/period.hpp" 3 4
  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::expand(const duration_rep& d)
  {
    begin_ = begin_ - d;
    last_ = last_ + d;
  }


  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const point_rep& point) const
  {
    return ((point >= begin_) &&
            (point <= last_));
  }



  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const period<point_rep,duration_rep>& other) const
  {
    return ((begin_ <= other.begin_) && (last_ >= other.last_));
  }
# 234 "/usr/include/boost/date_time/period.hpp" 3 4
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_adjacent(const period<point_rep,duration_rep>& other) const
  {
    return (other.begin() == end() ||
            begin_ == other.end());
  }
# 253 "/usr/include/boost/date_time/period.hpp" 3 4
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_after(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }

    return t < begin_;
  }
# 275 "/usr/include/boost/date_time/period.hpp" 3 4
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_before(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }

    return last_ < t;
  }
# 300 "/usr/include/boost/date_time/period.hpp" 3 4
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::intersects(const period<point_rep,duration_rep>& other) const
  {
    return ( contains(other.begin_) ||
             other.contains(begin_) ||
             ((other.begin_ < begin_) && (other.last_ >= begin_)));
  }


  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::intersection(const period<point_rep,duration_rep>& other) const
  {
    if (begin_ > other.begin_) {
      if (last_ <= other.last_) {
        return *this;
      }

      return period<point_rep,duration_rep>(begin_, other.end());
    }
    else {
      if (last_ <= other.last_) {
        return period<point_rep,duration_rep>(other.begin_, this->end());
      }

      return other;
    }

  }




  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::merge(const period<point_rep,duration_rep>& other) const
  {
    if (this->intersects(other)) {
      if (begin_ < other.begin_) {
        return period<point_rep,duration_rep>(begin_, last_ > other.last_ ? this->end() : other.end());
      }

      return period<point_rep,duration_rep>(other.begin_, last_ > other.last_ ? this->end() : other.end());

    }
    return period<point_rep,duration_rep>(begin_,begin_);
  }
# 362 "/usr/include/boost/date_time/period.hpp" 3 4
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::span(const period<point_rep,duration_rep>& other) const
  {
    point_rep start((begin_ < other.begin_) ? begin() : other.begin());
    point_rep newend((last_ < other.last_) ? other.end() : this->end());
    return period<point_rep,duration_rep>(start, newend);
  }


} }
# 19 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_calendar.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/gregorian/greg_calendar.hpp" 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_weekday.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/gregorian/greg_weekday.hpp" 3 4
# 1 "/usr/include/boost/date_time/constrained_value.hpp" 1 3 4
# 17 "/usr/include/boost/date_time/constrained_value.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_base_of.hpp" 1 3 4
# 12 "/usr/include/boost/type_traits/is_base_of.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_base_and_derived.hpp" 1 3 4
# 24 "/usr/include/boost/type_traits/is_base_and_derived.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 25 "/usr/include/boost/type_traits/is_base_and_derived.hpp" 2 3 4

namespace boost {

namespace detail {
# 222 "/usr/include/boost/type_traits/is_base_and_derived.hpp" 3 4
template <typename B, typename D>
struct is_base_and_derived_impl
{
    static const bool value = (__is_base_of(B,D) && !is_same<B,D>::value);
};

}

template< typename Base, typename Derived > struct is_base_and_derived : ::boost::integral_constant<bool,(::boost::detail::is_base_and_derived_impl<Base,Derived>::value)> { };







template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_and_derived< Base,Derived& > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived& > : ::boost::integral_constant<bool,false> { };






}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 250 "/usr/include/boost/type_traits/is_base_and_derived.hpp" 2 3 4
# 13 "/usr/include/boost/type_traits/is_base_of.hpp" 2 3 4




# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 18 "/usr/include/boost/type_traits/is_base_of.hpp" 2 3 4

namespace boost {

template< typename Base, typename Derived > struct is_base_of : ::boost::integral_constant<bool,(::boost::type_traits::ice_or< (::boost::detail::is_base_and_derived_impl<Base,Derived>::value), (::boost::is_same<Base,Derived>::value)>::value)> { };
# 31 "/usr/include/boost/type_traits/is_base_of.hpp" 3 4
template< typename Base, typename Derived > struct is_base_of< Base&,Derived > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_of< Base,Derived& > : ::boost::integral_constant<bool,false> { };
template< typename Base, typename Derived > struct is_base_of< Base&,Derived& > : ::boost::integral_constant<bool,false> { };


}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 39 "/usr/include/boost/type_traits/is_base_of.hpp" 2 3 4
# 18 "/usr/include/boost/date_time/constrained_value.hpp" 2 3 4

namespace boost {


namespace CV {

  enum violation_enum {min_violation, max_violation};
# 41 "/usr/include/boost/date_time/constrained_value.hpp" 3 4
  template<class value_policies>
  class constrained_value {
  public:
    typedef typename value_policies::value_type value_type;

    constrained_value(value_type value) : value_((min)())
    {
      assign(value);
    }
    constrained_value& operator=(value_type v)
    {
      assign(v);
      return *this;
    }

    static value_type max () {return (value_policies::max)();}

    static value_type min () {return (value_policies::min)();}

    operator value_type() const {return value_;}
  protected:
    value_type value_;
  private:
    void assign(value_type value)
    {


      if (value+1 < (min)()+1) {
        value_policies::on_error(value_, value, min_violation);
        return;
      }
      if (value > (max)()) {
        value_policies::on_error(value_, value, max_violation);
        return;
      }
      value_ = value;
    }
};


  template<typename rep_type, rep_type min_value,
           rep_type max_value, class exception_type>
  class simple_exception_policy
  {
    struct exception_wrapper : public exception_type
    {




      operator std::out_of_range () const
      {

        return std::out_of_range("constrained value boundary has been violated");
      }
    };

    typedef typename mpl::if_<
      is_base_of< std::exception, exception_type >,
      exception_type,
      exception_wrapper
    >::type actual_exception_type;

  public:
    typedef rep_type value_type;
    static rep_type min () { return min_value; }
    static rep_type max () { return max_value; }
    static void on_error(rep_type, rep_type, violation_enum)
    {
      boost::throw_exception(actual_exception_type());
    }
  };



} }
# 13 "/usr/include/boost/date_time/gregorian/greg_weekday.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/date_defs.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/date_defs.hpp" 3 4
namespace boost {
namespace date_time {


  enum weekdays {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};


  enum months_of_year {Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec,NotAMonth,NumMonths};

} }
# 14 "/usr/include/boost/date_time/gregorian/greg_weekday.hpp" 2 3 4




namespace boost {
namespace gregorian {


  using date_time::Sunday;
  using date_time::Monday;
  using date_time::Tuesday;
  using date_time::Wednesday;
  using date_time::Thursday;
  using date_time::Friday;
  using date_time::Saturday;



  struct bad_weekday : public std::out_of_range
  {
    bad_weekday() : std::out_of_range(std::string("Weekday is out of range 0..6")) {}
  };
  typedef CV::simple_exception_policy<unsigned short, 0, 6, bad_weekday> greg_weekday_policies;
  typedef CV::constrained_value<greg_weekday_policies> greg_weekday_rep;



  class greg_weekday : public greg_weekday_rep {
  public:
    typedef boost::date_time::weekdays weekday_enum;
    greg_weekday(unsigned short day_of_week_num) :
      greg_weekday_rep(day_of_week_num)
    {}

    unsigned short as_number() const {return value_;}
    const char* as_short_string() const;
    const char* as_long_string() const;

    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;

    weekday_enum as_enum() const {return static_cast<weekday_enum>(value_);}


  };



} }
# 13 "/usr/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_day_of_year.hpp" 1 3 4
# 16 "/usr/include/boost/date_time/gregorian/greg_day_of_year.hpp" 3 4
namespace boost {
namespace gregorian {


  struct bad_day_of_year : public std::out_of_range
  {
    bad_day_of_year() :
      std::out_of_range(std::string("Day of year value is out of range 1..366"))
    {}
  };


  typedef CV::simple_exception_policy<unsigned short,1,366,bad_day_of_year> greg_day_of_year_policies;


  typedef CV::constrained_value<greg_day_of_year_policies> greg_day_of_year_rep;


} }
# 14 "/usr/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian_calendar.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/gregorian_calendar.hpp" 3 4
namespace boost {
namespace date_time {
# 27 "/usr/include/boost/date_time/gregorian_calendar.hpp" 3 4
  template<typename ymd_type_, typename date_int_type_>
  class gregorian_calendar_base {
  public:

    typedef ymd_type_ ymd_type;

    typedef typename ymd_type::month_type month_type;

    typedef typename ymd_type::day_type day_type;

    typedef typename ymd_type::year_type year_type;

    typedef date_int_type_ date_int_type;


    static unsigned short day_of_week(const ymd_type& ymd);
    static int week_number(const ymd_type&ymd);

    static date_int_type day_number(const ymd_type& ymd);
    static date_int_type julian_day_number(const ymd_type& ymd);
    static long modjulian_day_number(const ymd_type& ymd);
    static ymd_type from_day_number(date_int_type);
    static ymd_type from_julian_day_number(date_int_type);
    static ymd_type from_modjulian_day_number(long);
    static bool is_leap_year(year_type);
    static unsigned short end_of_month_day(year_type y, month_type m);
    static ymd_type epoch();
    static unsigned short days_in_week();

  };



} }


# 1 "/usr/include/boost/date_time/gregorian_calendar.ipp" 1 3 4
# 14 "/usr/include/boost/date_time/gregorian_calendar.ipp" 3 4
namespace boost {
namespace date_time {



  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_of_week(const ymd_type& ymd) {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 2);
    unsigned short d = static_cast<unsigned short>((ymd.day + y + (y/4) - (y/100) + (y/400) + (31*m)/12) % 7);

    return d;
  }







  template<typename ymd_type_, typename date_int_type_>
  inline
  int
  gregorian_calendar_base<ymd_type_,date_int_type_>::week_number(const ymd_type& ymd) {
    unsigned long julianbegin = julian_day_number(ymd_type(ymd.year,1,1));
    unsigned long juliantoday = julian_day_number(ymd);
    unsigned long day = (julianbegin + 3) % 7;
    unsigned long week = (juliantoday + day - julianbegin + 4)/7;

    if ((week >= 1) && (week <= 52)) {
      return week;
    }

    if ((week == 53)) {
      if((day==6) ||(day == 5 && is_leap_year(ymd.year))) {
        return week;
      } else {
        return 1;
      }
    }

    else if (week == 0) {
      julianbegin = julian_day_number(ymd_type(static_cast<unsigned short>(ymd.year-1),1,1));
      juliantoday = julian_day_number(ymd);
      day = (julianbegin + 3) % 7;
      week = (juliantoday + day - julianbegin + 4)/7;
      return week;
    }

    return week;

  }




  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_number(const ymd_type& ymd)
  {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year + 4800 - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 3);
    unsigned long d = ymd.day + ((153*m + 2)/5) + 365*y + (y/4) - (y/100) + (y/400) - 32045;
    return d;
  }




  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::julian_day_number(const ymd_type& ymd)
  {
    return day_number(ymd);
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  long
  gregorian_calendar_base<ymd_type_,date_int_type_>::modjulian_day_number(const ymd_type& ymd)
  {
    return julian_day_number(ymd)-2400001;
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a + 3)/146097;
    date_int_type c = a-((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - (1461*d)/4;
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<unsigned short>(100*b + d - 4800 + (m/10));


    return ymd_type(static_cast<unsigned short>(year),month,day);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_julian_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a+3)/146097;
    date_int_type c = a - ((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - ((1461*d)/4);
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<year_type>(100*b + d - 4800 + (m/10));


    return ymd_type(year,month,day);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_modjulian_day_number(long dayNumber) {
    date_int_type jd = dayNumber + 2400001;
    return from_julian_day_number(jd);
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  bool
  gregorian_calendar_base<ymd_type_,date_int_type_>::is_leap_year(year_type year)
  {

    return (!(year % 4)) && ((year % 100) || (!(year % 400)));
  }





  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::end_of_month_day(year_type year,
                                                                      month_type month)
  {
    switch (month) {
    case 2:
      if (is_leap_year(year)) {
        return 29;
      } else {
        return 28;
      };
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
    default:
      return 31;
    };

  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::epoch()
  {
    return ymd_type(1400,1,1);
  }


  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::days_in_week()
  {
    return 7;
  }


} }
# 64 "/usr/include/boost/date_time/gregorian_calendar.hpp" 2 3 4
# 15 "/usr/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_ymd.hpp" 1 3 4
# 14 "/usr/include/boost/date_time/gregorian/greg_ymd.hpp" 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_day.hpp" 1 3 4
# 16 "/usr/include/boost/date_time/gregorian/greg_day.hpp" 3 4
namespace boost {
namespace gregorian {


  struct bad_day_of_month : public std::out_of_range
  {
    bad_day_of_month() :
      std::out_of_range(std::string("Day of month value is out of range 1..31"))
    {}

    bad_day_of_month(const std::string& s) :
      std::out_of_range(s)
    {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1, 31, bad_day_of_month> greg_day_policies;


  typedef CV::constrained_value<greg_day_policies> greg_day_rep;







  class greg_day : public greg_day_rep {
  public:
    greg_day(unsigned short day_of_month) : greg_day_rep(day_of_month) {}
    unsigned short as_number() const {return value_;}
    operator unsigned short() const {return value_;}
  private:

  };



} }
# 15 "/usr/include/boost/date_time/gregorian/greg_ymd.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_year.hpp" 1 3 4
# 16 "/usr/include/boost/date_time/gregorian/greg_year.hpp" 3 4
namespace boost {
namespace gregorian {


  struct bad_year : public std::out_of_range
  {
    bad_year() :
      std::out_of_range(std::string("Year is out of valid range: 1400..10000"))
    {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1400, 10000, bad_year> greg_year_policies;


  typedef CV::constrained_value<greg_year_policies> greg_year_rep;
# 39 "/usr/include/boost/date_time/gregorian/greg_year.hpp" 3 4
  class greg_year : public greg_year_rep {
  public:
    greg_year(unsigned short year) : greg_year_rep(year) {}
    operator unsigned short() const {return value_;}
  private:

  };



} }
# 16 "/usr/include/boost/date_time/gregorian/greg_ymd.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_month.hpp" 1 3 4
# 20 "/usr/include/boost/date_time/gregorian/greg_month.hpp" 3 4
# 1 "/usr/include/c++/4.4/cctype" 1 3 4
# 41 "/usr/include/c++/4.4/cctype" 3 4
       
# 42 "/usr/include/c++/4.4/cctype" 3
# 21 "/usr/include/boost/date_time/gregorian/greg_month.hpp" 2 3 4

namespace boost {
namespace gregorian {

  typedef date_time::months_of_year months_of_year;


  using date_time::Jan;
  using date_time::Feb;
  using date_time::Mar;
  using date_time::Apr;
  using date_time::May;
  using date_time::Jun;
  using date_time::Jul;
  using date_time::Aug;
  using date_time::Sep;
  using date_time::Oct;
  using date_time::Nov;
  using date_time::Dec;
  using date_time::NotAMonth;
  using date_time::NumMonths;


  struct bad_month : public std::out_of_range
  {
    bad_month() : std::out_of_range(std::string("Month number is out of range 1..12")) {}
  };

  typedef CV::simple_exception_policy<unsigned short, 1, 12, bad_month> greg_month_policies;

  typedef CV::constrained_value<greg_month_policies> greg_month_rep;



  class greg_month : public greg_month_rep {
  public:
    typedef date_time::months_of_year month_enum;
    typedef std::map<std::string, unsigned short> month_map_type;
    typedef boost::shared_ptr<month_map_type> month_map_ptr_type;

    greg_month(month_enum theMonth) :
      greg_month_rep(static_cast<greg_month_rep::value_type>(theMonth)) {}

    greg_month(unsigned short theMonth) : greg_month_rep(theMonth) {}

    operator unsigned short() const {return value_;}

    unsigned short as_number() const {return value_;}
    month_enum as_enum() const {return static_cast<month_enum>(value_);}
    const char* as_short_string() const;
    const char* as_long_string() const;

    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;


    static month_map_ptr_type get_month_map_ptr();



    const char* as_short_string(char) const
    {
      return as_short_string();
    }
    const char* as_long_string(char) const
    {
      return as_long_string();
    }

    const wchar_t* as_short_string(wchar_t) const
    {
      return as_short_wstring();
    }
    const wchar_t* as_long_string(wchar_t) const
    {
      return as_long_wstring();
    }

  };

} }
# 17 "/usr/include/boost/date_time/gregorian/greg_ymd.hpp" 2 3 4

namespace boost {
namespace gregorian {

  typedef date_time::year_month_day_base<greg_year,
                                         greg_month,
                                         greg_day> greg_year_month_day;



} }
# 16 "/usr/include/boost/date_time/gregorian/greg_calendar.hpp" 2 3 4


namespace boost {
namespace gregorian {


  typedef date_time::int_adapter<unsigned long> fancy_date_rep;


  class gregorian_calendar :
    public date_time::gregorian_calendar_base<greg_year_month_day, fancy_date_rep::int_type> {
  public:

    typedef greg_weekday day_of_week_type;

    typedef greg_day_of_year_rep day_of_year_type;

    typedef fancy_date_rep date_rep_type;

    typedef fancy_date_rep date_traits_type;


  private:
  };

} }
# 20 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_duration.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/gregorian/greg_duration.hpp" 3 4
# 1 "/usr/include/boost/date_time/date_duration.hpp" 1 3 4
# 16 "/usr/include/boost/date_time/date_duration.hpp" 3 4
namespace boost {
namespace date_time {



  template<class duration_rep_traits>
  class date_duration : private
              boost::less_than_comparable1< date_duration< duration_rep_traits >
            , boost::equality_comparable1< date_duration< duration_rep_traits >
            , boost::addable1< date_duration< duration_rep_traits >
            , boost::subtractable1< date_duration< duration_rep_traits >
            , boost::dividable2< date_duration< duration_rep_traits >, int
            > > > > >
  {
  public:
    typedef typename duration_rep_traits::int_type duration_rep_type;
    typedef typename duration_rep_traits::impl_type duration_rep;


    explicit date_duration(duration_rep day_count) : days_(day_count) {};



    date_duration(special_values sv) :
            days_(duration_rep::from_special(sv))
    {}



    date_duration(const date_duration<duration_rep_traits>& other) :
            days_(other.days_)
    {}


    duration_rep get_rep()const
    {
        return days_;
    }
    bool is_special()const
    {
        return days_.is_special();
    }

    duration_rep_type days() const
    {
        return duration_rep_traits::as_number(days_);
    }

    static date_duration unit()
    {
        return date_duration<duration_rep_traits>(1);
    }

    bool operator==(const date_duration& rhs) const
    {
        return days_ == rhs.days_;
    }

    bool operator<(const date_duration& rhs) const
    {
        return days_ < rhs.days_;
    }







    date_duration& operator-=(const date_duration& rhs)
    {

        days_ = days_ - rhs.days_;
        return *this;
    }

    date_duration& operator+=(const date_duration& rhs)
    {
        days_ = days_ + rhs.days_;
        return *this;
    }


    date_duration operator-() const
    {
        return date_duration<duration_rep_traits>(get_rep() * (-1));
    }

    date_duration& operator/=(int divisor)
    {
        days_ = days_ / divisor;
        return *this;
    }


    bool is_negative() const
    {
        return days_ < 0;
    }

  private:
    duration_rep days_;
  };





  struct duration_traits_long
  {
    typedef long int_type;
    typedef long impl_type;
    static int_type as_number(impl_type i) { return i; };
  };




  struct duration_traits_adapted
  {
    typedef long int_type;
    typedef boost::date_time::int_adapter<long> impl_type;
    static int_type as_number(impl_type i) { return i.as_number(); };
  };


} }
# 13 "/usr/include/boost/date_time/gregorian/greg_duration.hpp" 2 3 4



namespace boost {
namespace gregorian {


  typedef boost::date_time::duration_traits_adapted date_duration_rep;




  class date_duration :
    public boost::date_time::date_duration< date_duration_rep >
  {
    typedef boost::date_time::date_duration< date_duration_rep > base_type;

  public:
    typedef base_type::duration_rep duration_rep;


    explicit date_duration(duration_rep day_count = 0) : base_type(day_count) {}


    date_duration(date_time::special_values sv) : base_type(sv) {}


    date_duration(const date_duration& other) : base_type(static_cast< base_type const& >(other))
    {}


    date_duration(const base_type& other) : base_type(other)
    {}





    bool operator== (const date_duration& rhs) const
    {
      return base_type::operator== (rhs);
    }
    bool operator!= (const date_duration& rhs) const
    {
      return !operator== (rhs);
    }
    bool operator< (const date_duration& rhs) const
    {
      return base_type::operator< (rhs);
    }
    bool operator> (const date_duration& rhs) const
    {
      return !(base_type::operator< (rhs) || base_type::operator== (rhs));
    }
    bool operator<= (const date_duration& rhs) const
    {
      return (base_type::operator< (rhs) || base_type::operator== (rhs));
    }
    bool operator>= (const date_duration& rhs) const
    {
      return !base_type::operator< (rhs);
    }


    date_duration& operator-= (const date_duration& rhs)
    {
      base_type::operator-= (rhs);
      return *this;
    }
    friend date_duration operator- (date_duration rhs, date_duration const& lhs)
    {
      rhs -= lhs;
      return rhs;
    }


    date_duration& operator+= (const date_duration& rhs)
    {
      base_type::operator+= (rhs);
      return *this;
    }
    friend date_duration operator+ (date_duration rhs, date_duration const& lhs)
    {
      rhs += lhs;
      return rhs;
    }


    date_duration operator- ()const
    {
      return date_duration(get_rep() * (-1));
    }


    date_duration& operator/= (int divisor)
    {
      base_type::operator/= (divisor);
      return *this;
    }
    friend date_duration operator/ (date_duration rhs, int lhs)
    {
      rhs /= lhs;
      return rhs;
    }


    static date_duration unit()
    {
      return date_duration(base_type::unit().get_rep());
    }
  };


  typedef date_duration days;

} }


# 1 "/usr/include/boost/date_time/date_duration_types.hpp" 1 3 4
# 16 "/usr/include/boost/date_time/date_duration_types.hpp" 3 4
namespace boost {
namespace date_time {



  template <class duration_config>
  class weeks_duration : public date_duration<duration_config> {
  public:
    weeks_duration(typename duration_config::impl_type w)
      : date_duration<duration_config>(w * 7) {}
    weeks_duration(special_values sv)
      : date_duration<duration_config>(sv) {}
  };


  template<class t>
  class years_duration;






  template<class base_config>
  class months_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef months_duration<base_config> months_type;
      typedef years_duration<base_config> years_type;
    public:
      months_duration(int_rep num) : _m(num) {}
      months_duration(special_values sv) : _m(sv)
      {
        _m = int_rep::from_special(sv);
      }
      int_rep number_of_months() const { return _m; }

      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const months_type& rhs) const
      {
        return(_m == rhs._m);
      }
      bool operator!=(const months_type& rhs) const
      {
        return(_m != rhs._m);
      }
      months_type operator+(const months_type& rhs)const
      {
        return months_type(_m + rhs._m);
      }
      months_type& operator+=(const months_type& rhs)
      {
        _m = _m + rhs._m;
        return *this;
      }
      months_type operator-(const months_type& rhs)const
      {
        return months_type(_m - rhs._m);
      }
      months_type& operator-=(const months_type& rhs)
      {
        _m = _m - rhs._m;
        return *this;
      }
      months_type operator*(const int_type rhs)const
      {
        return months_type(_m * rhs);
      }
      months_type& operator*=(const int_type rhs)
      {
        _m = _m * rhs;
        return *this;
      }
      months_type operator/(const int_type rhs)const
      {
        return months_type(_m / rhs);
      }
      months_type& operator/=(const int_type rhs)
      {
        _m = _m / rhs;
        return *this;
      }
      months_type operator+(const years_type& y)const
      {
        return months_type(y.number_of_years() * 12 + _m);
      }
      months_type& operator+=(const years_type& y)
      {
        _m = y.number_of_years() * 12 + _m;
        return *this;
      }
      months_type operator-(const years_type& y) const
      {
        return months_type(_m - y.number_of_years() * 12);
      }
      months_type& operator-=(const years_type& y)
      {
        _m = _m - y.number_of_years() * 12;
        return *this;
      }


      friend date_type operator+(const date_type& d, const months_type& m)
      {
        return d + m.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const months_type& m)
      {
        return d += m.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const months_type& m)
      {

        return d + m.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const months_type& m)
      {

        return d += m.get_neg_offset(d);
      }

    private:
      int_rep _m;
  };







  template<class base_config>
  class years_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef years_duration<base_config> years_type;
      typedef months_duration<base_config> months_type;
    public:
      years_duration(int_rep num) : _y(num) {}
      years_duration(special_values sv) : _y(sv)
      {
        _y = int_rep::from_special(sv);
      }
      int_rep number_of_years() const { return _y; }

      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const years_type& rhs) const
      {
        return(_y == rhs._y);
      }
      bool operator!=(const years_type& rhs) const
      {
        return(_y != rhs._y);
      }
      years_type operator+(const years_type& rhs)const
      {
        return years_type(_y + rhs._y);
      }
      years_type& operator+=(const years_type& rhs)
      {
        _y = _y + rhs._y;
        return *this;
      }
      years_type operator-(const years_type& rhs)const
      {
        return years_type(_y - rhs._y);
      }
      years_type& operator-=(const years_type& rhs)
      {
        _y = _y - rhs._y;
        return *this;
      }
      years_type operator*(const int_type rhs)const
      {
        return years_type(_y * rhs);
      }
      years_type& operator*=(const int_type rhs)
      {
        _y = _y * rhs;
        return *this;
      }
      years_type operator/(const int_type rhs)const
      {
        return years_type(_y / rhs);
      }
      years_type& operator/=(const int_type rhs)
      {
        _y = _y / rhs;
        return *this;
      }
      months_type operator+(const months_type& m) const
      {
        return(months_type(_y * 12 + m.number_of_months()));
      }
      months_type operator-(const months_type& m) const
      {
        return(months_type(_y * 12 - m.number_of_months()));
      }


      friend date_type operator+(const date_type& d, const years_type& y)
      {
        return d + y.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const years_type& y)
      {
        return d += y.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const years_type& y)
      {

        return d + y.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const years_type& y)
      {

        return d += y.get_neg_offset(d);
      }

    private:
      int_rep _y;
  };

}}
# 132 "/usr/include/boost/date_time/gregorian/greg_duration.hpp" 2 3 4
# 21 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/gregorian/greg_duration_types.hpp" 1 3 4
# 12 "/usr/include/boost/date_time/gregorian/greg_duration_types.hpp" 3 4
# 1 "/usr/include/boost/date_time/gregorian/greg_date.hpp" 1 3 4
# 18 "/usr/include/boost/date_time/gregorian/greg_date.hpp" 3 4
namespace boost {
namespace gregorian {


  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;
# 37 "/usr/include/boost/date_time/gregorian/greg_date.hpp" 3 4
  class date : public date_time::date<date, gregorian_calendar, date_duration>
  {
   public:
    typedef gregorian_calendar::year_type year_type;
    typedef gregorian_calendar::month_type month_type;
    typedef gregorian_calendar::day_type day_type;
    typedef gregorian_calendar::day_of_year_type day_of_year_type;
    typedef gregorian_calendar::ymd_type ymd_type;
    typedef gregorian_calendar::date_rep_type date_rep_type;
    typedef gregorian_calendar::date_int_type date_int_type;
    typedef date_duration duration_type;


    date():
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(not_a_date_time))
    {}


    date(year_type y, month_type m, day_type d)
      : date_time::date<date, gregorian_calendar, date_duration>(y, m, d)
    {
      if (gregorian_calendar::end_of_month_day(y, m) < d) {
        boost::throw_exception(bad_day_of_month(std::string("Day of month is not valid for year")));
      }
    }

    explicit date(const ymd_type& ymd)
      : date_time::date<date, gregorian_calendar, date_duration>(ymd)
    {}

    explicit date(const date_int_type& rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}

    explicit date(date_rep_type rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}

    explicit date(special_values sv):
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(sv))
    {
      if (sv == min_date_time)
      {
        *this = date(1400, 1, 1);
      }
      if (sv == max_date_time)
      {
        *this = date(9999, 12, 31);
      }

    }

    date_int_type julian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::julian_day_number(ymd);
    }

    day_of_year_type day_of_year() const
    {
      date start_of_year(year(), 1, 1);
      unsigned short doy = static_cast<unsigned short>((*this-start_of_year).days() + 1);
      return day_of_year_type(doy);
    }

    long modjulian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::modjulian_day_number(ymd);
    }

    int week_number() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::week_number(ymd);
    }

    date_int_type day_number() const
    {
      return days_;
    }

    date end_of_month() const
    {
      ymd_type ymd = year_month_day();
      short eom_day = gregorian_calendar::end_of_month_day(ymd.year, ymd.month);
      return date(ymd.year, ymd.month, eom_day);
    }

   private:

  };



} }
# 13 "/usr/include/boost/date_time/gregorian/greg_duration_types.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/adjust_functors.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/adjust_functors.hpp" 3 4
# 1 "/usr/include/boost/date_time/wrapping_int.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/wrapping_int.hpp" 3 4
namespace boost {
namespace date_time {
# 30 "/usr/include/boost/date_time/wrapping_int.hpp" 3 4
template<typename int_type_, int_type_ wrap_val>
class wrapping_int {
public:
  typedef int_type_ int_type;

  static int_type wrap_value() {return wrap_val;}

  wrapping_int(int_type v) : value_(v) {};

  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}





  template< typename IntT >
  IntT add(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    IntT overflow = static_cast<IntT>(v / (wrap_val));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }






  template< typename IntT >
  IntT subtract(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    IntT underflow = static_cast<IntT>(-(v / (wrap_val)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow) * -1;
  }
private:
  int_type value_;

  template< typename IntT >
  IntT calculate_wrap(IntT wrap)
  {
    if ((value_) >= wrap_val)
    {
      ++wrap;
      value_ -= (wrap_val);
    }
    else if(value_ < 0)
    {
      --wrap;
      value_ += (wrap_val);
    }
    return wrap;
  }

};






template<typename int_type_, int_type_ wrap_min, int_type_ wrap_max>
class wrapping_int2 {
public:
  typedef int_type_ int_type;
  static int_type wrap_value() {return wrap_max;}
  static int_type min_value() {return wrap_min;}


  wrapping_int2(int_type v) : value_(v) {
    if(value_ < wrap_min)
    {
      value_ = wrap_min;
    }
    if(value_ > wrap_max)
    {
      value_ = wrap_max;
    }
  }

  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}





  template< typename IntT >
  IntT add(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    IntT overflow = static_cast<IntT>(v / (wrap_max - wrap_min + 1));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }





  template< typename IntT >
  IntT subtract(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    IntT underflow = static_cast<IntT>(-(v / (wrap_max - wrap_min + 1)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow);
  }

private:
  int_type value_;

  template< typename IntT >
  IntT calculate_wrap(IntT wrap)
  {
    if ((value_) > wrap_max)
    {
      ++wrap;
      value_ -= (wrap_max - wrap_min + 1);
    }
    else if((value_) < wrap_min)
    {
      --wrap;
      value_ += (wrap_max - wrap_min + 1);
    }
    return wrap;
  }
};



} }
# 14 "/usr/include/boost/date_time/adjust_functors.hpp" 2 3 4

namespace boost {
namespace date_time {



  template<class date_type>
  class day_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    day_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {


      d.year();
      return duration_type(f_);
    }
    duration_type get_neg_offset(const date_type& d) const
    {

      d.year();
      return duration_type(-f_);
    }
  private:
    int f_;
  };
# 53 "/usr/include/boost/date_time/adjust_functors.hpp" 3 4
  template<class date_type>
  class month_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type cal_type;
    typedef typename cal_type::ymd_type ymd_type;
    typedef typename cal_type::day_type day_type;

    month_functor(int f) : f_(f), origDayOfMonth_(0) {}
    duration_type get_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);

      int_type year = wi.add(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);



      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));

      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }

    duration_type get_neg_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);

      int_type year = wi.subtract(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);

      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));

      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }
  private:
    int f_;
    mutable short origDayOfMonth_;
  };



  template<class date_type>
  class week_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type calendar_type;
    week_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {


      d.year();
      return duration_type(f_*calendar_type::days_in_week());
    }
    duration_type get_neg_offset(const date_type& d) const
    {

      d.year();
      return duration_type(-f_*calendar_type::days_in_week());
    }
  private:
    int f_;
  };


  template<class date_type>
  class year_functor
  {
  public:

    typedef typename date_type::duration_type duration_type;
    year_functor(int f) : _mf(f * 12) {}
    duration_type get_offset(const date_type& d) const
    {
      return _mf.get_offset(d);
    }
    duration_type get_neg_offset(const date_type& d) const
    {
      return _mf.get_neg_offset(d);
    }
  private:
    month_functor<date_type> _mf;
  };


} }
# 15 "/usr/include/boost/date_time/gregorian/greg_duration_types.hpp" 2 3 4



namespace boost {
namespace gregorian {


  struct greg_durations_config {
    typedef date date_type;
    typedef date_time::int_adapter<int> int_rep;
    typedef date_time::month_functor<date_type> month_adjustor_type;
  };

  typedef date_time::months_duration<greg_durations_config> months;
  typedef date_time::years_duration<greg_durations_config> years;

  class weeks_duration : public date_duration {
  public:
    weeks_duration(duration_rep w)
      : date_duration(w * 7) {}
    weeks_duration(date_time::special_values sv)
      : date_duration(sv) {}
  };

  typedef weeks_duration weeks;

}}
# 23 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4


# 1 "/usr/include/boost/date_time/date_generators.hpp" 1 3 4
# 17 "/usr/include/boost/date_time/date_generators.hpp" 3 4
# 1 "/usr/include/c++/4.4/sstream" 1 3 4
# 37 "/usr/include/c++/4.4/sstream" 3 4
       
# 38 "/usr/include/c++/4.4/sstream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 57 "/usr/include/c++/4.4/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 91 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 104 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 119 "/usr/include/c++/4.4/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 143 "/usr/include/c++/4.4/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 195 "/usr/include/c++/4.4/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }
    };
# 255 "/usr/include/c++/4.4/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 291 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 309 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 331 "/usr/include/c++/4.4/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 365 "/usr/include/c++/4.4/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 401 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 419 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 441 "/usr/include/c++/4.4/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 475 "/usr/include/c++/4.4/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 509 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 525 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 547 "/usr/include/c++/4.4/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };

}


# 1 "/usr/include/c++/4.4/bits/sstream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/sstream.tcc" 3
       
# 40 "/usr/include/c++/4.4/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "/usr/include/c++/4.4/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;



}
# 574 "/usr/include/c++/4.4/sstream" 2 3
# 18 "/usr/include/boost/date_time/date_generators.hpp" 2 3 4




namespace boost {
namespace date_time {







  template<class date_type>
  class year_based_generator
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::year_type year_type;
    year_based_generator() {};
    virtual ~year_based_generator() {};
    virtual date_type get_date(year_type y) const = 0;

    virtual std::string to_string() const =0;
  };
# 55 "/usr/include/boost/date_time/date_generators.hpp" 3 4
  template<class date_type>
 class partial_date : public year_based_generator<date_type>
 {
 public:
   typedef typename date_type::calendar_type calendar_type;
   typedef typename calendar_type::day_type day_type;
   typedef typename calendar_type::month_type month_type;
   typedef typename calendar_type::year_type year_type;
   typedef typename date_type::duration_type duration_type;
   typedef typename duration_type::duration_rep duration_rep;
   partial_date(day_type d, month_type m) :
     day_(d),
     month_(m)
   {}





   partial_date(duration_rep days) :
     day_(1),
     month_(1)
   {
     date_type d1(2000,1,1);
     if(days > 1) {
       if(days > 366)
       {
         days = 366;
       }
       days = days - 1;
       duration_type dd(days);
       d1 = d1 + dd;
     }
     day_ = d1.day();
     month_ = d1.month();
   }
# 101 "/usr/include/boost/date_time/date_generators.hpp" 3 4
   date_type get_date(year_type y) const
   {
     if((day_ == 29) && (month_ == 2) && !(calendar_type::is_leap_year(y))) {
       std::ostringstream ss;
       ss << "No Feb 29th in given year of " << y << ".";
       boost::throw_exception(std::invalid_argument(ss.str()));
     }
     return date_type(y, month_, day_);
   }
   date_type operator()(year_type y) const
   {
     return get_date(y);

   }
   bool operator==(const partial_date& rhs) const
   {
     return (month_ == rhs.month_) && (day_ == rhs.day_);
   }
   bool operator<(const partial_date& rhs) const
   {
     if (month_ < rhs.month_) return true;
     if (month_ > rhs.month_) return false;

     return (day_ < rhs.day_);
   }


   month_type month() const
   {
     return month_;
   }
   day_type day() const
   {
     return day_;
   }






   virtual std::string to_string() const
   {
     std::ostringstream ss;
     date_type d(2004, month_, day_);
     unsigned short c = d.day_of_year();
     c--;
     ss << c;
     return ss.str();
   }
 private:
   day_type day_;
   month_type month_;
 };



  const char* nth_as_str(int n);
# 177 "/usr/include/boost/date_time/date_generators.hpp" 3 4
  template<class date_type>
  class nth_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;
    enum week_num {first=1, second, third, fourth, fifth};
    nth_kday_of_month(week_num week_no,
                      day_of_week_type dow,
                      month_type m) :
      month_(m),
      wn_(week_no),
      dow_(dow)
    {}

    date_type get_date(year_type y) const
    {
      date_type d(y, month_, 1);
      duration_type one_day(1);
      duration_type one_week(7);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      int week = 1;
      while (week < wn_) {
        d = d + one_week;
        week++;
      }

      if(d.month() != month_) {
        d = d - one_week;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    week_num nth_week() const
    {
      return wn_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
    const char* nth_week_as_str() const
    {
      return nth_as_str(wn_);
    }


    virtual std::string to_string() const
    {
     std::ostringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << static_cast<int>(wn_) << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    week_num wn_;
    day_of_week_type dow_;
  };





  template<class date_type>
  class first_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;




    first_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}

    date_type get_date(year_type year) const
    {
      date_type d(year, month_,1);
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }


    virtual std::string to_string() const
    {
     std::ostringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << 1 << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
  };
# 313 "/usr/include/boost/date_time/date_generators.hpp" 3 4
  template<class date_type>
  class last_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;




    last_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}

    date_type get_date(year_type year) const
    {
      date_type d(year, month_, calendar_type::end_of_month_day(year,month_));
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }

    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }


    virtual std::string to_string() const
    {
      std::ostringstream ss;
      ss << 'M'
         << static_cast<int>(month_) << '.'
         << 5 << '.'
         << static_cast<int>(dow_);
      return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
   };
# 375 "/usr/include/boost/date_time/date_generators.hpp" 3 4
  template<class date_type>
  class first_kday_after
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_after(day_of_week_type dow) :
      dow_(dow)
    {}

    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day + one_day;
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
    }

    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };
# 413 "/usr/include/boost/date_time/date_generators.hpp" 3 4
  template<class date_type>
  class first_kday_before
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_before(day_of_week_type dow) :
      dow_(dow)
    {}

    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day - one_day;
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }

    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };





  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_until_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.is_negative()){
      wks = duration_type(7);
    }
    return dd + wks;
  }






  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_before_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.days() > 0){
      wks = duration_type(7);
    }


    return (-dd + wks);
  }






  template<class date_type, class weekday_type>
  inline
  date_type next_weekday(const date_type& d, const weekday_type& wd)
  {
    return d + days_until_weekday(d, wd);
  }






  template<class date_type, class weekday_type>
  inline
  date_type previous_weekday(const date_type& d, const weekday_type& wd)
  {
    return d - days_before_weekday(d, wd);
  }

} }
# 26 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/date_clock_device.hpp" 1 3 4
# 15 "/usr/include/boost/date_time/date_clock_device.hpp" 3 4
namespace boost {
namespace date_time {







  template<class date_type>
  class day_clock
  {
  public:
    typedef typename date_type::ymd_type ymd_type;

    static date_type local_day()
    {
      return date_type(local_day_ymd());
    }

    static typename date_type::ymd_type local_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_local_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }

    static typename date_type::ymd_type universal_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_universal_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }

    static date_type universal_day()
    {
      return date_type(universal_day_ymd());
    }

  private:
    static ::std::tm* get_local_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::localtime(&t, &result);
    }
    static ::std::tm* get_universal_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::gmtime(&t, &result);
    }

  };

} }
# 27 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/date_iterator.hpp" 1 3 4
# 14 "/usr/include/boost/date_time/date_iterator.hpp" 3 4
namespace boost {
namespace date_time {

  enum date_resolutions {day, week, months, year, decade, century, NumDateResolutions};
# 32 "/usr/include/boost/date_time/date_iterator.hpp" 3 4
  template<class date_type>
  class date_itr_base {



  public:
    typedef typename date_type::duration_type duration_type;
    typedef date_type value_type;
    typedef std::input_iterator_tag iterator_category;

    date_itr_base(date_type d) : current_(d) {}
    virtual ~date_itr_base() {};
    date_itr_base& operator++()
    {
      current_ = current_ + get_offset(current_);
      return *this;
    }
    date_itr_base& operator--()
    {
      current_ = current_ + get_neg_offset(current_);
      return *this;
    }
    virtual duration_type get_offset(const date_type& current) const=0;
    virtual duration_type get_neg_offset(const date_type& current) const=0;
    date_type operator*() {return current_;};
    date_type* operator->() {return &current_;};
    bool operator< (const date_type& d) {return current_ < d;}
    bool operator<= (const date_type& d) {return current_ <= d;}
    bool operator> (const date_type& d) {return current_ > d;}
    bool operator>= (const date_type& d) {return current_ >= d;}
    bool operator== (const date_type& d) {return current_ == d;}
    bool operator!= (const date_type& d) {return current_ != d;}
  private:
    date_type current_;
  };
# 76 "/usr/include/boost/date_time/date_iterator.hpp" 3 4
  template<class offset_functor, class date_type>
  class date_itr : public date_itr_base<date_type> {
  public:
    typedef typename date_type::duration_type duration_type;
    date_itr(date_type d, int factor=1) :
      date_itr_base<date_type>(d),
      of_(factor)
    {}
  private:
    virtual duration_type get_offset(const date_type& current) const
    {
      return of_.get_offset(current);
    }
    virtual duration_type get_neg_offset(const date_type& current) const
    {
      return of_.get_neg_offset(current);
    }
    offset_functor of_;
  };



} }
# 28 "/usr/include/boost/date_time/gregorian/gregorian_types.hpp" 2 3 4


namespace boost {






namespace gregorian {



  typedef date_time::period<date, date_duration> date_period;






  typedef date_time::year_based_generator<date> year_based_generator;


  typedef date_time::partial_date<date> partial_date;

  typedef date_time::nth_kday_of_month<date> nth_kday_of_month;
  typedef nth_kday_of_month nth_day_of_the_week_in_month;

  typedef date_time::first_kday_of_month<date> first_kday_of_month;
  typedef first_kday_of_month first_day_of_the_week_in_month;

  typedef date_time::last_kday_of_month<date> last_kday_of_month;
  typedef last_kday_of_month last_day_of_the_week_in_month;

  typedef date_time::first_kday_after<date> first_kday_after;
  typedef first_kday_after first_day_of_the_week_after;

  typedef date_time::first_kday_before<date> first_kday_before;
  typedef first_kday_before first_day_of_the_week_before;




  typedef date_time::day_clock<date> day_clock;




  typedef date_time::date_itr_base<date> date_iterator;




  typedef date_time::date_itr<date_time::day_functor<date>,
                              date> day_iterator;



  typedef date_time::date_itr<date_time::week_functor<date>,
                              date> week_iterator;



  typedef date_time::date_itr<date_time::month_functor<date>,
                              date> month_iterator;



  typedef date_time::date_itr<date_time::year_functor<date>,
                              date> year_iterator;


  using date_time::days_until_weekday;
  using date_time::days_before_weekday;
  using date_time::next_weekday;
  using date_time::previous_weekday;

} }
# 19 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 2 3 4



namespace boost {
namespace posix_time {
# 40 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 3 4
  typedef date_time::time_resolution_traits<
    boost::date_time::time_resolution_traits_adapted64_impl, boost::date_time::micro,
                                            1000000, 6 > time_res_traits;
# 57 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 3 4
  class time_duration :
    public date_time::time_duration<time_duration, time_res_traits>
  {
  public:
    typedef time_res_traits rep_type;
    typedef time_res_traits::day_type day_type;
    typedef time_res_traits::hour_type hour_type;
    typedef time_res_traits::min_type min_type;
    typedef time_res_traits::sec_type sec_type;
    typedef time_res_traits::fractional_seconds_type fractional_seconds_type;
    typedef time_res_traits::tick_type tick_type;
    typedef time_res_traits::impl_type impl_type;
    time_duration(hour_type hour,
                  min_type min,
                  sec_type sec,
                  fractional_seconds_type fs=0) :
      date_time::time_duration<time_duration, time_res_traits>(hour,min,sec,fs)
    {}
    time_duration() :
      date_time::time_duration<time_duration, time_res_traits>(0,0,0)
    {}

    time_duration(boost::date_time::special_values sv) :
      date_time::time_duration<time_duration, time_res_traits>(sv)
    {}

    friend class date_time::time_duration<time_duration, time_res_traits>;
  private:
    explicit time_duration(impl_type tick_count) :
      date_time::time_duration<time_duration, time_res_traits>(tick_count)
    {}
  };
# 154 "/usr/include/boost/date_time/posix_time/posix_time_config.hpp" 3 4
  class millisec_posix_time_system_config
  {
   public:
    typedef boost::int64_t time_rep_type;

    typedef gregorian::date date_type;
    typedef gregorian::date_duration date_duration_type;
    typedef time_duration time_duration_type;
    typedef time_res_traits::tick_type int_type;
    typedef time_res_traits::impl_type impl_type;
    typedef time_res_traits resolution_traits;


    static const boost::int64_t tick_per_second = 1000000;

  };



} }
# 14 "/usr/include/boost/date_time/posix_time/posix_time_system.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/time_system_split.hpp" 1 3 4
# 17 "/usr/include/boost/date_time/time_system_split.hpp" 3 4
namespace boost {
namespace date_time {





  template<typename config>

  class split_timedate_system
  {
   public:
    typedef typename config::time_rep_type time_rep_type;
    typedef typename config::date_type date_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::date_duration_type date_duration_type;
    typedef typename config::int_type int_type;
    typedef typename config::resolution_traits resolution_traits;





   private:
     static const int_type ticks_per_day = int64_t(86400) * config::tick_per_second;
   public:



    typedef date_time::wrapping_int<int_type, ticks_per_day> wrap_int_type;



    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));

      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));

      }

    }

    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags = not_dst)
    {
      if(day.is_special() || tod.is_special()) {
        if(day.is_not_a_date() || tod.is_not_a_date_time()) {
          return time_rep_type(date_type(not_a_date_time),
                               time_duration_type(not_a_date_time));
        }
        else if(day.is_pos_infinity()) {
          if(tod.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(pos_infin));
          }
        }
        else if(day.is_neg_infinity()) {
          if(tod.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(neg_infin));
          }
        }
        else if(tod.is_pos_infinity()) {
          if(day.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(pos_infin), tod);
          }
        }
        else if(tod.is_neg_infinity()) {
          if(day.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(neg_infin), tod);
          }
        }
      }
      return time_rep_type(day, tod);
    }
    static date_type get_date(const time_rep_type& val)
    {
      return date_type(val.day);
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      return time_duration_type(val.time_of_day);
    }
    static std::string zone_name(const time_rep_type&)
    {
      return std::string();
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return ((lhs.day == rhs.day) && (lhs.time_of_day == rhs.time_of_day));
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      if (lhs.day < rhs.day) return true;
      if (lhs.day > rhs.day) return false;
      return (lhs.time_of_day < rhs.time_of_day);
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      return time_rep_type(base.day+dd, base.time_of_day);
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      return split_timedate_system::get_time_rep(base.day-dd, base.time_of_day);
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.day.is_special() || td.is_special())
      {
        return split_timedate_system::get_time_rep(base.day, -td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return add_time_duration(base,td1);
      }

      wrap_int_type day_offset(base.time_of_day.ticks());
      date_duration_type day_overflow(static_cast<typename date_duration_type::duration_rep_type>(day_offset.subtract(td.ticks())));

      return time_rep_type(base.day-day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.day.is_special() || td.is_special()) {
        return split_timedate_system::get_time_rep(base.day, td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return subtract_time_duration(base,td1);
      }

      wrap_int_type day_offset(base.time_of_day.ticks());
      date_duration_type day_overflow(static_cast< typename date_duration_type::duration_rep_type >(day_offset.add(td.ticks())));

      return time_rep_type(base.day+day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      date_duration_type dd = lhs.day - rhs.day;
      time_duration_type td(dd.days()*24,0,0);
      time_duration_type td2 = lhs.time_of_day - rhs.time_of_day;
      return td+td2;

    }

  };

} }
# 15 "/usr/include/boost/date_time/posix_time/posix_time_system.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/time_system_counted.hpp" 1 3 4
# 18 "/usr/include/boost/date_time/time_system_counted.hpp" 3 4
namespace boost {
namespace date_time {


  template<class config>
  struct counted_time_rep
  {
    typedef typename config::int_type int_type;
    typedef typename config::date_type date_type;
    typedef typename config::impl_type impl_type;
    typedef typename date_type::duration_type date_duration_type;
    typedef typename date_type::calendar_type calendar_type;
    typedef typename date_type::ymd_type ymd_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::resolution_traits resolution_traits;

    counted_time_rep(const date_type& d, const time_duration_type& time_of_day)
      : time_count_(1)
    {
      if(d.is_infinity() || d.is_not_a_date() || time_of_day.is_special()) {
        time_count_ = time_of_day.get_rep() + d.day_count();

      }
      else {
        time_count_ = (d.day_number() * frac_sec_per_day()) + time_of_day.ticks();
      }
    }
    explicit counted_time_rep(int_type count) :
      time_count_(count)
    {}
    explicit counted_time_rep(impl_type count) :
      time_count_(count)
    {}
    date_type date() const
    {
      if(time_count_.is_special()) {
        return date_type(time_count_.as_special());
      }
      else {
        typename calendar_type::date_int_type dc = day_count();

        ymd_type ymd = calendar_type::from_day_number(dc);
        return date_type(ymd);
      }
    }

    unsigned long day_count() const
    {
# 78 "/usr/include/boost/date_time/time_system_counted.hpp" 3 4
      return static_cast<unsigned long>(resolution_traits::as_number(time_count_) / frac_sec_per_day());
    }
    int_type time_count() const
    {
      return resolution_traits::as_number(time_count_);
    }
    int_type tod() const
    {
      return resolution_traits::as_number(time_count_) % frac_sec_per_day();
    }
    static int_type frac_sec_per_day()
    {
      int_type seconds_per_day = 60*60*24;
      int_type fractional_sec_per_sec(resolution_traits::res_adjust());
      return seconds_per_day*fractional_sec_per_sec;
    }
    bool is_pos_infinity()const
    {
      return impl_type::is_pos_inf(time_count_.as_number());
    }
    bool is_neg_infinity()const
    {
      return impl_type::is_neg_inf(time_count_.as_number());
    }
    bool is_not_a_date_time()const
    {
      return impl_type::is_not_a_number(time_count_.as_number());
    }
    bool is_special()const
    {
      return time_count_.is_special();
    }
    impl_type get_rep()const
    {
      return time_count_;
    }
  private:
    impl_type time_count_;
  };


  template<class time_rep>
  class counted_time_system
  {
   public:
    typedef time_rep time_rep_type;
    typedef typename time_rep_type::impl_type impl_type;
    typedef typename time_rep_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::fractional_seconds_type fractional_seconds_type;
    typedef typename time_rep_type::date_type date_type;
    typedef typename time_rep_type::date_duration_type date_duration_type;


    template<class T> static void unused_var(const T&) {}

    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags dst=not_dst)
    {
      unused_var(dst);
      return time_rep_type(day, tod);
    }

    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));

      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));

      }

    }

    static date_type get_date(const time_rep_type& val)
    {
      return val.date();
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      if(val.is_special()) {
        return time_duration_type(val.get_rep().as_special());
      }
      else{
        return time_duration_type(0,0,0,val.tod());
      }
    }
    static std::string zone_name(const time_rep_type&)
    {
      return "";
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() == rhs.time_count());
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() < rhs.time_count());
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() + dd.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() - dd.get_rep()));
      }
      else{
        return time_rep_type(base.time_count() - (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() - td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() - td.ticks());
      }
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() + td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + td.ticks());
      }
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      if(lhs.is_special() || rhs.is_special()) {
        return(time_duration_type(
          impl_type::to_special((lhs.get_rep() - rhs.get_rep()).as_number())));
      }
      else {
        fractional_seconds_type fs = lhs.time_count() - rhs.time_count();
        return time_duration_type(0,0,0,fs);
      }
    }

  };


} }
# 16 "/usr/include/boost/date_time/posix_time/posix_time_system.hpp" 2 3 4



namespace boost {
namespace posix_time {
# 32 "/usr/include/boost/date_time/posix_time/posix_time_system.hpp" 3 4
  typedef date_time::counted_time_rep<millisec_posix_time_system_config> int64_time_rep;
  typedef date_time::counted_time_system<int64_time_rep> posix_time_system;



} }
# 13 "/usr/include/boost/date_time/posix_time/ptime.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/time.hpp" 1 3 4
# 21 "/usr/include/boost/date_time/time.hpp" 3 4
namespace boost {
namespace date_time {
# 45 "/usr/include/boost/date_time/time.hpp" 3 4
  template <class T, class time_system>
  class base_time : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
      > >
  {
  public:
    typedef T time_type;
    typedef typename time_system::time_rep_type time_rep_type;
    typedef typename time_system::date_type date_type;
    typedef typename time_system::date_duration_type date_duration_type;
    typedef typename time_system::time_duration_type time_duration_type;


    base_time(const date_type& day,
              const time_duration_type& td,
              dst_flags dst=not_dst) :
      time_(time_system::get_time_rep(day, td, dst))
    {}
    base_time(special_values sv) :
      time_(time_system::get_time_rep(sv))
    {}
    base_time(const time_rep_type& rhs) :
      time_(rhs)
    {}
    date_type date() const
    {
      return time_system::get_date(time_);
    }
    time_duration_type time_of_day() const
    {
      return time_system::get_time_of_day(time_);
    }



    std::string zone_name(bool =false) const
    {
      return time_system::zone_name(time_);
    }



    std::string zone_abbrev(bool =false) const
    {
      return time_system::zone_name(time_);
    }

    std::string zone_as_posix_string() const
    {
      return std::string();
    }


    bool is_not_a_date_time() const
    {
      return time_.is_not_a_date_time();
    }

    bool is_infinity() const
    {
      return (is_pos_infinity() || is_neg_infinity());
    }

    bool is_pos_infinity() const
    {
      return time_.is_pos_infinity();
    }

    bool is_neg_infinity() const
    {
      return time_.is_neg_infinity();
    }

    bool is_special() const
    {
      return(is_not_a_date_time() || is_infinity());
    }

    bool operator==(const time_type& rhs) const
    {
      return time_system::is_equal(time_,rhs.time_);
    }

    bool operator<(const time_type& rhs) const
    {
      return time_system::is_less(time_,rhs.time_);
    }

    time_duration_type operator-(const time_type& rhs) const
    {
      return time_system::subtract_times(time_, rhs.time_);
    }

    time_type operator+(const date_duration_type& dd) const
    {
      return time_system::add_days(time_, dd);
    }
    time_type operator+=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() + dd, time_of_day()));
      return time_type(time_);
    }

    time_type operator-(const date_duration_type& dd) const
    {
      return time_system::subtract_days(time_, dd);
    }
    time_type operator-=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() - dd, time_of_day()));
      return time_type(time_);
    }

    time_type operator+(const time_duration_type& td) const
    {
      return time_type(time_system::add_time_duration(time_, td));
    }
    time_type operator+=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() + td));
      return time_type(time_);
    }

    time_type operator-(const time_duration_type& rhs) const
    {
      return time_system::subtract_time_duration(time_, rhs);
    }
    time_type operator-=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() - td));
      return time_type(time_);
    }

  protected:
    time_rep_type time_;
  };





} }
# 14 "/usr/include/boost/date_time/posix_time/ptime.hpp" 2 3 4

namespace boost {

namespace posix_time {


  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;




  class ptime : public date_time::base_time<ptime, posix_time_system>
  {
  public:
    typedef posix_time_system time_system_type;
    typedef time_system_type::time_rep_type time_rep_type;
    typedef time_system_type::time_duration_type time_duration_type;
    typedef ptime time_type;

    ptime(gregorian::date d,time_duration_type td) : date_time::base_time<time_type,time_system_type>(d,td)
    {}

    explicit ptime(gregorian::date d) : date_time::base_time<time_type,time_system_type>(d,time_duration_type(0,0,0))
    {}

    ptime(const time_rep_type& rhs):
      date_time::base_time<time_type,time_system_type>(rhs)
    {}

    ptime(const special_values sv) : date_time::base_time<time_type,time_system_type>(sv)
    {}


    ptime() : date_time::base_time<time_type,time_system_type>(gregorian::date(not_a_date_time), time_duration_type(not_a_date_time))
    {}


  };



} }
# 13 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/posix_time/date_duration_operators.hpp" 1 3 4
# 15 "/usr/include/boost/date_time/posix_time/date_duration_operators.hpp" 3 4
namespace boost {
namespace posix_time {
# 29 "/usr/include/boost/date_time/posix_time/date_duration_operators.hpp" 3 4
  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::months& m)
  {
    return t + m.get_offset(t.date());
  }




  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::months& m)
  {

    return t += m.get_offset(t.date());
  }




  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::months& m)
  {

    return t + m.get_neg_offset(t.date());
  }




  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::months& m)
  {
    return t += m.get_neg_offset(t.date());
  }






  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::years& y)
  {
    return t + y.get_offset(t.date());
  }




  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::years& y)
  {
    return t += y.get_offset(t.date());
  }




  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::years& y)
  {

    return t + y.get_neg_offset(t.date());
  }




  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::years& y)
  {

    return t += y.get_neg_offset(t.date());
  }

}}
# 15 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/posix_time/posix_time_duration.hpp" 1 3 4
# 14 "/usr/include/boost/date_time/posix_time/posix_time_duration.hpp" 3 4
namespace boost {
namespace posix_time {




  class hours : public time_duration
  {
  public:
    explicit hours(long h) :
      time_duration(h,0,0)
    {}
  };




  class minutes : public time_duration
  {
  public:
    explicit minutes(long m) :
      time_duration(0,m,0)
    {}
  };




  class seconds : public time_duration
  {
  public:
    explicit seconds(long s) :
      time_duration(0,0,s)
    {}
  };





  typedef date_time::subsecond_duration<time_duration,1000> millisec;
  typedef date_time::subsecond_duration<time_duration,1000> milliseconds;




  typedef date_time::subsecond_duration<time_duration,1000000> microsec;
  typedef date_time::subsecond_duration<time_duration,1000000> microseconds;
# 78 "/usr/include/boost/date_time/posix_time/posix_time_duration.hpp" 3 4
} }
# 17 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/posix_time/time_period.hpp" 1 3 4
# 16 "/usr/include/boost/date_time/posix_time/time_period.hpp" 3 4
namespace boost {
namespace posix_time {




  typedef date_time::period<ptime, time_duration> time_period;


} }
# 19 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/time_iterator.hpp" 1 3 4
# 13 "/usr/include/boost/date_time/time_iterator.hpp" 3 4
namespace boost {
namespace date_time {



  template<class time_type>
  class time_itr {
  public:
    typedef typename time_type::time_duration_type time_duration_type;
    time_itr(time_type t, time_duration_type d) : current_(t), offset_(d) {};
    time_itr& operator++()
    {
      current_ = current_ + offset_;
      return *this;
    }
    time_itr& operator--()
    {
      current_ = current_ - offset_;
      return *this;
    }
    time_type operator*() {return current_;};
    time_type* operator->() {return &current_;};
    bool operator< (const time_type& t) {return current_ < t;};
    bool operator<= (const time_type& t) {return current_ <= t;};
    bool operator!= (const time_type& t) {return current_ != t;};
    bool operator== (const time_type& t) {return current_ == t;};
    bool operator> (const time_type& t) {return current_ > t;};
    bool operator>= (const time_type& t) {return current_ >= t;};

  private:
    time_type current_;
    time_duration_type offset_;
  };



} }
# 20 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3 4
# 1 "/usr/include/boost/date_time/dst_rules.hpp" 1 3 4
# 21 "/usr/include/boost/date_time/dst_rules.hpp" 3 4
namespace boost {
  namespace date_time {

    enum time_is_dst_result {is_not_in_dst, is_in_dst,
                             ambiguous, invalid_time_label};



    template<class date_type_,
             class time_duration_type_>
    class dst_calculator
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
# 47 "/usr/include/boost/date_time/dst_rules.hpp" 3 4
      static time_is_dst_result
      process_local_dst_start_day(const time_duration_type& time_of_day,
                                  unsigned int dst_start_offset_minutes,
                                  long dst_length_minutes)
      {

        if (time_of_day < time_duration_type(0,dst_start_offset_minutes,0)) {
          return is_not_in_dst;
        }
        long offset = dst_start_offset_minutes + dst_length_minutes;
        if (time_of_day >= time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        return invalid_time_label;
      }
# 72 "/usr/include/boost/date_time/dst_rules.hpp" 3 4
      static time_is_dst_result
      process_local_dst_end_day(const time_duration_type& time_of_day,
                                unsigned int dst_end_offset_minutes,
                                long dst_length_minutes)
      {

        int offset = dst_end_offset_minutes-dst_length_minutes;
        if (time_of_day < time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        if (time_of_day >= time_duration_type(0,dst_end_offset_minutes,0)) {
          return is_not_in_dst;
        }
        return ambiguous;
      }
# 100 "/usr/include/boost/date_time/dst_rules.hpp" 3 4
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   const time_duration_type& dst_start_offset,
                   const date_type& dst_end_day,
                   const time_duration_type& dst_end_offset,
                   const time_duration_type& dst_length_minutes)
      {
        unsigned int start_minutes =
          dst_start_offset.hours() * 60 + dst_start_offset.minutes();
        unsigned int end_minutes =
          dst_end_offset.hours() * 60 + dst_end_offset.minutes();
        long length_minutes =
          dst_length_minutes.hours() * 60 + dst_length_minutes.minutes();

        return local_is_dst(current_day, time_of_day,
                            dst_start_day, start_minutes,
                            dst_end_day, end_minutes,
                            length_minutes);
      }
# 136 "/usr/include/boost/date_time/dst_rules.hpp" 3 4
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   unsigned int dst_start_offset_minutes,
                   const date_type& dst_end_day,
                   unsigned int dst_end_offset_minutes,
                   long dst_length_minutes)
      {

        if (dst_start_day < dst_end_day) {
          if ((current_day > dst_start_day) && (current_day < dst_end_day)) {
            return is_in_dst;
          }
          if ((current_day < dst_start_day) || (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
        }
        else {
          if ((current_day < dst_start_day) && (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
          if ((current_day > dst_start_day) || (current_day < dst_end_day)) {
            return is_in_dst;
          }
        }

        if (current_day == dst_start_day) {
          return process_local_dst_start_day(time_of_day,
                                             dst_start_offset_minutes,
                                             dst_length_minutes);
        }

        if (current_day == dst_end_day) {
          return process_local_dst_end_day(time_of_day,
                                           dst_end_offset_minutes,
                                           dst_length_minutes);
        }

        return invalid_time_label;
      }

    };
# 208 "/usr/include/boost/date_time/dst_rules.hpp" 3 4
    template<class date_type,
             class time_duration_type,
             class dst_traits>
    class dst_calc_engine
    {
    public:
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;






      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {

        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,
                                     dst_traits::dst_start_offset_minutes(),
                                     dst_end,
                                     dst_traits::dst_end_offset_minutes(),
                                     dst_traits::dst_shift_length_minutes());

      }

      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }


      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_traits::dst_shift_length_minutes(),0);
      }

      static date_type local_dst_start_day(year_type year)
      {
        return dst_traits::local_dst_start_day(year);
      }

      static date_type local_dst_end_day(year_type year)
      {
        return dst_traits::local_dst_end_day(year);
      }


    };






    template<class date_type_,
             class time_duration_type_,
             unsigned int dst_start_offset_minutes=120,
             short dst_length_minutes=60>
    class us_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef date_time::last_kday_of_month<date_type> lkday;
      typedef date_time::first_kday_of_month<date_type> fkday;
      typedef date_time::nth_kday_of_month<date_type> nkday;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;






      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {

        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,dst_start_offset_minutes,
                                     dst_end, dst_start_offset_minutes,
                                     dst_length_minutes);

      }


      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }

      static date_type local_dst_start_day(year_type year)
      {
        if (year >= year_type(2007)) {

          nkday ssim(nkday::second, Sunday, gregorian::Mar);
          return ssim.get_date(year);
        } else {

          fkday fsia(Sunday, gregorian::Apr);
          return fsia.get_date(year);
        }
      }

      static date_type local_dst_end_day(year_type year)
      {
        if (year >= year_type(2007)) {

          fkday fsin(Sunday, gregorian::Nov);
          return fsin.get_date(year);
        } else {

          lkday lsio(Sunday, gregorian::Oct);
          return lsio.get_date(year);
        }
      }

      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_length_minutes,0);
      }

     private:


    };


    template<class date_type_, class time_duration_type_>
    class null_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;





      static time_is_dst_result local_is_dst(const date_type&,
                                             const time_duration_type&)
      {
        return is_not_in_dst;
      }


      static time_is_dst_result utc_is_dst(const date_type&,
                                           const time_duration_type&)
      {
        return is_not_in_dst;
      }

      static bool is_dst_boundary_day(date_type d)
      {
        return false;
      }

      static time_duration_type dst_offset()
      {
        return time_duration_type(0,0,0);
      }

    };


  } }
# 21 "/usr/include/boost/date_time/posix_time/posix_time_types.hpp" 2 3 4

namespace boost {


namespace posix_time {




  typedef date_time::time_itr<ptime> time_iterator;



  typedef date_time::second_clock<ptime> second_clock;





  typedef date_time::microsec_clock<ptime> microsec_clock;



  typedef date_time::null_dst_rules<ptime::date_type, time_duration> no_dst;

  typedef date_time::us_dst_rules<ptime::date_type, time_duration> us_dst;


} }
# 11 "/usr/include/boost/thread/thread_time.hpp" 2 3 4

# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 13 "/usr/include/boost/thread/thread_time.hpp" 2 3 4

namespace boost
{
    typedef boost::posix_time::ptime system_time;

    inline system_time get_system_time()
    {
        return boost::date_time::microsec_clock<system_time>::universal_time();
    }

    namespace detail
    {
        inline system_time get_system_time_sentinel()
        {
            return system_time(boost::posix_time::pos_infin);
        }

        inline unsigned long get_milliseconds_until(system_time const& target_time)
        {
            if(target_time.is_pos_infinity())
            {
                return ~(unsigned long)0;
            }
            system_time const now=get_system_time();
            if(target_time<=now)
            {
                return 0;
            }
            return static_cast<unsigned long>((target_time-now).total_milliseconds()+1);
        }

    }

}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 49 "/usr/include/boost/thread/thread_time.hpp" 2 3 4
# 13 "/usr/include/boost/thread/locks.hpp" 2 3 4


# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 16 "/usr/include/boost/thread/locks.hpp" 2 3 4

namespace boost
{
    struct xtime;
# 28 "/usr/include/boost/thread/locks.hpp" 3 4
    namespace detail
    {
        template<typename T>
        struct has_member_lock
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U>
            static true_type has_member(U*,void (U::*dummy)()=&U::lock);
            static false_type has_member(void*);

            static const bool value=sizeof(has_member_lock<T>::has_member((T*)__null))==sizeof(true_type);
        };

        template<typename T>
        struct has_member_unlock
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U>
            static true_type has_member(U*,void (U::*dummy)()=&U::unlock);
            static false_type has_member(void*);

            static const bool value=sizeof(has_member_unlock<T>::has_member((T*)__null))==sizeof(true_type);
        };

        template<typename T>
        struct has_member_try_lock
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };

            template<typename U>
            static true_type has_member(U*,bool (U::*dummy)()=&U::try_lock);
            static false_type has_member(void*);

            static const bool value=sizeof(has_member_try_lock<T>::has_member((T*)__null))==sizeof(true_type);
        };

    }


    template<typename T>
    struct is_mutex_type
    {
        static const bool value = detail::has_member_lock<T>::value && detail::has_member_unlock<T>::value && detail::has_member_try_lock<T>::value;



    };
# 97 "/usr/include/boost/thread/locks.hpp" 3 4
    struct defer_lock_t
    {};
    struct try_to_lock_t
    {};
    struct adopt_lock_t
    {};

    const defer_lock_t defer_lock={};
    const try_to_lock_t try_to_lock={};
    const adopt_lock_t adopt_lock={};

    template<typename Mutex>
    class shared_lock;

    template<typename Mutex>
    class upgrade_lock;

    template<typename Mutex>
    class unique_lock;

    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper;
    }
# 182 "/usr/include/boost/thread/locks.hpp" 3 4
    template<typename Mutex>
    class lock_guard
    {
    private:
        Mutex& m;

        explicit lock_guard(lock_guard&);
        lock_guard& operator=(lock_guard&);
    public:
        explicit lock_guard(Mutex& m_):
            m(m_)
        {
            m.lock();
        }
        lock_guard(Mutex& m_,adopt_lock_t):
            m(m_)
        {}
        ~lock_guard()
        {
            m.unlock();
        }
    };


    template<typename Mutex>
    class unique_lock
    {
    private:
        Mutex* m;
        bool is_locked;
        unique_lock(unique_lock&);
        explicit unique_lock(upgrade_lock<Mutex>&);
        unique_lock& operator=(unique_lock&);
        unique_lock& operator=(upgrade_lock<Mutex>& other);
    public:
        unique_lock():
            m(0),is_locked(false)
        {}

        explicit unique_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        unique_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        unique_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        unique_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        template<typename TimeDuration>
        unique_lock(Mutex& m_,TimeDuration const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }
        unique_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }

        unique_lock(unique_lock&& other):
            m(other.m),is_locked(other.is_locked)
        {
            other.is_locked=false;
            other.m=0;
        }
        explicit unique_lock(upgrade_lock<Mutex>&& other);

        unique_lock<Mutex>&& move()
        {
            return static_cast<unique_lock<Mutex>&&>(*this);
        }


        unique_lock& operator=(unique_lock<Mutex>&& other)
        {
            unique_lock temp(other);
            swap(temp);
            return *this;
        }

        unique_lock& operator=(upgrade_lock<Mutex>&& other)
        {
            unique_lock temp(other);
            swap(temp);
            return *this;
        }
        void swap(unique_lock&& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
# 325 "/usr/include/boost/thread/locks.hpp" 3 4
        ~unique_lock()
        {
            if(owns_lock())
            {
                m->unlock();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            m->lock();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->try_lock();
            return is_locked;
        }
        template<typename TimeDuration>
        bool timed_lock(TimeDuration const& relative_time)
        {
            is_locked=m->timed_lock(relative_time);
            return is_locked;
        }

        bool timed_lock(::boost::system_time const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        bool timed_lock(::boost::xtime const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                throw boost::lock_error();
            }
            m->unlock();
            is_locked=false;
        }

        typedef void (unique_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&unique_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }

        Mutex* mutex() const
        {
            return m;
        }

        Mutex* release()
        {
            Mutex* const res=m;
            m=0;
            is_locked=false;
            return res;
        }

        friend class shared_lock<Mutex>;
        friend class upgrade_lock<Mutex>;
    };


    template<typename Mutex>
    void swap(unique_lock<Mutex>&& lhs,unique_lock<Mutex>&& rhs)
    {
        lhs.swap(rhs);
    }
# 423 "/usr/include/boost/thread/locks.hpp" 3 4
    template<typename Mutex>
    inline unique_lock<Mutex>&& move(unique_lock<Mutex>&& ul)
    {
        return ul;
    }


    template<typename Mutex>
    class shared_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit shared_lock(shared_lock&);
        shared_lock& operator=(shared_lock&);
    public:
        shared_lock():
            m(0),is_locked(false)
        {}

        explicit shared_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        shared_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        shared_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        shared_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        shared_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }

        shared_lock(detail::thread_move_t<shared_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }

        shared_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }

        shared_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_upgrade_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }

        operator detail::thread_move_t<shared_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<shared_lock<Mutex> > move()
        {
            return detail::thread_move_t<shared_lock<Mutex> >(*this);
        }


        shared_lock& operator=(detail::thread_move_t<shared_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }

        shared_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }

        shared_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }


        void swap(shared_lock&& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
# 546 "/usr/include/boost/thread/locks.hpp" 3 4
        Mutex* mutex() const
        {
            return m;
        }

        ~shared_lock()
        {
            if(owns_lock())
            {
                m->unlock_shared();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            m->lock_shared();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->try_lock_shared();
            return is_locked;
        }
        bool timed_lock(boost::system_time const& target_time)
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        template<typename Duration>
        bool timed_lock(Duration const& target_time)
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                throw boost::lock_error();
            }
            m->unlock_shared();
            is_locked=false;
        }

        typedef void (shared_lock<Mutex>::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&shared_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }

    };


    template<typename Mutex>
    void swap(shared_lock<Mutex>&& lhs,shared_lock<Mutex>&& rhs)
    {
        lhs.swap(rhs);
    }
# 635 "/usr/include/boost/thread/locks.hpp" 3 4
    template<typename Mutex>
    class upgrade_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit upgrade_lock(upgrade_lock&);
        upgrade_lock& operator=(upgrade_lock&);
    public:
        upgrade_lock():
            m(0),is_locked(false)
        {}

        explicit upgrade_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        upgrade_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        upgrade_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        upgrade_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        upgrade_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }

        upgrade_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_upgrade();
            }
            other->is_locked=false;
            other->m=0;
        }

        operator detail::thread_move_t<upgrade_lock<Mutex> >()
        {
            return move();
        }

        detail::thread_move_t<upgrade_lock<Mutex> > move()
        {
            return detail::thread_move_t<upgrade_lock<Mutex> >(*this);
        }


        upgrade_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            upgrade_lock temp(other);
            swap(temp);
            return *this;
        }

        upgrade_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            upgrade_lock temp(other);
            swap(temp);
            return *this;
        }

        void swap(upgrade_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }

        ~upgrade_lock()
        {
            if(owns_lock())
            {
                m->unlock_upgrade();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            m->lock_upgrade();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                throw boost::lock_error();
            }
            is_locked=m->try_lock_upgrade();
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                throw boost::lock_error();
            }
            m->unlock_upgrade();
            is_locked=false;
        }

        typedef void (upgrade_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&upgrade_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }
        friend class shared_lock<Mutex>;
        friend class unique_lock<Mutex>;
    };



    template<typename Mutex>
    unique_lock<Mutex>::unique_lock(upgrade_lock<Mutex>&& other):
        m(other.m),is_locked(other.is_locked)
    {
        other.is_locked=false;
        if(is_locked)
        {
            m.unlock_upgrade_and_lock();
        }
    }
# 790 "/usr/include/boost/thread/locks.hpp" 3 4
    template <class Mutex>
    class upgrade_to_unique_lock
    {
    private:
        upgrade_lock<Mutex>* source;
        unique_lock<Mutex> exclusive;

        explicit upgrade_to_unique_lock(upgrade_to_unique_lock&);
        upgrade_to_unique_lock& operator=(upgrade_to_unique_lock&);
    public:
        explicit upgrade_to_unique_lock(upgrade_lock<Mutex>& m_):
            source(&m_),exclusive(move(*source))
        {}
        ~upgrade_to_unique_lock()
        {
            if(source)
            {
                *source=move(exclusive);
            }
        }

        upgrade_to_unique_lock(detail::thread_move_t<upgrade_to_unique_lock<Mutex> > other):
            source(other->source),exclusive(move(other->exclusive))
        {
            other->source=0;
        }

        upgrade_to_unique_lock& operator=(detail::thread_move_t<upgrade_to_unique_lock<Mutex> > other)
        {
            upgrade_to_unique_lock temp(other);
            swap(temp);
            return *this;
        }
        void swap(upgrade_to_unique_lock& other)
        {
            std::swap(source,other.source);
            exclusive.swap(other.exclusive);
        }
        typedef void (upgrade_to_unique_lock::*bool_type)(upgrade_to_unique_lock&);
        operator bool_type() const
        {
            return exclusive.owns_lock()?&upgrade_to_unique_lock::swap:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return exclusive.owns_lock();
        }
    };

    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper:
            private unique_lock<Mutex>
        {
            typedef unique_lock<Mutex> base;
        public:
            try_lock_wrapper()
            {}

            explicit try_lock_wrapper(Mutex& m):
                base(m,try_to_lock)
            {}

            try_lock_wrapper(Mutex& m_,adopt_lock_t):
                base(m_,adopt_lock)
            {}
            try_lock_wrapper(Mutex& m_,defer_lock_t):
                base(m_,defer_lock)
            {}
            try_lock_wrapper(Mutex& m_,try_to_lock_t):
                base(m_,try_to_lock)
            {}
            try_lock_wrapper(detail::thread_move_t<try_lock_wrapper<Mutex> > other):
                base(detail::thread_move_t<base>(*other))
            {}

            operator detail::thread_move_t<try_lock_wrapper<Mutex> >()
            {
                return move();
            }

            detail::thread_move_t<try_lock_wrapper<Mutex> > move()
            {
                return detail::thread_move_t<try_lock_wrapper<Mutex> >(*this);
            }

            try_lock_wrapper& operator=(detail::thread_move_t<try_lock_wrapper<Mutex> > other)
            {
                try_lock_wrapper temp(other);
                swap(temp);
                return *this;
            }


            void swap(try_lock_wrapper&& other)
            {
                base::swap(other);
            }
# 904 "/usr/include/boost/thread/locks.hpp" 3 4
            void lock()
            {
                base::lock();
            }
            bool try_lock()
            {
                return base::try_lock();
            }
            void unlock()
            {
                base::unlock();
            }
            bool owns_lock() const
            {
                return base::owns_lock();
            }
            Mutex* mutex() const
            {
                return base::mutex();
            }
            Mutex* release()
            {
                return base::release();
            }
            bool operator!() const
            {
                return !this->owns_lock();
            }

            typedef typename base::bool_type bool_type;
            operator bool_type() const
            {
                return base::operator bool_type();
            }
        };


        template<typename Mutex>
        void swap(try_lock_wrapper<Mutex>&& lhs,try_lock_wrapper<Mutex>&& rhs)
        {
            lhs.swap(rhs);
        }
# 954 "/usr/include/boost/thread/locks.hpp" 3 4
        template<typename MutexType1,typename MutexType2>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(!m2.try_lock())
            {
                return 2;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }


        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }


        template<typename MutexType1,typename MutexType2>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(!m2.try_lock())
            {
                return 1;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }

        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }
    }

    namespace detail
    {
        template<bool x>
        struct is_mutex_type_wrapper
        {};

        template<typename MutexType1,typename MutexType2>
        void lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            unsigned const lock_count=2;
            unsigned lock_first=0;
            while(true)
            {
                switch(lock_first)
                {
                case 0:
                    lock_first=detail::lock_helper(m1,m2);
                    if(!lock_first)
                        return;
                    break;
                case 1:
                    lock_first=detail::lock_helper(m2,m1);
                    if(!lock_first)
                        return;
                    lock_first=(lock_first+1)%lock_count;
                    break;
                }
            }
        }

        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }


    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        unsigned const lock_count=3;
        unsigned lock_first=0;
        while(true)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            }
        }
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4)
    {
        unsigned const lock_count=4;
        unsigned lock_first=0;
        while(true)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            }
        }
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4,typename MutexType5>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4,MutexType5& m5)
    {
        unsigned const lock_count=5;
        unsigned lock_first=0;
        while(true)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4,m5);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m5,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m5,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m5,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            case 4:
                lock_first=detail::lock_helper(m5,m1,m2,m3,m4);
                if(!lock_first)
                    return;
                lock_first=(lock_first+4)%lock_count;
                break;
            }
        }
    }

    namespace detail
    {
        template<typename Mutex,bool x=is_mutex_type<Mutex>::value>
        struct try_lock_impl_return
        {
            typedef int type;
        };

        template<typename Iterator>
        struct try_lock_impl_return<Iterator,false>
        {
            typedef Iterator type;
        };

        template<typename MutexType1,typename MutexType2>
        int try_lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            return ((int)detail::try_lock_internal(m1,m2))-1;
        }

        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3))-1;
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4))-1;
    }

    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4,typename MutexType5>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4,MutexType5& m5)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4,m5))-1;
    }


    namespace detail
    {
        template<typename Iterator>
        struct range_lock_guard
        {
            Iterator begin;
            Iterator end;

            range_lock_guard(Iterator begin_,Iterator end_):
                begin(begin_),end(end_)
            {
                lock(begin,end);
            }

            void release()
            {
                begin=end;
            }

            ~range_lock_guard()
            {
                for(;begin!=end;++begin)
                {
                    begin->unlock();
                }
            }
        };

        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)

        {
            if(begin==end)
            {
                return end;
            }
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;
            unique_lock<lock_type> guard(*begin,try_to_lock);

            if(!guard.owns_lock())
            {
                return begin;
            }
            Iterator const failed=try_lock(++begin,end);
            if(failed==end)
            {
                guard.release();
            }

            return failed;
        }
    }


    namespace detail
    {
        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)
        {
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;

            if(begin==end)
            {
                return;
            }
            bool start_with_begin=true;
            Iterator second=begin;
            ++second;
            Iterator next=second;

            for(;;)
            {
                unique_lock<lock_type> begin_lock(*begin,defer_lock);
                if(start_with_begin)
                {
                    begin_lock.lock();
                    Iterator const failed_lock=try_lock(next,end);
                    if(failed_lock==end)
                    {
                        begin_lock.release();
                        return;
                    }
                    start_with_begin=false;
                    next=failed_lock;
                }
                else
                {
                    detail::range_lock_guard<Iterator> guard(next,end);
                    if(begin_lock.try_lock())
                    {
                        Iterator const failed_lock=try_lock(second,next);
                        if(failed_lock==next)
                        {
                            begin_lock.release();
                            guard.release();
                            return;
                        }
                        start_with_begin=false;
                        next=failed_lock;
                    }
                    else
                    {
                        start_with_begin=true;
                        next=second;
                    }
                }
            }
        }

    }

}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 1429 "/usr/include/boost/thread/locks.hpp" 2 3 4
# 12 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4

# 1 "/usr/include/boost/thread/xtime.hpp" 1 3 4
# 13 "/usr/include/boost/thread/xtime.hpp" 3 4
# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 14 "/usr/include/boost/thread/xtime.hpp" 2 3 4

# 1 "/usr/include/boost/date_time/posix_time/conversion.hpp" 1 3 4
# 16 "/usr/include/boost/date_time/posix_time/conversion.hpp" 3 4
# 1 "/usr/include/boost/date_time/gregorian/conversion.hpp" 1 3 4
# 19 "/usr/include/boost/date_time/gregorian/conversion.hpp" 3 4
namespace boost {

namespace gregorian {


  inline
  std::tm to_tm(const date& d)
  {
    if (d.is_special())
    {
        std::string s = "tm unable to handle ";
        switch (d.as_special())
        {
        case date_time::not_a_date_time:
            s += "not-a-date-time value"; break;
        case date_time::neg_infin:
            s += "-infinity date value"; break;
        case date_time::pos_infin:
            s += "+infinity date value"; break;
        default:
            s += "a special date value"; break;
        }
        boost::throw_exception(std::out_of_range(s));
    }

    std::tm datetm = {};
    boost::gregorian::date::ymd_type ymd = d.year_month_day();
    datetm.tm_year = ymd.year - 1900;
    datetm.tm_mon = ymd.month - 1;
    datetm.tm_mday = ymd.day;
    datetm.tm_wday = d.day_of_week();
    datetm.tm_yday = d.day_of_year() - 1;
    datetm.tm_isdst = -1;
    return datetm;
  }


  inline
  date date_from_tm(const std::tm& datetm)
  {
    return date(static_cast<unsigned short>(datetm.tm_year+1900),
                static_cast<unsigned short>(datetm.tm_mon+1),
                static_cast<unsigned short>(datetm.tm_mday));
  }

} }
# 17 "/usr/include/boost/date_time/posix_time/conversion.hpp" 2 3 4

namespace boost {

namespace posix_time {



  inline
  ptime from_time_t(std::time_t t)
  {
    ptime start(gregorian::date(1970,1,1));
    return start + seconds(static_cast<long>(t));
  }


  inline
  std::tm to_tm(const boost::posix_time::ptime& t) {
    std::tm timetm = boost::gregorian::to_tm(t.date());
    boost::posix_time::time_duration td = t.time_of_day();
    timetm.tm_hour = td.hours();
    timetm.tm_min = td.minutes();
    timetm.tm_sec = td.seconds();
    timetm.tm_isdst = -1;
    return timetm;
  }

  inline
  std::tm to_tm(const boost::posix_time::time_duration& td) {
    std::tm timetm = {};
    timetm.tm_hour = date_time::absolute_value(td.hours());
    timetm.tm_min = date_time::absolute_value(td.minutes());
    timetm.tm_sec = date_time::absolute_value(td.seconds());
    timetm.tm_isdst = -1;
    return timetm;
  }


  inline
  ptime ptime_from_tm(const std::tm& timetm) {
    boost::gregorian::date d = boost::gregorian::date_from_tm(timetm);
    return ptime(d, time_duration(timetm.tm_hour, timetm.tm_min, timetm.tm_sec));
  }
# 85 "/usr/include/boost/date_time/posix_time/conversion.hpp" 3 4
} }
# 16 "/usr/include/boost/thread/xtime.hpp" 2 3 4

# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 18 "/usr/include/boost/thread/xtime.hpp" 2 3 4

namespace boost {

enum xtime_clock_types
{
    TIME_UTC=1







};

struct xtime
{



    typedef int_fast64_t xtime_sec_t;


    typedef int_fast32_t xtime_nsec_t;

    xtime_sec_t sec;
    xtime_nsec_t nsec;

    operator system_time() const
    {
        return boost::posix_time::from_time_t(0)+
            boost::posix_time::seconds(static_cast<long>(sec))+



        boost::posix_time::microseconds((nsec+500)/1000);

    }

};

inline xtime get_xtime(boost::system_time const& abs_time)
{
    xtime res;
    boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);

    res.sec=static_cast<xtime::xtime_sec_t>(time_since_epoch.total_seconds());
    res.nsec=static_cast<xtime::xtime_nsec_t>(time_since_epoch.fractional_seconds()*(1000000000/time_since_epoch.ticks_per_second()));
    return res;
}

inline int xtime_get(struct xtime* xtp, int clock_type)
{
    if (clock_type == TIME_UTC)
    {
        *xtp=get_xtime(get_system_time());
        return clock_type;
    }
    return 0;
}


inline int xtime_cmp(const xtime& xt1, const xtime& xt2)
{
    if (xt1.sec == xt2.sec)
        return (int)(xt1.nsec - xt2.nsec);
    else
        return (xt1.sec > xt2.sec) ? 1 : -1;
}

}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 91 "/usr/include/boost/thread/xtime.hpp" 2 3 4
# 14 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 15 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4
# 1 "/usr/include/errno.h" 1 3 4
# 16 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4
# 1 "/usr/include/boost/thread/pthread/timespec.hpp" 1 3 4
# 16 "/usr/include/boost/thread/pthread/timespec.hpp" 3 4
# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 17 "/usr/include/boost/thread/pthread/timespec.hpp" 2 3 4

namespace boost
{
    namespace detail
    {
        inline struct timespec get_timespec(boost::system_time const& abs_time)
        {
            struct timespec timeout={0,0};
            boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);

            timeout.tv_sec=time_since_epoch.total_seconds();
            timeout.tv_nsec=(long)(time_since_epoch.fractional_seconds()*(1000000000l/time_since_epoch.ticks_per_second()));
            return timeout;
        }
    }
}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 35 "/usr/include/boost/thread/pthread/timespec.hpp" 2 3 4
# 17 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4
# 1 "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 1 3 4
# 10 "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 11 "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2 3 4

# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 13 "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2 3 4

namespace boost
{
    namespace pthread
    {
        class pthread_mutex_scoped_lock
        {
            pthread_mutex_t* m;
        public:
            explicit pthread_mutex_scoped_lock(pthread_mutex_t* m_):
                m(m_)
            {
                ((!pthread_mutex_lock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_lock(m)", "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 25, __PRETTY_FUNCTION__));
            }
            ~pthread_mutex_scoped_lock()
            {
                ((!pthread_mutex_unlock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(m)", "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 29, __PRETTY_FUNCTION__));
            }

        };

        class pthread_mutex_scoped_unlock
        {
            pthread_mutex_t* m;
        public:
            explicit pthread_mutex_scoped_unlock(pthread_mutex_t* m_):
                m(m_)
            {
                ((!pthread_mutex_unlock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(m)", "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 41, __PRETTY_FUNCTION__));
            }
            ~pthread_mutex_scoped_unlock()
            {
                ((!pthread_mutex_lock(m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_lock(m)", "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 45, __PRETTY_FUNCTION__));
            }

        };
    }
}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 53 "/usr/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp" 2 3 4
# 18 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4







# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 26 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4

namespace boost
{
    class mutex:
        boost::noncopyable
    {
    private:
        pthread_mutex_t m;
    public:
        mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                throw thread_resource_error();
            }
        }
        ~mutex()
        {
            ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/usr/include/boost/thread/pthread/mutex.hpp", 45, __PRETTY_FUNCTION__));
        }

        void lock()
        {
            ((!pthread_mutex_lock(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_lock(&m)", "/usr/include/boost/thread/pthread/mutex.hpp", 50, __PRETTY_FUNCTION__));
        }

        void unlock()
        {
            ((!pthread_mutex_unlock(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(&m)", "/usr/include/boost/thread/pthread/mutex.hpp", 55, __PRETTY_FUNCTION__));
        }

        bool try_lock()
        {
            int const res=pthread_mutex_trylock(&m);
            ((!res || res==16) ? static_cast<void> (0) : __assert_fail ("!res || res==16", "/usr/include/boost/thread/pthread/mutex.hpp", 61, __PRETTY_FUNCTION__));
            return !res;
        }

        typedef pthread_mutex_t* native_handle_type;
        native_handle_type native_handle()
        {
            return &m;
        }

        typedef unique_lock<mutex> scoped_lock;
        typedef detail::try_lock_wrapper<mutex> scoped_try_lock;
    };

    typedef mutex try_mutex;

    class timed_mutex:
        boost::noncopyable
    {
    private:
        pthread_mutex_t m;




    public:
        timed_mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                throw thread_resource_error();
            }
# 103 "/usr/include/boost/thread/pthread/mutex.hpp" 3 4
        }
        ~timed_mutex()
        {
            ((!pthread_mutex_destroy(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_destroy(&m)", "/usr/include/boost/thread/pthread/mutex.hpp", 106, __PRETTY_FUNCTION__));



        }

        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time)
        {
            return timed_lock(get_system_time()+relative_time);
        }
        bool timed_lock(boost::xtime const & absolute_time)
        {
            return timed_lock(system_time(absolute_time));
        }


        void lock()
        {
            ((!pthread_mutex_lock(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_lock(&m)", "/usr/include/boost/thread/pthread/mutex.hpp", 125, __PRETTY_FUNCTION__));
        }

        void unlock()
        {
            ((!pthread_mutex_unlock(&m)) ? static_cast<void> (0) : __assert_fail ("!pthread_mutex_unlock(&m)", "/usr/include/boost/thread/pthread/mutex.hpp", 130, __PRETTY_FUNCTION__));
        }

        bool try_lock()
        {
            int const res=pthread_mutex_trylock(&m);
            ((!res || res==16) ? static_cast<void> (0) : __assert_fail ("!res || res==16", "/usr/include/boost/thread/pthread/mutex.hpp", 136, __PRETTY_FUNCTION__));
            return !res;
        }
        bool timed_lock(system_time const & abs_time)
        {
            struct timespec const timeout=detail::get_timespec(abs_time);
            int const res=pthread_mutex_timedlock(&m,&timeout);
            ((!res || res==110) ? static_cast<void> (0) : __assert_fail ("!res || res==110", "/usr/include/boost/thread/pthread/mutex.hpp", 143, __PRETTY_FUNCTION__));
            return !res;
        }

        typedef pthread_mutex_t* native_handle_type;
        native_handle_type native_handle()
        {
            return &m;
        }
# 200 "/usr/include/boost/thread/pthread/mutex.hpp" 3 4
        typedef unique_lock<timed_mutex> scoped_timed_lock;
        typedef detail::try_lock_wrapper<timed_mutex> scoped_try_lock;
        typedef scoped_timed_lock scoped_lock;
    };

}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 208 "/usr/include/boost/thread/pthread/mutex.hpp" 2 3 4
# 17 "/usr/include/boost/thread/mutex.hpp" 2 3 4
# 32 "/usr/include/cocaine/io.hpp" 2 3 4

# 1 "/usr/include/zmq.hpp" 1 3 4
# 24 "/usr/include/zmq.hpp" 3 4
# 1 "/usr/include/zmq.h" 1 3 4
# 25 "/usr/include/zmq.h" 3 4
extern "C" {


# 1 "/usr/include/errno.h" 1 3 4
# 29 "/usr/include/zmq.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 30 "/usr/include/zmq.h" 2 3 4
# 66 "/usr/include/zmq.h" 3 4
__attribute__ ((visibility("default"))) void zmq_version (int *major, int *minor, int *patch);
# 115 "/usr/include/zmq.h" 3 4
__attribute__ ((visibility("default"))) int zmq_errno (void);


__attribute__ ((visibility("default"))) const char *zmq_strerror (int errnum);
# 145 "/usr/include/zmq.h" 3 4
typedef struct
{
    void *content;
    unsigned char flags;
    unsigned char vsm_size;
    unsigned char vsm_data [30];
} zmq_msg_t;

typedef void (zmq_free_fn) (void *data, void *hint);

__attribute__ ((visibility("default"))) int zmq_msg_init (zmq_msg_t *msg);
__attribute__ ((visibility("default"))) int zmq_msg_init_size (zmq_msg_t *msg, size_t size);
__attribute__ ((visibility("default"))) int zmq_msg_init_data (zmq_msg_t *msg, void *data,
    size_t size, zmq_free_fn *ffn, void *hint);
__attribute__ ((visibility("default"))) int zmq_msg_close (zmq_msg_t *msg);
__attribute__ ((visibility("default"))) int zmq_msg_move (zmq_msg_t *dest, zmq_msg_t *src);
__attribute__ ((visibility("default"))) int zmq_msg_copy (zmq_msg_t *dest, zmq_msg_t *src);
__attribute__ ((visibility("default"))) void *zmq_msg_data (zmq_msg_t *msg);
__attribute__ ((visibility("default"))) size_t zmq_msg_size (zmq_msg_t *msg);





__attribute__ ((visibility("default"))) void *zmq_init (int io_threads);
__attribute__ ((visibility("default"))) int zmq_term (void *context);
# 222 "/usr/include/zmq.h" 3 4
__attribute__ ((visibility("default"))) void *zmq_socket (void *context, int type);
__attribute__ ((visibility("default"))) int zmq_close (void *s);
__attribute__ ((visibility("default"))) int zmq_setsockopt (void *s, int option, const void *optval,
    size_t optvallen);
__attribute__ ((visibility("default"))) int zmq_getsockopt (void *s, int option, void *optval,
    size_t *optvallen);
__attribute__ ((visibility("default"))) int zmq_bind (void *s, const char *addr);
__attribute__ ((visibility("default"))) int zmq_connect (void *s, const char *addr);
__attribute__ ((visibility("default"))) int zmq_send (void *s, zmq_msg_t *msg, int flags);
__attribute__ ((visibility("default"))) int zmq_recv (void *s, zmq_msg_t *msg, int flags);
# 241 "/usr/include/zmq.h" 3 4
typedef struct
{
    void *socket;



    int fd;

    short events;
    short revents;
} zmq_pollitem_t;

__attribute__ ((visibility("default"))) int zmq_poll (zmq_pollitem_t *items, int nitems, long timeout);
# 263 "/usr/include/zmq.h" 3 4
__attribute__ ((visibility("default"))) int zmq_device (int device, void * insocket, void* outsocket);




}
# 25 "/usr/include/zmq.hpp" 2 3 4


# 1 "/usr/include/c++/4.4/cassert" 1 3 4
# 43 "/usr/include/c++/4.4/cassert" 3 4
       
# 44 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 28 "/usr/include/zmq.hpp" 2 3 4
# 1 "/usr/include/c++/4.4/cstring" 1 3 4
# 41 "/usr/include/c++/4.4/cstring" 3 4
       
# 42 "/usr/include/c++/4.4/cstring" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
       
# 42 "/usr/include/c++/4.4/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 45 "/usr/include/c++/4.4/cstddef" 2 3
# 45 "/usr/include/c++/4.4/cstring" 2 3
# 29 "/usr/include/zmq.hpp" 2 3 4
# 52 "/usr/include/zmq.hpp" 3 4
namespace zmq
{

    typedef zmq_free_fn free_fn;
    typedef zmq_pollitem_t pollitem_t;

    class error_t : public std::exception
    {
    public:

        error_t () : errnum (zmq_errno ()) {}

        virtual const char *what () const throw ()
        {
            return zmq_strerror (errnum);
        }

        int num () const
        {
            return errnum;
        }

    private:

        int errnum;
    };

    inline int poll (zmq_pollitem_t *items_, int nitems_, long timeout_ = -1)
    {
        int rc = zmq_poll (items_, nitems_, timeout_);
        if (rc < 0)
            throw error_t ();
        return rc;
    }

    inline void device (int device_, void * insocket_, void* outsocket_)
    {
        int rc = zmq_device (device_, insocket_, outsocket_);
        if (rc != 0)
            throw error_t ();
    }

    inline void version (int *major_, int *minor_, int *patch_)
    {
        zmq_version (major_, minor_, patch_);
    }

    class message_t : private zmq_msg_t
    {
        friend class socket_t;

    public:

        inline message_t ()
        {
            int rc = zmq_msg_init (this);
            if (rc != 0)
                throw error_t ();
        }

        inline message_t (size_t size_)
        {
            int rc = zmq_msg_init_size (this, size_);
            if (rc != 0)
                throw error_t ();
        }

        inline message_t (void *data_, size_t size_, free_fn *ffn_,
            void *hint_ = __null)
        {
            int rc = zmq_msg_init_data (this, data_, size_, ffn_, hint_);
            if (rc != 0)
                throw error_t ();
        }

        inline ~message_t ()
        {
            int rc = zmq_msg_close (this);
            ((rc == 0) ? static_cast<void> (0) : __assert_fail ("rc == 0", "/usr/include/zmq.hpp", 130, __PRETTY_FUNCTION__));
        }

        inline void rebuild ()
        {
            int rc = zmq_msg_close (this);
            if (rc != 0)
                throw error_t ();
            rc = zmq_msg_init (this);
            if (rc != 0)
                throw error_t ();
        }

        inline void rebuild (size_t size_)
        {
            int rc = zmq_msg_close (this);
            if (rc != 0)
                throw error_t ();
            rc = zmq_msg_init_size (this, size_);
            if (rc != 0)
                throw error_t ();
        }

        inline void rebuild (void *data_, size_t size_, free_fn *ffn_,
            void *hint_ = __null)
        {
            int rc = zmq_msg_close (this);
            if (rc != 0)
                throw error_t ();
            rc = zmq_msg_init_data (this, data_, size_, ffn_, hint_);
            if (rc != 0)
                throw error_t ();
        }

        inline void move (message_t *msg_)
        {
            int rc = zmq_msg_move (this, (zmq_msg_t*) msg_);
            if (rc != 0)
                throw error_t ();
        }

        inline void copy (message_t *msg_)
        {
            int rc = zmq_msg_copy (this, (zmq_msg_t*) msg_);
            if (rc != 0)
                throw error_t ();
        }

        inline void *data ()
        {
            return zmq_msg_data (this);
        }

        inline size_t size ()
        {
            return zmq_msg_size (this);
        }

    private:



        message_t (const message_t&);
        void operator = (const message_t&);
    };

    class context_t
    {
        friend class socket_t;

    public:

        inline context_t (int io_threads_)
        {
            ptr = zmq_init (io_threads_);
            if (ptr == __null)
                throw error_t ();
        }


        inline context_t(context_t&& rhs) : ptr(rhs.ptr)
        {
            rhs.ptr = __null;
        }
        inline context_t& operator=(context_t&& rhs)
        {
            std::swap(ptr, rhs.ptr);
            return *this;
        }


        inline ~context_t ()
        {
            if (ptr == __null)
                return;
            int rc = zmq_term (ptr);
            ((rc == 0) ? static_cast<void> (0) : __assert_fail ("rc == 0", "/usr/include/zmq.hpp", 226, __PRETTY_FUNCTION__));
        }




        inline operator void* ()
        {
            return ptr;
        }

    private:

        void *ptr;

        context_t (const context_t&);
        void operator = (const context_t&);
    };

    class socket_t
    {
    public:

        inline socket_t (context_t &context_, int type_)
        {
            ptr = zmq_socket (context_.ptr, type_);
            if (ptr == __null)
                throw error_t ();
        }


        inline socket_t(socket_t&& rhs) : ptr(rhs.ptr)
        {
            rhs.ptr = __null;
        }
        inline socket_t& operator=(socket_t&& rhs)
        {
            std::swap(ptr, rhs.ptr);
            return *this;
        }


        inline ~socket_t ()
        {
            close();
        }

        inline operator void* ()
        {
            return ptr;
        }

        inline void close()
        {
            if(ptr == __null)

                return ;
            int rc = zmq_close (ptr);
            if (rc != 0)
                throw error_t ();
            ptr = 0 ;
        }

        inline void setsockopt (int option_, const void *optval_,
            size_t optvallen_)
        {
            int rc = zmq_setsockopt (ptr, option_, optval_, optvallen_);
            if (rc != 0)
                throw error_t ();
        }

        inline void getsockopt (int option_, void *optval_,
            size_t *optvallen_)
        {
            int rc = zmq_getsockopt (ptr, option_, optval_, optvallen_);
            if (rc != 0)
                throw error_t ();
        }

        inline void bind (const char *addr_)
        {
            int rc = zmq_bind (ptr, addr_);
            if (rc != 0)
                throw error_t ();
        }

        inline void connect (const char *addr_)
        {
            int rc = zmq_connect (ptr, addr_);
            if (rc != 0)
                throw error_t ();
        }

        inline bool send (message_t &msg_, int flags_ = 0)
        {
            int rc = zmq_send (ptr, &msg_, flags_);
            if (rc == 0)
                return true;
            if (rc == -1 && zmq_errno () == 11)
                return false;
            throw error_t ();
        }

        inline bool recv (message_t *msg_, int flags_ = 0)
        {
            int rc = zmq_recv (ptr, msg_, flags_);
            if (rc == 0)
                return true;
            if (rc == -1 && zmq_errno () == 11)
                return false;
            throw error_t ();
        }

    private:

        void *ptr;

        socket_t (const socket_t&);
        void operator = (const socket_t&);
    };

}
# 34 "/usr/include/cocaine/io.hpp" 2 3 4





namespace cocaine { namespace io {



class socket_base_t:
    public boost::noncopyable,
    public birth_control<socket_base_t>
{
    public:
        socket_base_t(context_t& context,
                      int type);

        virtual
        ~socket_base_t();

        void
        bind();

        void
        bind(const std::string& endpoint);

        void
        connect(const std::string& endpoint);

        bool
        send(zmq::message_t& message,
             int flags = 0);

        bool
        recv(zmq::message_t& message,
             int flags = 0);

        void
        drop();

        void
        getsockopt(int name,
                   void * value,
                   size_t * size);

        void
        setsockopt(int name,
                   const void * value,
                   size_t size);

    public:
        int
        fd() const {
            return m_fd;
        }

        std::string
        endpoint() const {
            return m_endpoint;
        }

        bool
        more() {
            int64_t rcvmore = 0;
            size_t size = sizeof(rcvmore);

            getsockopt(13, &rcvmore, &size);

            return rcvmore != 0;
        }

        std::string
        identity() {
            char identity[256] = { 0 };
            size_t size = sizeof(identity);

            getsockopt(5, &identity, &size);

            return identity;
        }

        bool
        pending(unsigned long event = 1) {
            unsigned long events = 0;
            size_t size = sizeof(events);

            getsockopt(15, &events, &size);

            return events & event;
        }

    protected:
        zmq::socket_t m_socket;

    private:
        context_t& m_context;

        int m_fd;
        std::string m_endpoint;

        uint16_t m_port;
};



namespace options {
    struct receive_timeout {
        typedef int value_type;
        typedef boost::mpl::int_<27> option_type;
    };

    struct send_timeout {
        typedef int value_type;
        typedef boost::mpl::int_<28> option_type;
    };
}

template<class Option>
class scoped_option {
    typedef typename Option::value_type value_type;
    typedef typename Option::option_type option_type;

    public:
        scoped_option(socket_base_t& socket,
                      value_type value):
            m_socket(socket),
            m_saved(value_type()),
            m_size(sizeof(m_saved))
        {
            m_socket.getsockopt(option_type(), &m_saved, &m_size);
            m_socket.setsockopt(option_type(), &value, sizeof(value));
        }

        ~scoped_option() {
            m_socket.setsockopt(option_type(), &m_saved, m_size);
        }

    private:
        socket_base_t& m_socket;
        value_type m_saved;
        size_t m_size;
};



namespace policies {
    struct unique { };

    struct shared {
        void
        lock() {
            m_mutex.lock();
        }

        void
        unlock() {
            m_mutex.unlock();
        }

    private:
        boost::mutex m_mutex;
    };
}



namespace detail {
    template<class T>
    struct raw {
        raw(T&& value_):
            value(std::forward<T>(value_))
        { }

        T&& value;
    };
}

template<class T>
struct raw_traits;

template<>
struct raw_traits<std::string> {
    static inline
    void
    pack(zmq::message_t& message,
         const std::string& value)
    {
        message.rebuild(value.size());

        std::memcpy(
            message.data(),
            value.data(),
            value.size()
        );
    }

    static inline
    void
    unpack( zmq::message_t& message,
           std::string& value)
    {
        value.assign(
            static_cast<const char*>(message.data()),
            message.size()
        );
    }
};

template<class T>
static inline
detail::raw<T>
protect(T&& value) {
    return detail::raw<T>(std::forward<T>(value));
}



template<class SharingPolicy>
struct socket:
    public socket_base_t,
    public SharingPolicy
{
    socket(context_t& context,
           int type):
        socket_base_t(context, type)
    { }

    using socket_base_t::send;
    using socket_base_t::recv;



    template<class T>
    bool
    send(const T& value,
         int flags = 0)
    {
        msgpack::sbuffer buffer;
        msgpack::packer<msgpack::sbuffer> packer(buffer);

        type_traits<T>::pack(packer, value);

        zmq::message_t message(buffer.size());

        std::memcpy(
            message.data(),
            buffer.data(),
            buffer.size()
        );

        return send(message, flags);
    }



    template<class T>
    bool
    send(const detail::raw<T>& object,
         int flags = 0)
    {
        zmq::message_t message;

        typedef typename std::remove_const<
            typename std::remove_reference<T>::type
        >::type argument_type;

        raw_traits<argument_type>::pack(message, object.value);

        return send(message, flags);
    }



    template<class Head>
    bool
    send_multipart(Head&& head) {
        return send(head);
    }

    template<class Head, class... Tail>
    bool
    send_multipart(Head&& head,
                   Tail&&... tail)
    {
        return send(head, 2) &&
               send_multipart(std::forward<Tail>(tail)...);
    }



    template<class T>
    bool
    recv(T& result,
         int flags = 0)
    {
        zmq::message_t message;
        msgpack::unpacked unpacked;

        if(!recv(message, flags)) {
            return false;
        }

        try {
            msgpack::unpack(
                &unpacked,
                static_cast<const char*>(message.data()),
                message.size()
            );
        } catch(const msgpack::unpack_error& e) {
            throw cocaine::error_t("corrupted object");
        }

        try {
            type_traits<T>::unpack(unpacked.get(), result);
        } catch(const msgpack::type_error& e) {
            throw cocaine::error_t("corrupted object");
        } catch(const std::bad_cast& e) {
            throw cocaine::error_t("corrupted object - type mismatch");
        }

        return true;
    }



    template<class T>
    bool
    recv(detail::raw<T>& result,
         int flags = 0)
    {
        zmq::message_t message;

        if(!recv(message, flags)) {
            return false;
        }

        typedef typename std::remove_const<
            typename std::remove_reference<T>::type
        >::type argument_type;

        raw_traits<argument_type>::unpack(message, result.value);

        return true;
    }

    template<class T>
    bool
    recv(detail::raw<T>&& result,
         int flags = 0)
    {
        return recv(result, flags);
    }



    template<class Head>
    bool
    recv_multipart(Head&& head) {
        return recv(head);
    }

    template<class Head, class... Tail>
    bool
    recv_multipart(Head&& head,
                   Tail&&... tail)
    {
        return recv(head) &&
               recv_multipart(std::forward<Tail>(tail)...);
    }
};

}}
# 25 "/usr/include/cocaine/channel.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/contains.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/contains.hpp" 3 4
# 1 "/usr/include/boost/mpl/contains_fwd.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/contains_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct contains_impl;
template< typename Sequence, typename T > struct contains;

}}
# 19 "/usr/include/boost/mpl/contains.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/aux_/contains_impl.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/aux_/contains_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/find.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/find.hpp" 3 4
# 1 "/usr/include/boost/mpl/find_if.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/find_if.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/find_if_pred.hpp" 1 3 4
# 14 "/usr/include/boost/mpl/aux_/find_if_pred.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/iter_apply.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/aux_/iter_apply.hpp" 3 4
# 1 "/usr/include/boost/mpl/apply.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/aux_/iter_apply.hpp" 2 3 4


namespace boost { namespace mpl { namespace aux {

template<
      typename F
    , typename Iterator
    >
struct iter_apply1
    : apply1< F,typename deref<Iterator>::type >
{
};

template<
      typename F
    , typename Iterator1
    , typename Iterator2
    >
struct iter_apply2
    : apply2<
          F
        , typename deref<Iterator1>::type
        , typename deref<Iterator2>::type
        >
{
};

}}}
# 15 "/usr/include/boost/mpl/aux_/find_if_pred.hpp" 2 3 4


namespace boost { namespace mpl { namespace aux {

template< typename Predicate >
struct find_if_pred
{
    template< typename Iterator >
    struct apply
    {
        typedef not_< aux::iter_apply1<Predicate,Iterator> > type;
    };
};

}}}
# 18 "/usr/include/boost/mpl/find_if.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/arg.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/find_if.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/iter_fold_if.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/iter_fold_if.hpp" 3 4
# 1 "/usr/include/boost/mpl/logical.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/iter_fold_if.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/always.hpp" 1 3 4
# 21 "/usr/include/boost/mpl/always.hpp" 3 4
namespace boost { namespace mpl {

template< typename Value > struct always
{
    template<
          typename T
        , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na
        >
    struct apply
    {
        typedef Value type;
    };
};



}}
# 21 "/usr/include/boost/mpl/iter_fold_if.hpp" 2 3 4


# 1 "/usr/include/boost/mpl/pair.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/pair.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename T1 = na
    , typename T2 = na
    >
struct pair
{
    typedef pair type;
    typedef T1 first;
    typedef T2 second;

   
};

template<
      typename P = na
    >
struct first
{

    typedef typename P::first type;



   
};

template<
      typename P = na
    >
struct second
{

    typedef typename P::second type;



   
};


template<> struct pair< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : pair< T1 , T2 > { }; }; template< typename Tag > struct lambda< pair< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef pair< na , na > result_; typedef pair< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< pair< T1 , T2 > > : int_<2> { }; template<> struct template_arity< pair< na , na > > : int_<-1> { }; }
template<> struct first< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : first< T1 > { }; }; template< typename Tag > struct lambda< first< na > , Tag , int_<-1> > { typedef false_ is_le; typedef first< na > result_; typedef first< na > type; }; namespace aux { template< typename T1 > struct template_arity< first< T1 > > : int_<1> { }; template<> struct template_arity< first< na > > : int_<-1> { }; }
template<> struct second< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : second< T1 > { }; }; template< typename Tag > struct lambda< second< na > , Tag , int_<-1> > { typedef false_ is_le; typedef second< na > result_; typedef second< na > type; }; namespace aux { template< typename T1 > struct template_arity< second< T1 > > : int_<1> { }; template<> struct template_arity< second< na > > : int_<-1> { }; }

}}
# 24 "/usr/include/boost/mpl/iter_fold_if.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/apply.hpp" 1 3 4
# 25 "/usr/include/boost/mpl/iter_fold_if.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 1 3 4
# 22 "/usr/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/apply.hpp" 1 3 4
# 23 "/usr/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2 3 4
# 32 "/usr/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp" 1 3 4
# 13 "/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

template< typename Iterator, typename State >
struct iter_fold_if_null_step
{
    typedef State state;
    typedef Iterator iterator;
};

template< bool >
struct iter_fold_if_step_impl
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef typename apply2< StateOp,State,Iterator >::type state;
        typedef typename IteratorOp::type iterator;
    };
};

template<>
struct iter_fold_if_step_impl<false>
{
    template<
          typename Iterator
        , typename State
        , typename StateOp
        , typename IteratorOp
        >
    struct result_
    {
        typedef State state;
        typedef Iterator iterator;
    };
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename Predicate
    >
struct iter_fold_if_forward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,ForwardOp, mpl::next<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename BackwardOp
    , typename Predicate
    >
struct iter_fold_if_backward_step
{
    typedef typename apply2< Predicate,State,Iterator >::type not_last;
    typedef typename iter_fold_if_step_impl<
          not_last::value
        >::template result_< Iterator,State,BackwardOp, identity<Iterator> > impl_;

    typedef typename impl_::state state;
    typedef typename impl_::iterator iterator;
};

template<
      typename Iterator
    , typename State
    , typename ForwardOp
    , typename ForwardPredicate
    , typename BackwardOp
    , typename BackwardPredicate
    >
struct iter_fold_if_impl
{
 private:
    typedef iter_fold_if_null_step< Iterator,State > forward_step0;
    typedef iter_fold_if_forward_step< typename forward_step0::iterator, typename forward_step0::state, ForwardOp, ForwardPredicate > forward_step1;
    typedef iter_fold_if_forward_step< typename forward_step1::iterator, typename forward_step1::state, ForwardOp, ForwardPredicate > forward_step2;
    typedef iter_fold_if_forward_step< typename forward_step2::iterator, typename forward_step2::state, ForwardOp, ForwardPredicate > forward_step3;
    typedef iter_fold_if_forward_step< typename forward_step3::iterator, typename forward_step3::state, ForwardOp, ForwardPredicate > forward_step4;


    typedef typename if_<
          typename forward_step4::not_last
        , iter_fold_if_impl<
              typename forward_step4::iterator
            , typename forward_step4::state
            , ForwardOp
            , ForwardPredicate
            , BackwardOp
            , BackwardPredicate
            >
        , iter_fold_if_null_step<
              typename forward_step4::iterator
            , typename forward_step4::state
            >
        >::type backward_step4;

    typedef iter_fold_if_backward_step< typename forward_step3::iterator, typename backward_step4::state, BackwardOp, BackwardPredicate > backward_step3;
    typedef iter_fold_if_backward_step< typename forward_step2::iterator, typename backward_step3::state, BackwardOp, BackwardPredicate > backward_step2;
    typedef iter_fold_if_backward_step< typename forward_step1::iterator, typename backward_step2::state, BackwardOp, BackwardPredicate > backward_step1;
    typedef iter_fold_if_backward_step< typename forward_step0::iterator, typename backward_step1::state, BackwardOp, BackwardPredicate > backward_step0;


 public:
    typedef typename backward_step0::state state;
    typedef typename backward_step4::iterator iterator;
};

}}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 33 "/usr/include/boost/mpl/aux_/iter_fold_if_impl.hpp" 2 3 4
# 26 "/usr/include/boost/mpl/iter_fold_if.hpp" 2 3 4







namespace boost { namespace mpl {

namespace aux {

template< typename Predicate, typename LastIterator >
struct iter_fold_if_pred
{
    template< typename State, typename Iterator > struct apply

        : and_<
              not_< is_same<Iterator,LastIterator> >
            , apply1<Predicate,Iterator>
            >
    {







    };
};

}

template<
      typename Sequence = na
    , typename State = na
    , typename ForwardOp = na
    , typename ForwardPredicate = na
    , typename BackwardOp = na
    , typename BackwardPredicate = na
    >
struct iter_fold_if
{

    typedef typename begin<Sequence>::type first_;
    typedef typename end<Sequence>::type last_;

    typedef typename eval_if<
          is_na<BackwardPredicate>
        , if_< is_na<BackwardOp>, always<false_>, always<true_> >
        , identity<BackwardPredicate>
        >::type backward_pred_;



    struct result_ :



        aux::iter_fold_if_impl<
          first_
        , State
        , ForwardOp
        , protect< aux::iter_fold_if_pred< ForwardPredicate,last_ > >
        , BackwardOp
        , backward_pred_
        >

    { };




public:

    typedef pair<
          typename result_::state
        , typename result_::iterator
        > type;

   




};

template<> struct iter_fold_if< na , na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct apply : iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > { }; }; template< typename Tag > struct lambda< iter_fold_if< na , na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef iter_fold_if< na , na , na , na , na , na > result_; typedef iter_fold_if< na , na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< iter_fold_if< T1 , T2 , T3 , T4 , T5 , T6 > > : int_<6> { }; template<> struct template_arity< iter_fold_if< na , na , na , na , na , na > > : int_<-1> { }; }

}}
# 20 "/usr/include/boost/mpl/find_if.hpp" 2 3 4




namespace boost { namespace mpl {



template<
      typename Sequence = na
    , typename Predicate = na
    >
struct find_if
{
    typedef typename iter_fold_if<
          Sequence
        , void
        , mpl::arg<1>
        , protect< aux::find_if_pred<Predicate> >
        >::type result_;

    typedef typename second<result_>::type type;

   
};

template<> struct find_if< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find_if< T1 , T2 > { }; }; template< typename Tag > struct lambda< find_if< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find_if< na , na > result_; typedef find_if< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find_if< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find_if< na , na > > : int_<-1> { }; }

}}
# 18 "/usr/include/boost/mpl/find.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/same_as.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/same_as.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/lambda_spec.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/same_as.hpp" 2 3 4




namespace boost { namespace mpl {

template< typename T1 >
struct same_as
{
    template< typename T2 > struct apply

        : is_same<T1,T2>
    {




    };
};

template< typename T1 >
struct not_same_as
{
    template< typename T2 > struct apply

        : not_< is_same<T1,T2> >
    {




    };
};

}}
# 19 "/usr/include/boost/mpl/find.hpp" 2 3 4



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct find
    : find_if< Sequence,same_as<T> >
{
   
};

template<> struct find< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : find< T1 , T2 > { }; }; template< typename Tag > struct lambda< find< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef find< na , na > result_; typedef find< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< find< T1 , T2 > > : int_<2> { }; template<> struct template_arity< find< na , na > > : int_<-1> { }; }

}}
# 21 "/usr/include/boost/mpl/aux_/contains_impl.hpp" 2 3 4







namespace boost { namespace mpl {

template< typename Tag >
struct contains_impl
{
    template< typename Sequence, typename T > struct apply

        : not_< is_same<
              typename find<Sequence,T>::type
            , typename end<Sequence>::type
            > >
    {
# 54 "/usr/include/boost/mpl/aux_/contains_impl.hpp" 3 4
    };
};

 template<> struct contains_impl<non_sequence_tag> {};

}}
# 21 "/usr/include/boost/mpl/contains.hpp" 2 3 4



namespace boost { namespace mpl {

template<
      typename Sequence = na
    , typename T = na
    >
struct contains
    : contains_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,T >
{
   
};

template<> struct contains< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : contains< T1 , T2 > { }; }; template< typename Tag > struct lambda< contains< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef contains< na , na > result_; typedef contains< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< contains< T1 , T2 > > : int_<2> { }; template<> struct template_arity< contains< na , na > > : int_<-1> { }; }

}}
# 28 "/usr/include/cocaine/channel.hpp" 2 3 4



# 1 "/usr/include/boost/mpl/list.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/list.hpp" 3 4
# 1 "/usr/include/boost/mpl/limits/list.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/list.hpp" 2 3 4
# 36 "/usr/include/boost/mpl/list.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/list20.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/list/list20.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/list10.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/list/list10.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/list0.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/list/list0.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/aux_/push_front.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/push_front.hpp" 3 4
# 1 "/usr/include/boost/mpl/push_front_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/push_front_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct push_front_impl;
template< typename Sequence, typename T > struct push_front;

}}
# 18 "/usr/include/boost/mpl/list/aux_/push_front.hpp" 2 3 4

# 1 "/usr/include/boost/mpl/list/aux_/item.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/list/aux_/item.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/aux_/tag.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/tag.hpp" 3 4
namespace boost { namespace mpl { namespace aux {

struct list_tag;
struct l_iter_tag;

}}}
# 19 "/usr/include/boost/mpl/list/aux_/item.hpp" 2 3 4



namespace boost { namespace mpl {

template<
      typename Size
    , typename T
    , typename Next
    >
struct l_item
{




    typedef aux::list_tag tag;
    typedef l_item type;

    typedef Size size;
    typedef T item;
    typedef Next next;
};

struct l_end
{



    typedef aux::list_tag tag;
    typedef l_end type;
    typedef long_<0> size;
};

}}
# 20 "/usr/include/boost/mpl/list/aux_/push_front.hpp" 2 3 4


namespace boost { namespace mpl {

template<>
struct push_front_impl< aux::list_tag >
{
    template< typename List, typename T > struct apply
    {
        typedef l_item<
              typename next<typename List::size>::type
            , T
            , typename List::type
            > type;
    };
};

}}
# 20 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/pop_front.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/pop_front.hpp" 3 4
# 1 "/usr/include/boost/mpl/pop_front_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/pop_front_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct pop_front_impl;
template< typename Sequence > struct pop_front;

}}
# 18 "/usr/include/boost/mpl/list/aux_/pop_front.hpp" 2 3 4



namespace boost { namespace mpl {

template<>
struct pop_front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename mpl::next<List>::type type;
    };
};

}}
# 21 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/push_back.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/push_back.hpp" 3 4
# 1 "/usr/include/boost/mpl/push_back_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/push_back_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct push_back_impl;
template< typename Sequence, typename T > struct push_back;

}}
# 18 "/usr/include/boost/mpl/list/aux_/push_back.hpp" 2 3 4



namespace boost { namespace mpl {

template< typename Tag > struct has_push_back_impl;

template<>
struct has_push_back_impl< aux::list_tag >
{
    template< typename Seq > struct apply
        : false_
    {
    };
};

}}
# 22 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/front.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/front.hpp" 3 4
# 1 "/usr/include/boost/mpl/front_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/front_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct front_impl;
template< typename Sequence > struct front;

}}
# 18 "/usr/include/boost/mpl/list/aux_/front.hpp" 2 3 4


namespace boost { namespace mpl {

template<>
struct front_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef typename List::item type;
    };
};

}}
# 23 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/clear.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/clear.hpp" 3 4
# 1 "/usr/include/boost/mpl/clear_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/clear_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct clear_impl;
template< typename Sequence > struct clear;

}}
# 18 "/usr/include/boost/mpl/list/aux_/clear.hpp" 2 3 4



namespace boost { namespace mpl {

template<>
struct clear_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_end type;
    };
};

}}
# 24 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/O1_size.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/list/aux_/O1_size.hpp" 3 4
namespace boost { namespace mpl {

template<>
struct O1_size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 25 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/size.hpp" 1 3 4
# 20 "/usr/include/boost/mpl/list/aux_/size.hpp" 3 4
namespace boost { namespace mpl {

template<>
struct size_impl< aux::list_tag >
{
    template< typename List > struct apply
        : List::size
    {
    };
};

}}
# 26 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/empty.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/empty.hpp" 3 4
# 1 "/usr/include/boost/mpl/empty_fwd.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/empty_fwd.hpp" 3 4
namespace boost { namespace mpl {

template< typename Tag > struct empty_impl;
template< typename Sequence > struct empty;

}}
# 18 "/usr/include/boost/mpl/list/aux_/empty.hpp" 2 3 4



namespace boost { namespace mpl {

template<>
struct empty_impl< aux::list_tag >
{
    template< typename List > struct apply
        : not_<typename List::size>
    {
    };
};

}}
# 27 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4
# 1 "/usr/include/boost/mpl/list/aux_/begin_end.hpp" 1 3 4
# 18 "/usr/include/boost/mpl/list/aux_/begin_end.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/aux_/iterator.hpp" 1 3 4
# 17 "/usr/include/boost/mpl/list/aux_/iterator.hpp" 3 4
# 1 "/usr/include/boost/mpl/iterator_tags.hpp" 1 3 4
# 19 "/usr/include/boost/mpl/iterator_tags.hpp" 3 4
namespace boost { namespace mpl {

struct forward_iterator_tag : int_<0> { typedef forward_iterator_tag type; };
struct bidirectional_iterator_tag : int_<1> { typedef bidirectional_iterator_tag type; };
struct random_access_iterator_tag : int_<2> { typedef random_access_iterator_tag type; };

}}
# 18 "/usr/include/boost/mpl/list/aux_/iterator.hpp" 2 3 4







namespace boost { namespace mpl {



template< typename Node >
struct l_iter
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;
};

template< typename Node >
struct deref< l_iter<Node> >
{
    typedef typename Node::item type;
};

template< typename Node >
struct next< l_iter<Node> >
{
    typedef l_iter< typename Node::next > type;
};
# 62 "/usr/include/boost/mpl/list/aux_/iterator.hpp" 3 4
template<> struct l_iter<l_end>
{
    typedef aux::l_iter_tag tag;
    typedef forward_iterator_tag category;




};

template< typename T1 , typename Tag > struct lambda< l_iter< T1 > , Tag , int_<1> > { typedef false_ is_le; typedef l_iter< T1 > result_; typedef result_ type; };

}}
# 19 "/usr/include/boost/mpl/list/aux_/begin_end.hpp" 2 3 4



namespace boost { namespace mpl {

template<>
struct begin_impl< aux::list_tag >
{
    template< typename List > struct apply
    {
        typedef l_iter<typename List::type> type;
    };
};

template<>
struct end_impl< aux::list_tag >
{
    template< typename > struct apply
    {
        typedef l_iter<l_end> type;
    };
};

}}
# 28 "/usr/include/boost/mpl/list/list0.hpp" 2 3 4


namespace boost { namespace mpl {

template< typename Dummy = na > struct list0;

template<> struct list0<na>
    : l_end
{
    typedef l_end type;
};

}}
# 19 "/usr/include/boost/mpl/list/list10.hpp" 2 3 4
# 27 "/usr/include/boost/mpl/list/list10.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1 3 4
# 30 "/usr/include/boost/mpl/list/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename T0
    >
struct list1
    : l_item<
          long_<1>
        , T0
        , l_end
        >
{
    typedef list1 type;
};

template<
      typename T0, typename T1
    >
struct list2
    : l_item<
          long_<2>
        , T0
        , list1<T1>
        >
{
    typedef list2 type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list3
    : l_item<
          long_<3>
        , T0
        , list2< T1,T2 >
        >
{
    typedef list3 type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list4
    : l_item<
          long_<4>
        , T0
        , list3< T1,T2,T3 >
        >
{
    typedef list4 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list5
    : l_item<
          long_<5>
        , T0
        , list4< T1,T2,T3,T4 >
        >
{
    typedef list5 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list6
    : l_item<
          long_<6>
        , T0
        , list5< T1,T2,T3,T4,T5 >
        >
{
    typedef list6 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list7
    : l_item<
          long_<7>
        , T0
        , list6< T1,T2,T3,T4,T5,T6 >
        >
{
    typedef list7 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list8
    : l_item<
          long_<8>
        , T0
        , list7< T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef list8 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list9
    : l_item<
          long_<9>
        , T0
        , list8< T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef list9 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list10
    : l_item<
          long_<10>
        , T0
        , list9< T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef list10 type;
};

}}
# 31 "/usr/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2 3 4
# 28 "/usr/include/boost/mpl/list/list10.hpp" 2 3 4
# 19 "/usr/include/boost/mpl/list/list20.hpp" 2 3 4
# 27 "/usr/include/boost/mpl/list/list20.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/aux_/include_preprocessed.hpp" 1 3 4
# 30 "/usr/include/boost/mpl/list/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list11
    : l_item<
          long_<11>
        , T0
        , list10< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef list11 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list12
    : l_item<
          long_<12>
        , T0
        , list11< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef list12 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list13
    : l_item<
          long_<13>
        , T0
        , list12< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef list13 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list14
    : l_item<
          long_<14>
        , T0
        , list13< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef list14 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list15
    : l_item<
          long_<15>
        , T0
        , list14< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef list15 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list16
    : l_item<
          long_<16>
        , T0
        , list15< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef list16 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list17
    : l_item<
          long_<17>
        , T0
        , list16< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef list17 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list18
    : l_item<
          long_<18>
        , T0
        , list17< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef list18 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list19
    : l_item<
          long_<19>
        , T0
        , list18< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef list19 type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list20
    : l_item<
          long_<20>
        , T0
        , list19< T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >
        >
{
    typedef list20 type;
};

}}
# 31 "/usr/include/boost/mpl/list/aux_/include_preprocessed.hpp" 2 3 4
# 28 "/usr/include/boost/mpl/list/list20.hpp" 2 3 4
# 37 "/usr/include/boost/mpl/list.hpp" 2 3 4
# 46 "/usr/include/boost/mpl/list.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 1 3 4
# 37 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 3 4
# 1 "/usr/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 1 3 4
# 12 "/usr/include/boost/mpl/aux_/preprocessed/gcc/list.hpp" 3 4
namespace boost { namespace mpl {

template<
      typename T0 = na, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na, typename T6 = na, typename T7 = na
    , typename T8 = na, typename T9 = na, typename T10 = na, typename T11 = na
    , typename T12 = na, typename T13 = na, typename T14 = na
    , typename T15 = na, typename T16 = na, typename T17 = na
    , typename T18 = na, typename T19 = na
    >
struct list;

template<

    >
struct list<
          na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list0< >
{
    typedef list0< >::type type;
};

template<
      typename T0
    >
struct list<
          T0, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list1<T0>
{
    typedef typename list1<T0>::type type;
};

template<
      typename T0, typename T1
    >
struct list<
          T0, T1, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list2< T0,T1 >
{
    typedef typename list2< T0,T1 >::type type;
};

template<
      typename T0, typename T1, typename T2
    >
struct list<
          T0, T1, T2, na, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list3< T0,T1,T2 >
{
    typedef typename list3< T0,T1,T2 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3
    >
struct list<
          T0, T1, T2, T3, na, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list4< T0,T1,T2,T3 >
{
    typedef typename list4< T0,T1,T2,T3 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct list<
          T0, T1, T2, T3, T4, na, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list5< T0,T1,T2,T3,T4 >
{
    typedef typename list5< T0,T1,T2,T3,T4 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct list<
          T0, T1, T2, T3, T4, T5, na, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list6< T0,T1,T2,T3,T4,T5 >
{
    typedef typename list6< T0,T1,T2,T3,T4,T5 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, na, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list7< T0,T1,T2,T3,T4,T5,T6 >
{
    typedef typename list7< T0,T1,T2,T3,T4,T5,T6 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, na, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list8< T0,T1,T2,T3,T4,T5,T6,T7 >
{
    typedef typename list8< T0,T1,T2,T3,T4,T5,T6,T7 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, na, na, na, na, na, na, na, na
        , na, na, na
        >
    : list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
{
    typedef typename list9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, na, na, na, na, na, na, na
        , na, na, na
        >
    : list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
{
    typedef typename list10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, na, na, na, na, na, na
        , na, na, na
        >
    : list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
{
    typedef typename list11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, na, na, na, na
        , na, na, na, na
        >
    : list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
{
    typedef typename list12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, na, na, na
        , na, na, na, na
        >
    : list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
{
    typedef typename list13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, na, na
        , na, na, na, na
        >
    : list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
{
    typedef typename list14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, na
        , na, na, na, na
        >
    : list15<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        >
{
    typedef typename list15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, na, na, na, na
        >
    : list16<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15
        >
{
    typedef typename list16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, na, na, na
        >
    : list17<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16
        >
{
    typedef typename list17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, na, na
        >
    : list18<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17
        >
{
    typedef typename list18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >::type type;
};

template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct list<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, na
        >
    : list19<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18
        >
{
    typedef typename list19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >::type type;
};



template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct list
    : list20<
          T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        , T15, T16, T17, T18, T19
        >
{
    typedef typename list20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >::type type;
};

}}
# 38 "/usr/include/boost/mpl/aux_/include_preprocessed.hpp" 2 3 4
# 47 "/usr/include/boost/mpl/list.hpp" 2 3 4
# 32 "/usr/include/cocaine/channel.hpp" 2 3 4


namespace cocaine { namespace io {

namespace mpl = boost::mpl;

template<class Tag>
struct protocol;

namespace detail {
    template<
        class Event,
        class Protocol = typename protocol<
            typename Event::tag
        >::type
    >
    struct enumerate:
        public mpl::distance<
            typename mpl::begin<Protocol>::type,
            typename mpl::find<Protocol, Event>::type
        >::type
    {
        static_assert(
            mpl::contains<Protocol, Event>::value,
            "event has not been registered with its protocol"
        );
    };

    template<class T>
    struct depend {
        typedef void type;
    };

    template<class Event, class U = void>
    struct tuple_type {
        typedef mpl::list<> type;
    };

    template<class Event>
    struct tuple_type<
        Event,
        typename depend<typename Event::tuple_type>::type
    >
    {
        typedef typename Event::tuple_type type;
    };
}

template<class Event>
struct event_traits {
    typedef typename detail::tuple_type<
        Event
    >::type tuple_type;

    enum constants {
        id = detail::enumerate<Event>::value,
        length = mpl::size<tuple_type>::value,
        empty = length == 0
    };
};

template<class SharingPolicy>
class channel:
    public socket<SharingPolicy>
{
    public:
        channel(context_t& context, int type):
            socket<SharingPolicy>(context, type)
        { }

        template<class T>
        channel(context_t& context, int type, const T& identity):
            socket<SharingPolicy>(context, type)
        {
            msgpack::sbuffer buffer;
            msgpack::packer<msgpack::sbuffer> packer(buffer);



            type_traits<T>::pack(packer, identity);

            this->setsockopt(5, buffer.data(), buffer.size());
        }

        using socket<SharingPolicy>::send;
        using socket<SharingPolicy>::recv;



        template<class Event, typename... Args>
        typename boost::disable_if_c<
            event_traits<Event>::empty,
            bool
        >::type
        send(Args&&... args) {
            msgpack::sbuffer buffer;

            type_traits<
                typename event_traits<Event>::tuple_type
            >::pack(buffer, std::forward<Args>(args)...);

            zmq::message_t message(buffer.size());

            std::memcpy(
                message.data(),
                buffer.data(),
                buffer.size()
            );

            return this->send_multipart(
                static_cast<int>(event_traits<Event>::id),
                message
            );
        }

        template<class Event>
        typename boost::enable_if_c<
            event_traits<Event>::empty,
            bool
        >::type
        send() {
            return this->send(
                static_cast<int>(event_traits<Event>::id)
            );
        }

        template<class Event, typename... Args>
        typename boost::disable_if_c<
            event_traits<Event>::empty,
            bool
        >::type
        recv(Args&&... args) {
            zmq::message_t message;
            msgpack::unpacked unpacked;

            if(!this->recv(message)) {
                return false;
            }

            try {
                msgpack::unpack(
                    &unpacked,
                    static_cast<const char*>(message.data()),
                    message.size()
                );
            } catch(const msgpack::unpack_error& e) {
                throw cocaine::error_t("corrupted object");
            }

            try {
                type_traits<
                    typename event_traits<Event>::tuple_type
                >::unpack(unpacked.get(), std::forward<Args>(args)...);
            } catch(const msgpack::type_error& e) {
                throw cocaine::error_t("corrupted object");
            } catch(const std::bad_cast& e) {
                throw cocaine::error_t("corrupted object - type mismatch");
            }

            return true;
        }



        bool
        send_message(int message_id,
                     const std::string& message)
        {
            return this->send(message_id, message.size() ? 2 : 0) &&
                   (!message.size() || this->send(protect(message)));
        }
};

}}
# 25 "/usr/include/cocaine/rpc.hpp" 2 3 4

namespace cocaine { namespace io {

namespace tags {
    struct rpc_tag;
    struct control_tag;
}

namespace rpc {
    struct heartbeat {
        typedef tags::rpc_tag tag;
    };

    struct suicide {
        typedef tags::rpc_tag tag;

        enum reasons: int {
            normal,
            abnormal
        };

        typedef boost::mpl::list<
            int,
            std::string
        > tuple_type;
    };

    struct terminate {
        typedef tags::rpc_tag tag;
    };

    struct invoke {
        typedef tags::rpc_tag tag;

        typedef boost::mpl::list<
            unique_id_t,
            std::string
        > tuple_type;
    };

    struct chunk {
        typedef tags::rpc_tag tag;

        typedef boost::mpl::list<
            unique_id_t,
            std::string
        > tuple_type;
    };

    struct error {
        typedef tags::rpc_tag tag;

        typedef boost::mpl::list<
            unique_id_t,
            int,
            std::string
        > tuple_type;
    };

    struct choke {
        typedef tags::rpc_tag tag;

        typedef boost::mpl::list<
            unique_id_t
        > tuple_type;
    };
}

namespace control {
    struct status {
        typedef tags::control_tag tag;
    };

    struct terminate {
        typedef tags::control_tag tag;
    };
}

template<>
struct protocol<tags::rpc_tag> {
    typedef boost::mpl::list<
        rpc::heartbeat,
        rpc::suicide,
        rpc::terminate,
        rpc::invoke,
        rpc::chunk,
        rpc::error,
        rpc::choke
    >::type type;
};

template<>
struct protocol<tags::control_tag> {
    typedef boost::mpl::list<
        control::status,
        control::terminate
    >::type type;
};

}}
# 7 "../src/worker.hpp" 2
# 1 "/usr/include/cocaine/unique_id.hpp" 1 3 4
# 26 "/usr/include/cocaine/unique_id.hpp" 3 4
# 1 "/usr/include/boost/functional/hash.hpp" 1 3 4





# 1 "/usr/include/boost/functional/hash/hash.hpp" 1 3 4
# 7 "/usr/include/boost/functional/hash.hpp" 2 3 4
# 27 "/usr/include/cocaine/unique_id.hpp" 2 3 4

# 1 "/usr/include/uuid/uuid.h" 1 3 4
# 44 "/usr/include/uuid/uuid.h" 3 4
typedef unsigned char uuid_t[16];
# 66 "/usr/include/uuid/uuid.h" 3 4
extern "C" {



void uuid_clear(uuid_t uu);


int uuid_compare(const uuid_t uu1, const uuid_t uu2);


void uuid_copy(uuid_t dst, const uuid_t src);


void uuid_generate(uuid_t out);
void uuid_generate_random(uuid_t out);
void uuid_generate_time(uuid_t out);


int uuid_is_null(const uuid_t uu);


int uuid_parse(const char *in, uuid_t uu);


void uuid_unparse(const uuid_t uu, char *out);
void uuid_unparse_lower(const uuid_t uu, char *out);
void uuid_unparse_upper(const uuid_t uu, char *out);


time_t uuid_time(const uuid_t uu, struct timeval *ret_tv);
int uuid_type(const uuid_t uu);
int uuid_variant(const uuid_t uu);


}
# 29 "/usr/include/cocaine/unique_id.hpp" 2 3 4

namespace cocaine {

namespace detail {
    struct uninitialized_t { };
}

static
const detail::uninitialized_t
uninitialized = detail::uninitialized_t();

struct unique_id_t {
    unique_id_t() {
        uuid_generate(reinterpret_cast<unsigned char*>(uuid));
    }

    explicit
    unique_id_t(detail::uninitialized_t) {


    }

    explicit
    unique_id_t(const std::string& other) {
        int rv = uuid_parse(
            other.c_str(),
            reinterpret_cast<unsigned char*>(uuid)
        );

        if(rv != 0) {
            throw cocaine::error_t("unable to parse '%s' as an unique id", other);
        }
    }

    std::string
    string() const {

        char unparsed[37];

        uuid_unparse_lower(
            reinterpret_cast<const unsigned char*>(uuid),
            unparsed
        );

        return unparsed;
    }

    bool
    operator == (const unique_id_t& other) const {
        return uuid[0] == other.uuid[0] &&
               uuid[1] == other.uuid[1];
    }

    friend
    std::ostream&
    operator << (std::ostream& stream,
                 const unique_id_t& id)
    {
        stream << id.string();
        return stream;
    }

public:

    uint64_t uuid[2];
};

static inline
size_t
hash_value(const unique_id_t& id) {
    return boost::hash_range(&id.uuid[0], &id.uuid[1]);
}

}
# 8 "../src/worker.hpp" 2
# 1 "/usr/include/cocaine/asio.hpp" 1 3 4
# 30 "/usr/include/cocaine/asio.hpp" 3 4
# 1 "/usr/include/ev++.h" 1 3 4
# 46 "/usr/include/ev++.h" 3 4
# 1 "/usr/include/ev.h" 1 3 4
# 44 "/usr/include/ev.h" 3 4
extern "C" {


typedef double ev_tstamp;
# 90 "/usr/include/ev.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 104 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;

# 58 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4
# 79 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 80 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();







extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
# 113 "/usr/include/signal.h" 3 4





extern __sighandler_t bsd_signal (int __sig, __sighandler_t __handler)
     throw ();






extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();




extern int raise (int __sig) throw ();




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, __const char *__s);




extern void psiginfo (__const siginfo_t *__pinfo, __const char *__s);
# 168 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 177 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 196 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
# 211 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (__const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, __const sigset_t *__left,
        __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, __const sigset_t *__left,
       __const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 253 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     throw ();
# 310 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 334 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) throw ();



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 26 "/usr/include/bits/sigcontext.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/sigcontext.h" 2 3 4

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 109 "/usr/include/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  unsigned long r8;
  unsigned long r9;
  unsigned long r10;
  unsigned long r11;
  unsigned long r12;
  unsigned long r13;
  unsigned long r14;
  unsigned long r15;
  unsigned long rdi;
  unsigned long rsi;
  unsigned long rbp;
  unsigned long rbx;
  unsigned long rdx;
  unsigned long rax;
  unsigned long rcx;
  unsigned long rsp;
  unsigned long rip;
  unsigned long eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  unsigned long err;
  unsigned long trapno;
  unsigned long oldmask;
  unsigned long cr2;
  struct _fpstate * fpstate;
  unsigned long __reserved1 [8];
};
# 340 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 350 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 357 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 24 "/usr/include/sys/ucontext.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 25 "/usr/include/sys/ucontext.h" 2 3 4
# 33 "/usr/include/sys/ucontext.h" 3 4
typedef long int greg_t;





typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    unsigned long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 360 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) throw ();







extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();






# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) throw ();
# 396 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();



}
# 91 "/usr/include/ev.h" 2 3 4
# 101 "/usr/include/ev.h" 3 4
# 1 "/usr/include/sys/stat.h" 1 3 4
# 105 "/usr/include/sys/stat.h" 3 4
extern "C" {

# 1 "/usr/include/bits/stat.h" 1 3 4
# 43 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 88 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 103 "/usr/include/bits/stat.h" 3 4
    long int __unused[3];
# 112 "/usr/include/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/bits/stat.h" 3 4
    long int __unused[3];



  };
# 108 "/usr/include/sys/stat.h" 2 3 4
# 217 "/usr/include/sys/stat.h" 3 4
extern int stat (__const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "stat64")

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) throw () __asm__ ("" "fstat64")
     __attribute__ ((__nonnull__ (2)));






extern int stat64 (__const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));
# 243 "/usr/include/sys/stat.h" 3 4
extern int fstatat (int __fd, __const char *__restrict __file, struct stat *__restrict __buf, int __flag) throw () __asm__ ("" "fstatat64") __attribute__ ((__nonnull__ (2, 3)));
# 253 "/usr/include/sys/stat.h" 3 4
extern int fstatat64 (int __fd, __const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 267 "/usr/include/sys/stat.h" 3 4
extern int lstat (__const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "lstat64")


     __attribute__ ((__nonnull__ (1, 2)));





extern int lstat64 (__const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (__const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (__const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, __const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (__const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (__const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, __const char *__path,
        __const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, __const struct timespec __times[2]) throw ();
# 410 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) throw () __asm__ ("" "__fxstat64")

     __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, __const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__xstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, __const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__lxstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, __const char *__filename, struct stat *__stat_buf, int __flag) throw () __asm__ ("" "__fxstatat64") __attribute__ ((__nonnull__ (3, 4)));
# 432 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, __const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, __const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, __const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, __const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));
# 534 "/usr/include/sys/stat.h" 3 4
}
# 102 "/usr/include/ev.h" 2 3 4




struct ev_loop;
# 215 "/usr/include/ev.h" 3 4
typedef struct ev_watcher
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_watcher *w, int revents);
} ev_watcher;


typedef struct ev_watcher_list
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_watcher_list *w, int revents); struct ev_watcher_list *next;
} ev_watcher_list;


typedef struct ev_watcher_time
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_watcher_time *w, int revents); ev_tstamp at;
} ev_watcher_time;



typedef struct ev_io
{
  int active;
  int pending;
  int priority;
  void *data;
  void (*cb)(struct ev_loop *loop, struct ev_io *w, int revents);
  struct ev_watcher_list *next;

  int fd;
  int events;
} ev_io;



typedef struct ev_timer
{
  int active;
  int pending;
  int priority;
  void *data;
  void (*cb)(struct ev_loop *loop, struct ev_timer *w, int revents);
  ev_tstamp at;
  ev_tstamp repeat;
} ev_timer;



typedef struct ev_periodic
{
  int active;
  int pending;
  int priority;
  void *data;
  void (*cb)(struct ev_loop *loop, struct ev_periodic *w, int revents);
  ev_tstamp at;

  ev_tstamp offset;
  ev_tstamp interval;
  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now);
} ev_periodic0;



typedef struct ev_signal
{
  int active;
  int pending;
  int priority;
  void *data;
  void (*cb)(struct ev_loop *loop, struct ev_signal *w, int revents);
  struct ev_watcher_list *next;

  int signum;
} ev_signal;




typedef struct ev_child
{
  int active;
  int pending;
  int priority;
  void *data;
  void (*cb)(struct ev_loop *loop, struct ev_child *w, int revents);
  struct ev_watcher_list *next;

  int flags;
  int pid;
  int rpid;
  int rstatus;
} ev_child;






typedef struct stat ev_statdata;




typedef struct ev_stat
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_stat *w, int revents); struct ev_watcher_list *next;

  ev_timer timer;
  ev_tstamp interval;
  const char *path;
  ev_statdata prev;
  ev_statdata attr;

  int wd;
} ev_stat;





typedef struct ev_idle
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_idle *w, int revents);
} ev_idle;





typedef struct ev_prepare
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_prepare *w, int revents);
} ev_prepare;



typedef struct ev_check
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_check *w, int revents);
} ev_check;



typedef struct ev_fork
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_fork *w, int revents);
} ev_fork;





typedef struct ev_embed
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_embed *w, int revents);

  struct ev_loop *other;
  ev_io io;
  ev_prepare prepare;
  ev_check check;
  ev_timer timer;
  ev_periodic periodic;
  ev_idle idle;
  ev_fork fork;
} ev_embed;





typedef struct ev_async
{
  int active; int pending; int priority; void *data; void (*cb)(struct ev_loop *loop, struct ev_async *w, int revents);

  sig_atomic_t volatile sent;
} ev_async;





union ev_any_watcher
{
  struct ev_watcher w;
  struct ev_watcher_list wl;

  struct ev_io io;
  struct ev_timer timer;
  struct ev_periodic periodic;
  struct ev_signal signal;
  struct ev_child child;

  struct ev_stat stat;


  struct ev_idle idle;

  struct ev_prepare prepare;
  struct ev_check check;

  struct ev_fork fork;


  struct ev_embed embed;


  struct ev_async async;

};
# 419 "/usr/include/ev.h" 3 4
int ev_version_major (void);
int ev_version_minor (void);

unsigned int ev_supported_backends (void);
unsigned int ev_recommended_backends (void);
unsigned int ev_embeddable_backends (void);

ev_tstamp ev_time (void);
void ev_sleep (ev_tstamp delay);







void ev_set_allocator (void *(*cb)(void *ptr, long size));





void ev_set_syserr_cb (void (*cb)(const char *msg));


static inline struct ev_loop *
ev_default_loop_uc (void)
{
  extern struct ev_loop *ev_default_loop_ptr;

  return ev_default_loop_ptr;
}



static inline struct ev_loop *
ev_default_loop (unsigned int flags)
{
  struct ev_loop *loop = ev_default_loop_uc ();

  if (!loop)
    {
      extern struct ev_loop *ev_default_loop_init (unsigned int flags);

      loop = ev_default_loop_init (flags);
    }

  return loop;
}


struct ev_loop *ev_loop_new (unsigned int flags);
void ev_loop_destroy (struct ev_loop *loop);
void ev_loop_fork (struct ev_loop *loop);

ev_tstamp ev_now (struct ev_loop *loop);
# 489 "/usr/include/ev.h" 3 4
static inline int
ev_is_default_loop (struct ev_loop *loop)
{

  extern struct ev_loop *ev_default_loop_ptr;

  return !!(loop == ev_default_loop_ptr);



}

void ev_default_destroy (void);




void ev_default_fork (void);

unsigned int ev_backend (struct ev_loop *loop);

void ev_now_update (struct ev_loop *loop);
# 528 "/usr/include/ev.h" 3 4
void ev_loop (struct ev_loop *loop, int flags);
void ev_unloop (struct ev_loop *loop, int how);






void ev_ref (struct ev_loop *loop);
void ev_unref (struct ev_loop *loop);





void ev_once (struct ev_loop *loop, int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg);


unsigned int ev_loop_count (struct ev_loop *loop);
unsigned int ev_loop_depth (struct ev_loop *loop);
void ev_loop_verify (struct ev_loop *loop);

void ev_set_io_collect_interval (struct ev_loop *loop, ev_tstamp interval);
void ev_set_timeout_collect_interval (struct ev_loop *loop, ev_tstamp interval);


void ev_set_userdata (struct ev_loop *loop, void *data);
void *ev_userdata (struct ev_loop *loop);
void ev_set_invoke_pending_cb (struct ev_loop *loop, void (*invoke_pending_cb)(struct ev_loop *loop));
void ev_set_loop_release_cb (struct ev_loop *loop, void (*release)(struct ev_loop *loop), void (*acquire)(struct ev_loop *loop));

unsigned int ev_pending_count (struct ev_loop *loop);
void ev_invoke_pending (struct ev_loop *loop);




void ev_suspend (struct ev_loop *loop);
void ev_resume (struct ev_loop *loop);
# 631 "/usr/include/ev.h" 3 4
void ev_feed_event (struct ev_loop *loop, void *w, int revents);
void ev_feed_fd_event (struct ev_loop *loop, int fd, int revents);
void ev_feed_signal_event (struct ev_loop *loop, int signum);
void ev_invoke (struct ev_loop *loop, void *w, int revents);
int ev_clear_pending (struct ev_loop *loop, void *w);

void ev_io_start (struct ev_loop *loop, ev_io *w);
void ev_io_stop (struct ev_loop *loop, ev_io *w);

void ev_timer_start (struct ev_loop *loop, ev_timer *w);
void ev_timer_stop (struct ev_loop *loop, ev_timer *w);

void ev_timer_again (struct ev_loop *loop, ev_timer *w);

ev_tstamp ev_timer_remaining (struct ev_loop *loop, ev_timer *w);


void ev_periodic_start (struct ev_loop *loop, ev_periodic *w);
void ev_periodic_stop (struct ev_loop *loop, ev_periodic *w);
void ev_periodic_again (struct ev_loop *loop, ev_periodic *w);



void ev_signal_start (struct ev_loop *loop, ev_signal *w);
void ev_signal_stop (struct ev_loop *loop, ev_signal *w);


void ev_child_start (struct ev_loop *loop, ev_child *w);
void ev_child_stop (struct ev_loop *loop, ev_child *w);


void ev_stat_start (struct ev_loop *loop, ev_stat *w);
void ev_stat_stop (struct ev_loop *loop, ev_stat *w);
void ev_stat_stat (struct ev_loop *loop, ev_stat *w);



void ev_idle_start (struct ev_loop *loop, ev_idle *w);
void ev_idle_stop (struct ev_loop *loop, ev_idle *w);


void ev_prepare_start (struct ev_loop *loop, ev_prepare *w);
void ev_prepare_stop (struct ev_loop *loop, ev_prepare *w);

void ev_check_start (struct ev_loop *loop, ev_check *w);
void ev_check_stop (struct ev_loop *loop, ev_check *w);


void ev_fork_start (struct ev_loop *loop, ev_fork *w);
void ev_fork_stop (struct ev_loop *loop, ev_fork *w);




void ev_embed_start (struct ev_loop *loop, ev_embed *w);
void ev_embed_stop (struct ev_loop *loop, ev_embed *w);
void ev_embed_sweep (struct ev_loop *loop, ev_embed *w);



void ev_async_start (struct ev_loop *loop, ev_async *w);
void ev_async_stop (struct ev_loop *loop, ev_async *w);
void ev_async_send (struct ev_loop *loop, ev_async *w);





}
# 47 "/usr/include/ev++.h" 2 3 4
# 57 "/usr/include/ev++.h" 3 4
namespace ev {

  typedef ev_tstamp tstamp;

  enum
  {
    UNDEF = -1,
    NONE = 0x00,
    READ = 0x01,
    WRITE = 0x02,
    TIMEOUT = 0x00000100,
    PERIODIC = 0x00000200,
    SIGNAL = 0x00000400,
    CHILD = 0x00000800,
    STAT = 0x00001000,
    IDLE = 0x00002000,
    CHECK = 0x00008000,
    PREPARE = 0x00004000,
    FORK = 0x00020000,
    ASYNC = 0x00040000,
    EMBED = 0x00010000,

    ERROR = 0x80000000,
  };

  enum
  {
    AUTO = 0x00000000U,
    NOENV = 0x01000000U,
    FORKCHECK = 0x02000000U,

    SELECT = 0x00000001U,
    POLL = 0x00000002U,
    EPOLL = 0x00000004U,
    KQUEUE = 0x00000008U,
    DEVPOLL = 0x00000010U,
    PORT = 0x00000020U
  };

  enum
  {
    NONBLOCK = 1,
    ONESHOT = 2
  };

  enum how_t
  {
    ONE = 1,
    ALL = 2
  };

  struct bad_loop

  : std::runtime_error

  {

    bad_loop ()
    : std::runtime_error ("libev event loop cannot be initialized, bad value of LIBEV_FLAGS?")
    {
    }

  };
# 137 "/usr/include/ev++.h" 3 4
  struct loop_ref
  {
    loop_ref (struct ev_loop *loop) throw ()

    : raw_loop (loop)

    {
    }

    bool operator == (const loop_ref &other) const throw ()
    {

      return raw_loop == other.raw_loop;



    }

    bool operator != (const loop_ref &other) const throw ()
    {

      return ! (*this == other);



    }


    bool operator == (const struct ev_loop *loop) const throw ()
    {
      return this->raw_loop == loop;
    }

    bool operator != (const struct ev_loop *loop) const throw ()
    {
      return (*this == loop);
    }

    operator struct ev_loop * () const throw ()
    {
      return raw_loop;
    }

    operator const struct ev_loop * () const throw ()
    {
      return raw_loop;
    }

    bool is_default () const throw ()
    {
      return raw_loop == ev_default_loop (0);
    }


    void loop (int flags = 0)
    {
      ev_loop (raw_loop, flags);
    }

    void unloop (how_t how = ONE) throw ()
    {
      ev_unloop (raw_loop, how);
    }

    void post_fork () throw ()
    {

      ev_loop_fork (raw_loop);



    }

    unsigned int backend () const throw ()
    {
      return ev_backend (raw_loop);
    }

    tstamp now () const throw ()
    {
      return ev_now (raw_loop);
    }

    void ref () throw ()
    {
      ev_ref (raw_loop);
    }

    void unref () throw ()
    {
      ev_unref (raw_loop);
    }


    unsigned int count () const throw ()
    {
      return ev_loop_count (raw_loop);
    }

    unsigned int depth () const throw ()
    {
      return ev_loop_depth (raw_loop);
    }

    void set_io_collect_interval (tstamp interval) throw ()
    {
      ev_set_io_collect_interval (raw_loop, interval);
    }

    void set_timeout_collect_interval (tstamp interval) throw ()
    {
      ev_set_timeout_collect_interval (raw_loop, interval);
    }



    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) throw ()
    {
      ev_once (raw_loop, fd, events, timeout, cb, arg);
    }


    template<class K, void (K::*method)(int)>
    void once (int fd, int events, tstamp timeout, K *object) throw ()
    {
      once (fd, events, timeout, method_thunk<K, method>, object);
    }


    template<class K>
    void once (int fd, int events, tstamp timeout, K *object) throw ()
    {
      once (fd, events, timeout, method_thunk<K, &K::operator ()>, object);
    }

    template<class K, void (K::*method)(int)>
    static void method_thunk (int revents, void *arg)
    {
      static_cast<K *>(arg)->*method
        (revents);
    }


    template<class K, void (K::*method)()>
    void once (int fd, int events, tstamp timeout, K *object) throw ()
    {
      once (fd, events, timeout, method_noargs_thunk<K, method>, object);
    }

    template<class K, void (K::*method)()>
    static void method_noargs_thunk (int revents, void *arg)
    {
      static_cast<K *>(arg)->*method
        ();
    }


    template<void (*cb)(int)>
    void once (int fd, int events, tstamp timeout) throw ()
    {
      once (fd, events, timeout, simpler_func_thunk<cb>);
    }

    template<void (*cb)(int)>
    static void simpler_func_thunk (int revents, void *arg)
    {
      (*cb)
        (revents);
    }


    template<void (*cb)()>
    void once (int fd, int events, tstamp timeout) throw ()
    {
      once (fd, events, timeout, simplest_func_thunk<cb>);
    }

    template<void (*cb)()>
    static void simplest_func_thunk (int revents, void *arg)
    {
      (*cb)
        ();
    }

    void feed_fd_event (int fd, int revents) throw ()
    {
      ev_feed_fd_event (raw_loop, fd, revents);
    }

    void feed_signal_event (int signum) throw ()
    {
      ev_feed_signal_event (raw_loop, signum);
    }


    struct ev_loop* raw_loop;


  };


  struct dynamic_loop : loop_ref
  {

    dynamic_loop (unsigned int flags = AUTO) throw (bad_loop)
    : loop_ref (ev_loop_new (flags))
    {
      if (!raw_loop)
        throw bad_loop ();
    }

    ~dynamic_loop () throw ()
    {
      ev_loop_destroy (raw_loop);
      raw_loop = 0;
    }

  private:

    dynamic_loop (const dynamic_loop &);

    dynamic_loop & operator= (const dynamic_loop &);

  };


  struct default_loop : loop_ref
  {
    default_loop (unsigned int flags = AUTO) throw (bad_loop)

    : loop_ref (ev_default_loop (flags))

    {
      if (

          !raw_loop



      )
        throw bad_loop ();
    }

    ~default_loop () throw ()
    {
      ev_default_destroy ();
    }

  private:
    default_loop (const default_loop &);
    default_loop &operator = (const default_loop &);
  };

  inline loop_ref get_default_loop () throw ()
  {

    return ev_default_loop (0);



  }
# 412 "/usr/include/ev++.h" 3 4
  template<class ev_watcher, class watcher>
  struct base : ev_watcher
  {

      loop_ref loop;

      void set (struct ev_loop *loop) throw ()
      {
        this->loop = loop;
      }


    base (loop_ref loop) throw ()

      : loop (loop)

    {
      do { ((ev_watcher *)(void *)(this))->active = ((ev_watcher *)(void *)(this))->pending = 0; ( (ev_watcher *)(void *)((this)))->priority = (0); ((this))->cb = (0); } while (0);
    }

    void set_ (const void *data, void (*cb)(struct ev_loop *loop, ev_watcher *w, int revents)) throw ()
    {
      this->data = (void *)data;
      (static_cast<ev_watcher *>(this))->cb = (cb);
    }


    template<void (*function)(watcher &w, int)>
    void set (void *data = 0) throw ()
    {
      set_ (data, function_thunk<function>);
    }

    template<void (*function)(watcher &w, int)>
    static void function_thunk (struct ev_loop *loop, ev_watcher *w, int revents)
    {
      function
        (*static_cast<watcher *>(w), revents);
    }


    template<class K, void (K::*method)(watcher &w, int)>
    void set (K *object) throw ()
    {
      set_ (object, method_thunk<K, method>);
    }


    template<class K>
    void set (K *object) throw ()
    {
      set_ (object, method_thunk<K, &K::operator ()>);
    }

    template<class K, void (K::*method)(watcher &w, int)>
    static void method_thunk (struct ev_loop *loop, ev_watcher *w, int revents)
    {
      (static_cast<K *>(w->data)->*method)
        (*static_cast<watcher *>(w), revents);
    }


    template<class K, void (K::*method)()>
    void set (K *object) throw ()
    {
      set_ (object, method_noargs_thunk<K, method>);
    }

    template<class K, void (K::*method)()>
    static void method_noargs_thunk (struct ev_loop *loop, ev_watcher *w, int revents)
    {
      static_cast<K *>(w->data)->*method
        ();
    }

    void operator ()(int events = -1)
    {
      return
        (static_cast<ev_watcher *>(this))->cb
          (static_cast<ev_watcher *>(this), events);
    }

    bool is_active () const throw ()
    {
      return (0 + ((ev_watcher *)(void *)(static_cast<const ev_watcher *>(this)))->active);
    }

    bool is_pending () const throw ()
    {
      return (0 + ((ev_watcher *)(void *)(static_cast<const ev_watcher *>(this)))->pending);
    }

    void feed_event (int revents) throw ()
    {
      ev_feed_event (loop, static_cast<const ev_watcher *>(this), revents);
    }
  };

  inline tstamp now () throw ()
  {
    return ev_time ();
  }

  inline void delay (tstamp interval) throw ()
  {
    ev_sleep (interval);
  }

  inline int version_major () throw ()
  {
    return ev_version_major ();
  }

  inline int version_minor () throw ()
  {
    return ev_version_minor ();
  }

  inline unsigned int supported_backends () throw ()
  {
    return ev_supported_backends ();
  }

  inline unsigned int recommended_backends () throw ()
  {
    return ev_recommended_backends ();
  }

  inline unsigned int embeddable_backends () throw ()
  {
    return ev_embeddable_backends ();
  }

  inline void set_allocator (void *(*cb)(void *ptr, long size)) throw ()
  {
    ev_set_allocator (cb);
  }

  inline void set_syserr_cb (void (*cb)(const char *msg)) throw ()
  {
    ev_set_syserr_cb (cb);
  }
# 604 "/usr/include/ev++.h" 3 4
  struct io : base<ev_io, io> { void start () throw () { ev_io_start (loop, static_cast<ev_io *>(this)); } void stop () throw () { ev_io_stop (loop, static_cast<ev_io *>(this)); } io (loop_ref loop = get_default_loop ()) throw () : base<ev_io, io> (loop) { } ~io () throw () { stop (); } using base<ev_io, io>::set; private: io (const io &o); io &operator =(const io &o); public:
    void set (int fd, int events) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { (static_cast<ev_io *>(this))->fd = (fd); (static_cast<ev_io *>(this))->events = (events) | 0x80; } while (0);
      if (active) start ();
    }

    void set (int events) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { (static_cast<ev_io *>(this))->fd = (fd); (static_cast<ev_io *>(this))->events = (events) | 0x80; } while (0);
      if (active) start ();
    }

    void start (int fd, int events) throw ()
    {
      set (fd, events);
      start ();
    }
  };

  struct timer : base<ev_timer, timer> { void start () throw () { ev_timer_start (loop, static_cast<ev_timer *>(this)); } void stop () throw () { ev_timer_stop (loop, static_cast<ev_timer *>(this)); } timer (loop_ref loop = get_default_loop ()) throw () : base<ev_timer, timer> (loop) { } ~timer () throw () { stop (); } using base<ev_timer, timer>::set; private: timer (const timer &o); timer &operator =(const timer &o); public:
    void set (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { ((ev_watcher_time *)(static_cast<ev_timer *>(this)))->at = (after); (static_cast<ev_timer *>(this))->repeat = (repeat); } while (0);
      if (active) start ();
    }

    void start (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
    {
      set (after, repeat);
      start ();
    }

    void again () throw ()
    {
      ev_timer_again (loop, static_cast<ev_timer *>(this));
    }
  };


  struct periodic : base<ev_periodic, periodic> { void start () throw () { ev_periodic_start (loop, static_cast<ev_periodic *>(this)); } void stop () throw () { ev_periodic_stop (loop, static_cast<ev_periodic *>(this)); } periodic (loop_ref loop = get_default_loop ()) throw () : base<ev_periodic, periodic> (loop) { } ~periodic () throw () { stop (); } using base<ev_periodic, periodic>::set; private: periodic (const periodic &o); periodic &operator =(const periodic &o); public:
    void set (ev_tstamp at, ev_tstamp interval = 0.) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { (static_cast<ev_periodic *>(this))->offset = (at); (static_cast<ev_periodic *>(this))->interval = (interval); (static_cast<ev_periodic *>(this))->reschedule_cb = (0); } while (0);
      if (active) start ();
    }

    void start (ev_tstamp at, ev_tstamp interval = 0.) throw ()
    {
      set (at, interval);
      start ();
    }

    void again () throw ()
    {
      ev_periodic_again (loop, static_cast<ev_periodic *>(this));
    }
  };


  struct sig : base<ev_signal, sig> { void start () throw () { ev_signal_start (loop, static_cast<ev_signal *>(this)); } void stop () throw () { ev_signal_stop (loop, static_cast<ev_signal *>(this)); } sig (loop_ref loop = get_default_loop ()) throw () : base<ev_signal, sig> (loop) { } ~sig () throw () { stop (); } using base<ev_signal, sig>::set; private: sig (const sig &o); sig &operator =(const sig &o); public:
    void set (int signum) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { (static_cast<ev_signal *>(this))->signum = (signum); } while (0);
      if (active) start ();
    }

    void start (int signum) throw ()
    {
      set (signum);
      start ();
    }
  };

  struct child : base<ev_child, child> { void start () throw () { ev_child_start (loop, static_cast<ev_child *>(this)); } void stop () throw () { ev_child_stop (loop, static_cast<ev_child *>(this)); } child (loop_ref loop = get_default_loop ()) throw () : base<ev_child, child> (loop) { } ~child () throw () { stop (); } using base<ev_child, child>::set; private: child (const child &o); child &operator =(const child &o); public:
    void set (int pid, int trace = 0) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { (static_cast<ev_child *>(this))->pid = (pid); (static_cast<ev_child *>(this))->flags = !!(trace); } while (0);
      if (active) start ();
    }

    void start (int pid, int trace = 0) throw ()
    {
      set (pid, trace);
      start ();
    }
  };


  struct stat : base<ev_stat, stat> { void start () throw () { ev_stat_start (loop, static_cast<ev_stat *>(this)); } void stop () throw () { ev_stat_stop (loop, static_cast<ev_stat *>(this)); } stat (loop_ref loop = get_default_loop ()) throw () : base<ev_stat, stat> (loop) { } ~stat () throw () { stop (); } using base<ev_stat, stat>::set; private: stat (const stat &o); stat &operator =(const stat &o); public:
    void set (const char *path, ev_tstamp interval = 0.) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { (static_cast<ev_stat *>(this))->path = (path); (static_cast<ev_stat *>(this))->interval = (interval); (static_cast<ev_stat *>(this))->wd = -2; } while (0);
      if (active) start ();
    }

    void start (const char *path, ev_tstamp interval = 0.) throw ()
    {
      stop ();
      set (path, interval);
      start ();
    }

    void update () throw ()
    {
      ev_stat_stat (loop, static_cast<ev_stat *>(this));
    }
  };


  struct idle : base<ev_idle, idle> { void start () throw () { ev_idle_start (loop, static_cast<ev_idle *>(this)); } void stop () throw () { ev_idle_stop (loop, static_cast<ev_idle *>(this)); } idle (loop_ref loop = get_default_loop ()) throw () : base<ev_idle, idle> (loop) { } ~idle () throw () { stop (); } using base<ev_idle, idle>::set; private: idle (const idle &o); idle &operator =(const idle &o); public:
    void set () throw () { }
  };

  struct prepare : base<ev_prepare, prepare> { void start () throw () { ev_prepare_start (loop, static_cast<ev_prepare *>(this)); } void stop () throw () { ev_prepare_stop (loop, static_cast<ev_prepare *>(this)); } prepare (loop_ref loop = get_default_loop ()) throw () : base<ev_prepare, prepare> (loop) { } ~prepare () throw () { stop (); } using base<ev_prepare, prepare>::set; private: prepare (const prepare &o); prepare &operator =(const prepare &o); public:
    void set () throw () { }
  };

  struct check : base<ev_check, check> { void start () throw () { ev_check_start (loop, static_cast<ev_check *>(this)); } void stop () throw () { ev_check_stop (loop, static_cast<ev_check *>(this)); } check (loop_ref loop = get_default_loop ()) throw () : base<ev_check, check> (loop) { } ~check () throw () { stop (); } using base<ev_check, check>::set; private: check (const check &o); check &operator =(const check &o); public:
    void set () throw () { }
  };


  struct embed : base<ev_embed, embed> { void start () throw () { ev_embed_start (loop, static_cast<ev_embed *>(this)); } void stop () throw () { ev_embed_stop (loop, static_cast<ev_embed *>(this)); } embed (loop_ref loop = get_default_loop ()) throw () : base<ev_embed, embed> (loop) { } ~embed () throw () { stop (); } using base<ev_embed, embed>::set; private: embed (const embed &o); embed &operator =(const embed &o); public:
    void set (struct ev_loop *embedded_loop) throw ()
    {
      int active = is_active ();
      if (active) stop ();
      do { (static_cast<ev_embed *>(this))->other = (embedded_loop); } while (0);
      if (active) start ();
    }

    void start (struct ev_loop *embedded_loop) throw ()
    {
      set (embedded_loop);
      start ();
    }

    void sweep ()
    {
      ev_embed_sweep (loop, static_cast<ev_embed *>(this));
    }
  };



  struct fork : base<ev_fork, fork> { void start () throw () { ev_fork_start (loop, static_cast<ev_fork *>(this)); } void stop () throw () { ev_fork_stop (loop, static_cast<ev_fork *>(this)); } fork (loop_ref loop = get_default_loop ()) throw () : base<ev_fork, fork> (loop) { } ~fork () throw () { stop (); } using base<ev_fork, fork>::set; private: fork (const fork &o); fork &operator =(const fork &o); public:
    void set () throw () { }
  };



  struct async : base<ev_async, async> { void start () throw () { ev_async_start (loop, static_cast<ev_async *>(this)); } void stop () throw () { ev_async_stop (loop, static_cast<ev_async *>(this)); } async (loop_ref loop = get_default_loop ()) throw () : base<ev_async, async> (loop) { } ~async () throw () { stop (); } using base<ev_async, async>::set; private: async (const async &o); async &operator =(const async &o); public:
    void set () throw () { }

    void send () throw ()
    {
      ev_async_send (loop, static_cast<ev_async *>(this));
    }

    bool async_pending () throw ()
    {
      return ((static_cast<ev_async *>(this))->sent + 0);
    }
  };







}
# 31 "/usr/include/cocaine/asio.hpp" 2 3 4
# 9 "../src/worker.hpp" 2

# 1 "/usr/include/cocaine/api/stream.hpp" 1 3 4
# 26 "/usr/include/cocaine/api/stream.hpp" 3 4
namespace cocaine { namespace api {

struct stream_t {
    virtual
    ~stream_t() {

    }

    virtual
    void
    push(const char * chunk,
         size_t size) = 0;

    virtual
    void
    error(error_code code,
          const std::string& message) = 0;

    virtual
    void
    close() = 0;
};

struct null_stream_t:
    public stream_t
{
    virtual
    void
    push(const char * chunk, size_t size) { }

    virtual
    void
    error(error_code code, const std::string& message) { }

    virtual
    void
    close() { }
};

}}
# 11 "../src/worker.hpp" 2

# 1 "/usr/include/nodejs/node.h" 1 3 4
# 61 "/usr/include/nodejs/node.h" 3 4
# 1 "/usr/include/nodejs/uv.h" 1 3 4
# 27 "/usr/include/nodejs/uv.h" 3 4
extern "C" {
# 58 "/usr/include/nodejs/uv.h" 3 4
# 1 "/usr/include/nodejs/ares.h" 1 3 4
# 21 "/usr/include/nodejs/ares.h" 3 4
# 1 "/usr/include/nodejs/ares_version.h" 1 3 4
# 22 "/usr/include/nodejs/ares.h" 2 3 4
# 74 "/usr/include/nodejs/ares.h" 3 4
typedef int ares_socklen_t;
# 118 "/usr/include/nodejs/ares.h" 3 4
extern "C" {
# 267 "/usr/include/nodejs/ares.h" 3 4
typedef int ares_socket_t;





typedef void (*ares_sock_state_cb)(void *data,
                                   ares_socket_t socket_fd,
                                   int readable,
                                   int writable);

struct apattern;
# 297 "/usr/include/nodejs/ares.h" 3 4
struct ares_options {
  int flags;
  int timeout;
  int tries;
  int ndots;
  unsigned short udp_port;
  unsigned short tcp_port;
  int socket_send_buffer_size;
  int socket_receive_buffer_size;
  struct in_addr *servers;
  int nservers;
  char **domains;
  int ndomains;
  char *lookups;
  ares_sock_state_cb sock_state_cb;
  void *sock_state_cb_data;
  struct apattern *sortlist;
  int nsort;
};

struct hostent;
struct timeval;
struct sockaddr;
struct ares_channeldata;

typedef struct ares_channeldata *ares_channel;

typedef void (*ares_callback)(void *arg,
                              int status,
                              int timeouts,
                              unsigned char *abuf,
                              int alen);

typedef void (*ares_host_callback)(void *arg,
                                   int status,
                                   int timeouts,
                                   struct hostent *hostent);

typedef void (*ares_nameinfo_callback)(void *arg,
                                       int status,
                                       int timeouts,
                                       char *node,
                                       char *service);

typedef int (*ares_sock_create_callback)(ares_socket_t socket_fd,
                                          int type,
                                          void *data);

 int ares_library_init(int flags);

 void ares_library_cleanup(void);

 const char *ares_version(int *version);

 int ares_init(ares_channel *channelptr);

 int ares_init_options(ares_channel *channelptr,
                                   struct ares_options *options,
                                   int optmask);

 int ares_save_options(ares_channel channel,
                                   struct ares_options *options,
                                   int *optmask);

 void ares_destroy_options(struct ares_options *options);

 int ares_dup(ares_channel *dest,
                          ares_channel src);

 void ares_destroy(ares_channel channel);

 void ares_cancel(ares_channel channel);





 void ares_set_local_ip4(ares_channel channel, unsigned int local_ip);


 void ares_set_local_ip6(ares_channel channel,
                                     const unsigned char* local_ip6);


 void ares_set_local_dev(ares_channel channel,
                                     const char* local_dev_name);

 void ares_set_socket_callback(ares_channel channel,
                                           ares_sock_create_callback callback,
                                           void *user_data);

 void ares_send(ares_channel channel,
                            const unsigned char *qbuf,
                            int qlen,
                            ares_callback callback,
                            void *arg);

 void ares_query(ares_channel channel,
                             const char *name,
                             int dnsclass,
                             int type,
                             ares_callback callback,
                             void *arg);

 void ares_search(ares_channel channel,
                              const char *name,
                              int dnsclass,
                              int type,
                              ares_callback callback,
                              void *arg);

 void ares_gethostbyname(ares_channel channel,
                                     const char *name,
                                     int family,
                                     ares_host_callback callback,
                                     void *arg);

 int ares_gethostbyname_file(ares_channel channel,
                                         const char *name,
                                         int family,
                                         struct hostent **host);

 void ares_gethostbyaddr(ares_channel channel,
                                     const void *addr,
                                     int addrlen,
                                     int family,
                                     ares_host_callback callback,
                                     void *arg);

 void ares_getnameinfo(ares_channel channel,
                                   const struct sockaddr *sa,
                                   ares_socklen_t salen,
                                   int flags,
                                   ares_nameinfo_callback callback,
                                   void *arg);

 int ares_fds(ares_channel channel,
                          fd_set *read_fds,
                          fd_set *write_fds);

 int ares_getsock(ares_channel channel,
                              ares_socket_t *socks,
                              int numsocks);

 struct timeval *ares_timeout(ares_channel channel,
                                          struct timeval *maxtv,
                                          struct timeval *tv);

 void ares_process(ares_channel channel,
                               fd_set *read_fds,
                               fd_set *write_fds);

 void ares_process_fd(ares_channel channel,
                                  ares_socket_t read_fd,
                                  ares_socket_t write_fd);

 int ares_mkquery(const char *name,
                              int dnsclass,
                              int type,
                              unsigned short id,
                              int rd,
                              unsigned char **buf,
                              int *buflen);

 int ares_expand_name(const unsigned char *encoded,
                                  const unsigned char *abuf,
                                  int alen,
                                  char **s,
                                  long *enclen);

 int ares_expand_string(const unsigned char *encoded,
                                    const unsigned char *abuf,
                                    int alen,
                                    unsigned char **s,
                                    long *enclen);
# 480 "/usr/include/nodejs/ares.h" 3 4
struct ares_in6_addr {
  union {
    unsigned char _S6_u8[16];
  } _S6_un;
};

struct ares_addrttl {
  struct in_addr ipaddr;
  int ttl;
};

struct ares_addr6ttl {
  struct ares_in6_addr ip6addr;
  int ttl;
};

struct ares_srv_reply {
  struct ares_srv_reply *next;
  char *host;
  unsigned short priority;
  unsigned short weight;
  unsigned short port;
};

struct ares_mx_reply {
  struct ares_mx_reply *next;
  char *host;
  unsigned short priority;
};

struct ares_txt_reply {
  struct ares_txt_reply *next;
  unsigned char *txt;
  size_t length;
};
# 524 "/usr/include/nodejs/ares.h" 3 4
 int ares_parse_a_reply(const unsigned char *abuf,
                                    int alen,
                                    struct hostent **host,
                                    struct ares_addrttl *addrttls,
                                    int *naddrttls);

 int ares_parse_aaaa_reply(const unsigned char *abuf,
                                       int alen,
                                       struct hostent **host,
                                       struct ares_addr6ttl *addrttls,
                                       int *naddrttls);

 int ares_parse_ptr_reply(const unsigned char *abuf,
                                      int alen,
                                      const void *addr,
                                      int addrlen,
                                      int family,
                                      struct hostent **host);

 int ares_parse_ns_reply(const unsigned char *abuf,
                                     int alen,
                                     struct hostent **host);

 int ares_parse_srv_reply(const unsigned char* abuf,
                                      int alen,
                                      struct ares_srv_reply** srv_out);

 int ares_parse_mx_reply(const unsigned char* abuf,
                                      int alen,
                                      struct ares_mx_reply** mx_out);

 int ares_parse_txt_reply(const unsigned char* abuf,
                                      int alen,
                                      struct ares_txt_reply** txt_out);

 void ares_free_string(void *str);

 void ares_free_hostent(struct hostent *host);

 void ares_free_data(void *dataptr);

 const char *ares_strerror(int code);


struct ares_addr_node {
  struct ares_addr_node *next;
  int family;
  union {
    struct in_addr addr4;
    struct ares_in6_addr addr6;
  } addr;
};

 int ares_set_servers(ares_channel channel,
                                  struct ares_addr_node *servers);


 int ares_set_servers_csv(ares_channel channel,
                                      const char* servers);

 int ares_get_servers(ares_channel channel,
                                  struct ares_addr_node **servers);


}
# 59 "/usr/include/nodejs/uv.h" 2 3 4


# 1 "/usr/include/nodejs/uv-private/uv-unix.h" 1 3 4
# 25 "/usr/include/nodejs/uv-private/uv-unix.h" 3 4
# 1 "/usr/include/nodejs/uv-private/ngx-queue.h" 1 3 4
# 11 "/usr/include/nodejs/uv-private/ngx-queue.h" 3 4
typedef struct ngx_queue_s ngx_queue_t;

struct ngx_queue_s {
    ngx_queue_t *prev;
    ngx_queue_t *next;
};
# 26 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4

# 1 "/usr/include/nodejs/uv-private/ev.h" 1 3 4
# 28 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4
# 1 "/usr/include/nodejs/uv-private/eio.h" 1 3 4
# 44 "/usr/include/nodejs/uv-private/eio.h" 3 4
extern "C" {


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 48 "/usr/include/nodejs/uv-private/eio.h" 2 3 4



typedef struct eio_req eio_req;
typedef struct eio_dirent eio_dirent;

typedef int (*eio_cb)(eio_req *req);
# 84 "/usr/include/nodejs/uv-private/eio.h" 3 4
  typedef uid_t eio_uid_t;
  typedef gid_t eio_gid_t;
  typedef ssize_t eio_ssize_t;
  typedef ino_t eio_ino_t;
  typedef mode_t eio_mode_t;
# 98 "/usr/include/nodejs/uv-private/eio.h" 3 4
enum
{
  EIO_READDIR_DENTS = 0x01,
  EIO_READDIR_DIRS_FIRST = 0x02,
  EIO_READDIR_STAT_ORDER = 0x04,
  EIO_READDIR_FOUND_UNKNOWN = 0x80,

  EIO_READDIR_CUSTOM1 = 0x100,
  EIO_READDIR_CUSTOM2 = 0x200
};


enum eio_dtype
{
  EIO_DT_UNKNOWN = 0,
  EIO_DT_FIFO = 1,
  EIO_DT_CHR = 2,
  EIO_DT_MPC = 3,
  EIO_DT_DIR = 4,
  EIO_DT_NAM = 5,
  EIO_DT_BLK = 6,
  EIO_DT_MPB = 7,
  EIO_DT_REG = 8,
  EIO_DT_NWK = 9,
  EIO_DT_CMP = 9,
  EIO_DT_LNK = 10,

  EIO_DT_SOCK = 12,
  EIO_DT_DOOR = 13,
  EIO_DT_WHT = 14,
  EIO_DT_MAX = 15
};

struct eio_dirent
{
  int nameofs;
  unsigned short namelen;
  unsigned char type;
  signed char score;
  eio_ino_t inode;
};


enum
{
  EIO_MS_ASYNC = 1,
  EIO_MS_INVALIDATE = 2,
  EIO_MS_SYNC = 4
};


enum
{
  EIO_MT_MODIFY = 1
};


enum
{
  EIO_SYNC_FILE_RANGE_WAIT_BEFORE = 1,
  EIO_SYNC_FILE_RANGE_WRITE = 2,
  EIO_SYNC_FILE_RANGE_WAIT_AFTER = 4
};


enum
{
  EIO_FALLOC_FL_KEEP_SIZE = 1
};


typedef double eio_tstamp;


enum
{
  EIO_CUSTOM,
  EIO_OPEN, EIO_CLOSE, EIO_DUP2,
  EIO_READ, EIO_WRITE,
  EIO_READAHEAD, EIO_SENDFILE,
  EIO_STAT, EIO_LSTAT, EIO_FSTAT,
  EIO_STATVFS, EIO_FSTATVFS,
  EIO_TRUNCATE, EIO_FTRUNCATE,
  EIO_UTIME, EIO_FUTIME,
  EIO_CHMOD, EIO_FCHMOD,
  EIO_CHOWN, EIO_FCHOWN,
  EIO_SYNC, EIO_FSYNC, EIO_FDATASYNC, EIO_SYNCFS,
  EIO_MSYNC, EIO_MTOUCH, EIO_SYNC_FILE_RANGE, EIO_FALLOCATE,
  EIO_MLOCK, EIO_MLOCKALL,
  EIO_UNLINK, EIO_RMDIR, EIO_MKDIR, EIO_RENAME,
  EIO_MKNOD, EIO_READDIR,
  EIO_LINK, EIO_SYMLINK, EIO_READLINK, EIO_REALPATH,
  EIO_GROUP, EIO_NOP,
  EIO_BUSY
};


enum
{
  EIO_MCL_CURRENT = 1,
  EIO_MCL_FUTURE = 2
};



enum {
  EIO_PRI_MIN = -4,
  EIO_PRI_MAX = 4,
  EIO_PRI_DEFAULT = 0
};
# 221 "/usr/include/nodejs/uv-private/eio.h" 3 4
typedef struct {
  eio_req *qs[(EIO_PRI_MAX - EIO_PRI_MIN + 1)], *qe[(EIO_PRI_MAX - EIO_PRI_MIN + 1)];
  int size;
} etp_reqq;

typedef struct {
  etp_reqq res_queue;
  void *data;
} eio_channel;




struct eio_req
{
  eio_req volatile *next;

  eio_ssize_t result;
  off_t offs;
  size_t size;
  void *ptr1;
  void *ptr2;
  eio_tstamp nv1;
  eio_tstamp nv2;

  int type;
  int int1;
  long int2;
  long int3;
  int errorno;

  eio_channel *channel;


  unsigned char cancelled;




  unsigned char flags;
  signed char pri;

  void *data;
  eio_cb finish;
  void (*destroy)(eio_req *req);
  void (*feed)(eio_req *req);

 

  eio_req *grp, *grp_prev, *grp_next, *grp_first;
};


enum {
  EIO_FLAG_PTR1_FREE = 0x01,
  EIO_FLAG_PTR2_FREE = 0x02,
  EIO_FLAG_GROUPADD = 0x04
};
# 288 "/usr/include/nodejs/uv-private/eio.h" 3 4
int eio_init (void (*want_poll)(eio_channel *), void (*done_poll)(eio_channel *));


void eio_channel_init(eio_channel *, void *data);



int eio_poll (eio_channel *channel);


void eio_set_max_poll_time (eio_tstamp nseconds);

void eio_set_max_poll_reqs (unsigned int nreqs);




void eio_set_min_parallel (unsigned int nthreads);
void eio_set_max_parallel (unsigned int nthreads);
void eio_set_max_idle (unsigned int nthreads);
void eio_set_idle_timeout (unsigned int seconds);

unsigned int eio_nreqs (void);
unsigned int eio_nready (void);
unsigned int eio_npending (void);
unsigned int eio_nthreads (void);





eio_req *eio_nop (int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_busy (eio_tstamp delay, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_sync (int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_fsync (int fd, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_fdatasync (int fd, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_syncfs (int fd, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_msync (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_mtouch (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_mlock (void *addr, size_t length, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_mlockall (int flags, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_fallocate (int fd, int mode, off_t offset, size_t len, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_close (int fd, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_readahead (int fd, off_t offset, size_t length, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_read (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_write (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_fstat (int fd, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_fstatvfs (int fd, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_futime (int fd, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_ftruncate (int fd, off_t offset, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_fchmod (int fd, eio_mode_t mode, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_fchown (int fd, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_dup2 (int fd, int fd2, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_sendfile (int out_fd, int in_fd, off_t in_offset, size_t length, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_open (const char *path, int flags, eio_mode_t mode, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_utime (const char *path, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_truncate (const char *path, off_t offset, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_chown (const char *path, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_chmod (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_mkdir (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_readdir (const char *path, int flags, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_rmdir (const char *path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_unlink (const char *path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_readlink (const char *path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_realpath (const char *path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_stat (const char *path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_lstat (const char *path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_statvfs (const char *path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_mknod (const char *path, eio_mode_t mode, dev_t dev, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_link (const char *path, const char *new_path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_symlink (const char *path, const char *new_path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_rename (const char *path, const char *new_path, int pri, eio_cb cb, void *data, eio_channel *channel);
eio_req *eio_custom (void (*execute)(eio_req *), int pri, eio_cb cb, void *data, eio_channel *channel);





eio_req *eio_grp (eio_cb cb, void *data, eio_channel *channel);
void eio_grp_feed (eio_req *grp, void (*feed)(eio_req *req), int limit);
void eio_grp_limit (eio_req *grp, int limit);
void eio_grp_add (eio_req *grp, eio_req *req);
void eio_grp_cancel (eio_req *grp);
# 387 "/usr/include/nodejs/uv-private/eio.h" 3 4
void eio_submit (eio_req *req);

void eio_cancel (eio_req *req);




eio_ssize_t eio_sendfile_sync (int ofd, int ifd, off_t offset, size_t count);
eio_ssize_t eio__pread (int fd, void *buf, size_t count, off_t offset);
eio_ssize_t eio__pwrite (int fd, void *buf, size_t count, off_t offset);


}
# 29 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4



# 1 "/usr/include/fcntl.h" 1 3 4
# 30 "/usr/include/fcntl.h" 3 4
extern "C" {



# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 25 "/usr/include/bits/fcntl.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/fcntl.h" 2 3 4

# 1 "/usr/include/bits/uio.h" 1 3 4
# 28 "/usr/include/bits/fcntl.h" 2 3 4
# 160 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;




    __off64_t l_start;
    __off64_t l_len;

    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };




enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_GID
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 257 "/usr/include/bits/fcntl.h" 3 4
extern "C" {




extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();



extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
       unsigned int __flags);



extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);


extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);


extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64");







extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);



}
# 35 "/usr/include/fcntl.h" 2 3 4
# 64 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 76 "/usr/include/fcntl.h" 3 4
extern int open (__const char *__file, int __oflag, ...) __asm__ ("" "open64")
     __attribute__ ((__nonnull__ (1)));





extern int open64 (__const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 101 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, __const char *__file, int __oflag, ...) __asm__ ("" "openat64") __attribute__ ((__nonnull__ (2)));






extern int openat64 (int __fd, __const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 121 "/usr/include/fcntl.h" 3 4
extern int creat (__const char *__file, __mode_t __mode) __asm__ ("" "creat64") __attribute__ ((__nonnull__ (1)));






extern int creat64 (__const char *__file, __mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 168 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) throw () __asm__ ("" "posix_fadvise64");







extern int posix_fadvise64 (int __fd, __off64_t __offset, __off64_t __len,
       int __advise) throw ();
# 189 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64");







extern int posix_fallocate64 (int __fd, __off64_t __offset, __off64_t __len);
# 208 "/usr/include/fcntl.h" 3 4
}
# 33 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4



# 1 "/usr/include/netinet/tcp.h" 1 3 4
# 92 "/usr/include/netinet/tcp.h" 3 4
struct tcphdr
  {
    u_int16_t source;
    u_int16_t dest;
    u_int32_t seq;
    u_int32_t ack_seq;

    u_int16_t res1:4;
    u_int16_t doff:4;
    u_int16_t fin:1;
    u_int16_t syn:1;
    u_int16_t rst:1;
    u_int16_t psh:1;
    u_int16_t ack:1;
    u_int16_t urg:1;
    u_int16_t res2:2;
# 121 "/usr/include/netinet/tcp.h" 3 4
    u_int16_t window;
    u_int16_t check;
    u_int16_t urg_ptr;
};


enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING
};
# 179 "/usr/include/netinet/tcp.h" 3 4
enum tcp_ca_state
{
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info
{
  u_int8_t tcpi_state;
  u_int8_t tcpi_ca_state;
  u_int8_t tcpi_retransmits;
  u_int8_t tcpi_probes;
  u_int8_t tcpi_backoff;
  u_int8_t tcpi_options;
  u_int8_t tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

  u_int32_t tcpi_rto;
  u_int32_t tcpi_ato;
  u_int32_t tcpi_snd_mss;
  u_int32_t tcpi_rcv_mss;

  u_int32_t tcpi_unacked;
  u_int32_t tcpi_sacked;
  u_int32_t tcpi_lost;
  u_int32_t tcpi_retrans;
  u_int32_t tcpi_fackets;


  u_int32_t tcpi_last_data_sent;
  u_int32_t tcpi_last_ack_sent;
  u_int32_t tcpi_last_data_recv;
  u_int32_t tcpi_last_ack_recv;


  u_int32_t tcpi_pmtu;
  u_int32_t tcpi_rcv_ssthresh;
  u_int32_t tcpi_rtt;
  u_int32_t tcpi_rttvar;
  u_int32_t tcpi_snd_ssthresh;
  u_int32_t tcpi_snd_cwnd;
  u_int32_t tcpi_advmss;
  u_int32_t tcpi_reordering;

  u_int32_t tcpi_rcv_rtt;
  u_int32_t tcpi_rcv_space;

  u_int32_t tcpi_total_retrans;
};





struct tcp_md5sig
{
  struct sockaddr_storage tcpm_addr;
  u_int16_t __tcpm_pad1;
  u_int16_t tcpm_keylen;
  u_int32_t __tcpm_pad2;
  u_int8_t tcpm_key[80];
};
# 37 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4

# 1 "/usr/include/netdb.h" 1 3 4
# 33 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4

extern "C" {

struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) throw ();
extern void endrpcent (void) throw ();
extern struct rpcent *getrpcbyname (__const char *__name) throw ();
extern struct rpcent *getrpcbynumber (int __number) throw ();
extern struct rpcent *getrpcent (void) throw ();


extern int getrpcbyname_r (__const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) throw ();

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) throw ();

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) throw ();


}
# 34 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4
# 39 "/usr/include/netdb.h" 2 3 4




# 1 "/usr/include/bits/netdb.h" 1 3 4
# 27 "/usr/include/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 44 "/usr/include/netdb.h" 2 3 4
# 54 "/usr/include/netdb.h" 3 4
extern "C" {






extern int *__h_errno_location (void) throw () __attribute__ ((__const__));
# 91 "/usr/include/netdb.h" 3 4
extern void herror (__const char *__str) throw ();


extern __const char *hstrerror (int __err_num) throw ();




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (__const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (__const char *__name);
# 154 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (__const char *__name, int __af);
# 166 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (__const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (__const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (__const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 197 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (__const char *__name);
# 236 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (__const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (__const char *__name,
          __const char *__proto);






extern struct servent *getservbyport (int __port, __const char *__proto);
# 308 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (__const char *__restrict __name,
       __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, __const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (__const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 374 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (__const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 395 "/usr/include/netdb.h" 3 4
extern int setnetgrent (__const char *__netgroup);







extern void endnetgrent (void);
# 412 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 423 "/usr/include/netdb.h" 3 4
extern int innetgr (__const char *__netgroup, __const char *__host,
      __const char *__user, __const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 451 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   __const char *__restrict __locuser,
   __const char *__restrict __remuser,
   __const char *__restrict __cmd, int *__restrict __fd2p);
# 463 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      __const char *__restrict __locuser,
      __const char *__restrict __remuser,
      __const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 479 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    __const char *__restrict __name,
    __const char *__restrict __pass,
    __const char *__restrict __cmd, int *__restrict __fd2p);
# 491 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       __const char *__restrict __name,
       __const char *__restrict __pass,
       __const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 505 "/usr/include/netdb.h" 3 4
extern int ruserok (__const char *__rhost, int __suser,
      __const char *__remuser, __const char *__locuser);
# 515 "/usr/include/netdb.h" 3 4
extern int ruserok_af (__const char *__rhost, int __suser,
         __const char *__remuser, __const char *__locuser,
         sa_family_t __af);
# 527 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 536 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __unused[5];
};
# 638 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (__const char *__restrict __name,
   __const char *__restrict __service,
   __const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) throw ();


extern __const char *gai_strerror (int __ecode) throw ();





extern int getnameinfo (__const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, unsigned int __flags);
# 668 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[],
     int __ent, struct sigevent *__restrict __sig);
# 679 "/usr/include/netdb.h" 3 4
extern int gai_suspend (__const struct gaicb *__const __list[], int __ent,
   __const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) throw ();


extern int gai_cancel (struct gaicb *__gaicbp) throw ();


}
# 39 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4

# 1 "/usr/include/termios.h" 1 3 4
# 36 "/usr/include/termios.h" 3 4
extern "C" {



# 1 "/usr/include/bits/termios.h" 1 3 4
# 25 "/usr/include/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;


struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
# 41 "/usr/include/termios.h" 2 3 4
# 49 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (__const struct termios *__termios_p) throw ();


extern speed_t cfgetispeed (__const struct termios *__termios_p) throw ();


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) throw ();


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) throw ();



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) throw ();




extern int tcgetattr (int __fd, struct termios *__termios_p) throw ();



extern int tcsetattr (int __fd, int __optional_actions,
        __const struct termios *__termios_p) throw ();




extern void cfmakeraw (struct termios *__termios_p) throw ();



extern int tcsendbreak (int __fd, int __duration) throw ();





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) throw ();



extern int tcflow (int __fd, int __action) throw ();




extern __pid_t tcgetsid (int __fd) throw ();




# 1 "/usr/include/sys/ttydefaults.h" 1 3 4
# 106 "/usr/include/termios.h" 2 3 4


}
# 41 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4
# 1 "/usr/include/pwd.h" 1 3 4
# 28 "/usr/include/pwd.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 34 "/usr/include/pwd.h" 2 3 4
# 50 "/usr/include/pwd.h" 3 4
struct passwd
{
  char *pw_name;
  char *pw_passwd;
  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};
# 73 "/usr/include/pwd.h" 3 4
extern void setpwent (void);





extern void endpwent (void);





extern struct passwd *getpwent (void);
# 95 "/usr/include/pwd.h" 3 4
extern struct passwd *fgetpwent (FILE *__stream);







extern int putpwent (__const struct passwd *__restrict __p,
       FILE *__restrict __f);






extern struct passwd *getpwuid (__uid_t __uid);





extern struct passwd *getpwnam (__const char *__name);
# 140 "/usr/include/pwd.h" 3 4
extern int getpwent_r (struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);


extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);

extern int getpwnam_r (__const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result);
# 164 "/usr/include/pwd.h" 3 4
extern int fgetpwent_r (FILE *__restrict __stream,
   struct passwd *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct passwd **__restrict __result);
# 181 "/usr/include/pwd.h" 3 4
extern int getpw (__uid_t __uid, char *__buffer);


}
# 42 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4
# 51 "/usr/include/nodejs/uv-private/uv-unix.h" 3 4
# 1 "/usr/include/semaphore.h" 1 3 4
# 30 "/usr/include/semaphore.h" 3 4
# 1 "/usr/include/bits/semaphore.h" 1 3 4
# 24 "/usr/include/bits/semaphore.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 25 "/usr/include/bits/semaphore.h" 2 3 4
# 37 "/usr/include/bits/semaphore.h" 3 4
typedef union
{
  char __size[32];
  long int __align;
} sem_t;
# 31 "/usr/include/semaphore.h" 2 3 4


extern "C" {



extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
     throw ();

extern int sem_destroy (sem_t *__sem) throw ();


extern sem_t *sem_open (__const char *__name, int __oflag, ...) throw ();


extern int sem_close (sem_t *__sem) throw ();


extern int sem_unlink (__const char *__name) throw ();





extern int sem_wait (sem_t *__sem);






extern int sem_timedwait (sem_t *__restrict __sem,
     __const struct timespec *__restrict __abstime);



extern int sem_trywait (sem_t *__sem) throw ();


extern int sem_post (sem_t *__sem) throw ();


extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
     throw ();


}
# 52 "/usr/include/nodejs/uv-private/uv-unix.h" 2 3 4
# 60 "/usr/include/nodejs/uv-private/uv-unix.h" 3 4
typedef struct {
  char* base;
  size_t len;
} uv_buf_t;

typedef int uv_file;

typedef int uv_os_sock_t;

typedef struct stat uv_statbuf_t;



typedef pthread_once_t uv_once_t;
typedef pthread_t uv_thread_t;
typedef pthread_mutex_t uv_mutex_t;
typedef pthread_rwlock_t uv_rwlock_t;



typedef sem_t uv_sem_t;



typedef gid_t uv_gid_t;
typedef uid_t uv_uid_t;



typedef struct {
  void* handle;
  char* errmsg;
} uv_lib_t;

struct uv__io_s;
struct uv_loop_s;

typedef struct uv__io_s uv__io_t;
typedef void (*uv__io_cb)(struct uv_loop_s* loop, uv__io_t* handle, int events);

struct uv__io_s {
  ev_io io_watcher;
};
# 62 "/usr/include/nodejs/uv.h" 2 3 4
# 129 "/usr/include/nodejs/uv.h" 3 4
typedef enum {
  UV_UNKNOWN = -1, UV_OK = 0, UV_EOF = 1, UV_EADDRINFO = 2, UV_EACCES = 3, UV_EAGAIN = 4, UV_EADDRINUSE = 5, UV_EADDRNOTAVAIL = 6, UV_EAFNOSUPPORT = 7, UV_EALREADY = 8, UV_EBADF = 9, UV_EBUSY = 10, UV_ECONNABORTED = 11, UV_ECONNREFUSED = 12, UV_ECONNRESET = 13, UV_EDESTADDRREQ = 14, UV_EFAULT = 15, UV_EHOSTUNREACH = 16, UV_EINTR = 17, UV_EINVAL = 18, UV_EISCONN = 19, UV_EMFILE = 20, UV_EMSGSIZE = 21, UV_ENETDOWN = 22, UV_ENETUNREACH = 23, UV_ENFILE = 24, UV_ENOBUFS = 25, UV_ENOMEM = 26, UV_ENOTDIR = 27, UV_EISDIR = 28, UV_ENONET = 29, UV_ENOTCONN = 31, UV_ENOTSOCK = 32, UV_ENOTSUP = 33, UV_ENOENT = 34, UV_ENOSYS = 35, UV_EPIPE = 36, UV_EPROTO = 37, UV_EPROTONOSUPPORT = 38, UV_EPROTOTYPE = 39, UV_ETIMEDOUT = 40, UV_ECHARSET = 41, UV_EAIFAMNOSUPPORT = 42, UV_EAISERVICE = 44, UV_EAISOCKTYPE = 45, UV_ESHUTDOWN = 46, UV_EEXIST = 47, UV_ESRCH = 48, UV_ENAMETOOLONG = 49, UV_EPERM = 50, UV_ELOOP = 51, UV_EXDEV = 52, UV_ENOTEMPTY = 53, UV_ENOSPC = 54, UV_EIO = 55, UV_EROFS = 56, UV_ENODEV = 57, UV_ESPIPE = 58,
  UV_MAX_ERRORS
} uv_err_code;
# 159 "/usr/include/nodejs/uv.h" 3 4
typedef enum {
  UV_UNKNOWN_HANDLE = 0,

  UV_ASYNC, UV_CHECK, UV_FS_EVENT, UV_FS_POLL, UV_IDLE, UV_NAMED_PIPE, UV_POLL, UV_PREPARE, UV_PROCESS, UV_TCP, UV_TIMER, UV_TTY, UV_UDP,

  UV_ARES_TASK,
  UV_FILE,
  UV_HANDLE_TYPE_MAX
} uv_handle_type;

typedef enum {
  UV_UNKNOWN_REQ = 0,

  UV_CONNECT, UV_WRITE, UV_SHUTDOWN, UV_UDP_SEND, UV_FS, UV_WORK, UV_GETADDRINFO,

 
  UV_REQ_TYPE_MAX
} uv_req_type;



typedef struct uv_loop_s uv_loop_t;
typedef struct uv_ares_task_s uv_ares_task_t;
typedef struct uv_err_s uv_err_t;
typedef struct uv_handle_s uv_handle_t;
typedef struct uv_stream_s uv_stream_t;
typedef struct uv_tcp_s uv_tcp_t;
typedef struct uv_udp_s uv_udp_t;
typedef struct uv_pipe_s uv_pipe_t;
typedef struct uv_tty_s uv_tty_t;
typedef struct uv_poll_s uv_poll_t;
typedef struct uv_timer_s uv_timer_t;
typedef struct uv_prepare_s uv_prepare_t;
typedef struct uv_check_s uv_check_t;
typedef struct uv_idle_s uv_idle_t;
typedef struct uv_async_s uv_async_t;
typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;
typedef struct uv_process_s uv_process_t;
typedef struct uv_counters_s uv_counters_t;
typedef struct uv_cpu_info_s uv_cpu_info_t;
typedef struct uv_interface_address_s uv_interface_address_t;

typedef struct uv_req_s uv_req_t;
typedef struct uv_shutdown_s uv_shutdown_t;
typedef struct uv_write_s uv_write_t;
typedef struct uv_connect_s uv_connect_t;
typedef struct uv_udp_send_s uv_udp_send_t;
typedef struct uv_fs_s uv_fs_t;

typedef struct uv_fs_event_s uv_fs_event_t;
typedef struct uv_fs_poll_s uv_fs_poll_t;
typedef struct uv_work_s uv_work_t;
# 221 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) uv_loop_t* uv_loop_new(void);
__attribute__((visibility("default"))) void uv_loop_delete(uv_loop_t*);




__attribute__((visibility("default"))) uv_loop_t* uv_default_loop(void);





__attribute__((visibility("default"))) int uv_run(uv_loop_t*);







__attribute__((visibility("default"))) int uv_run_once(uv_loop_t*);





__attribute__((visibility("default"))) void uv_ref(uv_handle_t*);
__attribute__((visibility("default"))) void uv_unref(uv_handle_t*);

__attribute__((visibility("default"))) void uv_update_time(uv_loop_t*);
__attribute__((visibility("default"))) int64_t uv_now(uv_loop_t*);
# 260 "/usr/include/nodejs/uv.h" 3 4
typedef uv_buf_t (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size);
# 274 "/usr/include/nodejs/uv.h" 3 4
typedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);






typedef void (*uv_read2_cb)(uv_pipe_t* pipe, ssize_t nread, uv_buf_t buf,
    uv_handle_type pending);

typedef void (*uv_write_cb)(uv_write_t* req, int status);
typedef void (*uv_connect_cb)(uv_connect_t* req, int status);
typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);
typedef void (*uv_connection_cb)(uv_stream_t* server, int status);
typedef void (*uv_close_cb)(uv_handle_t* handle);
typedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);
typedef void (*uv_timer_cb)(uv_timer_t* handle, int status);

typedef void (*uv_async_cb)(uv_async_t* handle, int status);
typedef void (*uv_prepare_cb)(uv_prepare_t* handle, int status);
typedef void (*uv_check_cb)(uv_check_t* handle, int status);
typedef void (*uv_idle_cb)(uv_idle_t* handle, int status);
typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* handle, int status,
    struct addrinfo* res);
typedef void (*uv_exit_cb)(uv_process_t*, int exit_status, int term_signal);
typedef void (*uv_fs_cb)(uv_fs_t* req);
typedef void (*uv_work_cb)(uv_work_t* req);
typedef void (*uv_after_work_cb)(uv_work_t* req);
typedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);







typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle, const char* filename,
    int events, int status);

typedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,
                              int status,
                              const uv_statbuf_t* prev,
                              const uv_statbuf_t* curr);

typedef enum {
  UV_LEAVE_GROUP = 0,
  UV_JOIN_GROUP
} uv_membership;


struct uv_err_s {

  uv_err_code code;

  int sys_errno_;
};







__attribute__((visibility("default"))) uv_err_t uv_last_error(uv_loop_t*);
__attribute__((visibility("default"))) const char* uv_strerror(uv_err_t err);
__attribute__((visibility("default"))) const char* uv_err_name(uv_err_t err);
# 352 "/usr/include/nodejs/uv.h" 3 4
struct uv_req_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;
};




# 369 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle,
    uv_shutdown_cb cb);

struct uv_shutdown_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;
  uv_stream_t* handle;
  uv_shutdown_cb cb;
 
};
# 393 "/usr/include/nodejs/uv.h" 3 4
struct uv_handle_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
};






__attribute__((visibility("default"))) size_t uv_handle_size(uv_handle_type type);




__attribute__((visibility("default"))) size_t uv_req_size(uv_req_type type);





__attribute__((visibility("default"))) int uv_is_active(const uv_handle_t* handle);




__attribute__((visibility("default"))) void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);
# 429 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) void uv_close(uv_handle_t* handle, uv_close_cb close_cb);
# 438 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) uv_buf_t uv_buf_init(char* base, unsigned int len);






__attribute__((visibility("default"))) size_t uv_strlcpy(char* dst, const char* src, size_t size);







__attribute__((visibility("default"))) size_t uv_strlcat(char* dst, const char* src, size_t size);
# 473 "/usr/include/nodejs/uv.h" 3 4
struct uv_stream_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_read2_cb read2_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t read_watcher; uv__io_t write_watcher; ngx_queue_t write_queue; ngx_queue_t write_completed_queue; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; int fd;
};

__attribute__((visibility("default"))) int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);
# 491 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_accept(uv_stream_t* server, uv_stream_t* client);
# 503 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb,
    uv_read_cb read_cb);

__attribute__((visibility("default"))) int uv_read_stop(uv_stream_t*);





__attribute__((visibility("default"))) int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb,
    uv_read2_cb read_cb);
# 534 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_write(uv_write_t* req, uv_stream_t* handle,
    uv_buf_t bufs[], int bufcnt, uv_write_cb cb);
# 544 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[],
    int bufcnt, uv_stream_t* send_handle, uv_write_cb cb);


struct uv_write_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;
  uv_write_cb cb;
  uv_stream_t* send_handle;
  uv_stream_t* handle;
  ngx_queue_t queue; int write_index; uv_buf_t* bufs; int bufcnt; int error; uv_buf_t bufsml[(4)];
};





__attribute__((visibility("default"))) int uv_is_readable(const uv_stream_t* handle);
__attribute__((visibility("default"))) int uv_is_writable(const uv_stream_t* handle);
# 571 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_is_closing(const uv_handle_t* handle);







struct uv_tcp_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_read2_cb read2_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t read_watcher; uv__io_t write_watcher; ngx_queue_t write_queue; ngx_queue_t write_completed_queue; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; int fd;
 
};

__attribute__((visibility("default"))) int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);


__attribute__((visibility("default"))) int uv_tcp_nodelay(uv_tcp_t* handle, int enable);





__attribute__((visibility("default"))) int uv_tcp_keepalive(uv_tcp_t* handle, int enable,
    unsigned int delay);
# 605 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);

__attribute__((visibility("default"))) int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);
__attribute__((visibility("default"))) int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);
__attribute__((visibility("default"))) int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,
    int* namelen);
__attribute__((visibility("default"))) int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,
    int* namelen);







__attribute__((visibility("default"))) int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,
    struct sockaddr_in address, uv_connect_cb cb);
__attribute__((visibility("default"))) int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,
    struct sockaddr_in6 address, uv_connect_cb cb);


struct uv_connect_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;
  uv_connect_cb cb;
  uv_stream_t* handle;
  ngx_queue_t queue;
};






enum uv_udp_flags {

  UV_UDP_IPV6ONLY = 1,




  UV_UDP_PARTIAL = 2
};





typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);
# 668 "/usr/include/nodejs/uv.h" 3 4
typedef void (*uv_udp_recv_cb)(uv_udp_t* handle, ssize_t nread, uv_buf_t buf,
    struct sockaddr* addr, unsigned flags);


struct uv_udp_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  int fd; uv_alloc_cb alloc_cb; uv_udp_recv_cb recv_cb; uv__io_t read_watcher; uv__io_t write_watcher; ngx_queue_t write_queue; ngx_queue_t write_completed_queue;
};


struct uv_udp_send_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;
  uv_udp_t* handle;
  uv_udp_send_cb cb;
  ngx_queue_t queue; struct sockaddr_in6 addr; int bufcnt; uv_buf_t* bufs; ssize_t status; uv_udp_send_cb send_cb; uv_buf_t bufsml[(4)];
};





__attribute__((visibility("default"))) int uv_udp_init(uv_loop_t*, uv_udp_t* handle);
# 702 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,
    unsigned flags);
# 716 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,
    unsigned flags);
__attribute__((visibility("default"))) int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,
    int* namelen);
# 734 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_set_membership(uv_udp_t* handle,
    const char* multicast_addr, const char* interface_addr,
    uv_membership membership);
# 750 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);
# 763 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);
# 776 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_set_broadcast(uv_udp_t* handle, int on);
# 789 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_set_ttl(uv_udp_t* handle, int ttl);
# 807 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle,
    uv_buf_t bufs[], int bufcnt, struct sockaddr_in addr,
    uv_udp_send_cb send_cb);
# 826 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle,
    uv_buf_t bufs[], int bufcnt, struct sockaddr_in6 addr,
    uv_udp_send_cb send_cb);
# 843 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,
    uv_udp_recv_cb recv_cb);
# 855 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_udp_recv_stop(uv_udp_t* handle);







struct uv_tty_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_read2_cb read2_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t read_watcher; uv__io_t write_watcher; ngx_queue_t write_queue; ngx_queue_t write_completed_queue; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; int fd;
  struct termios orig_termios; int mode;
};
# 880 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);




__attribute__((visibility("default"))) int uv_tty_set_mode(uv_tty_t*, int mode);





__attribute__((visibility("default"))) void uv_tty_reset_mode(void);




__attribute__((visibility("default"))) int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);







__attribute__((visibility("default"))) uv_handle_type uv_guess_handle(uv_file file);







struct uv_pipe_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_read2_cb read2_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t read_watcher; uv__io_t write_watcher; ngx_queue_t write_queue; ngx_queue_t write_completed_queue; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; int fd;
  const char* pipe_fname;
  int ipc;
};





__attribute__((visibility("default"))) int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);




__attribute__((visibility("default"))) void uv_pipe_open(uv_pipe_t*, uv_file file);

__attribute__((visibility("default"))) int uv_pipe_bind(uv_pipe_t* handle, const char* name);

__attribute__((visibility("default"))) void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,
    const char* name, uv_connect_cb cb);






__attribute__((visibility("default"))) void uv_pipe_pending_instances(uv_pipe_t* handle, int count);
# 972 "/usr/include/nodejs/uv.h" 3 4
struct uv_poll_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  uv_poll_cb poll_cb;
  int fd; uv__io_t io_watcher;
};

enum uv_poll_event {
  UV_READABLE = 1,
  UV_WRITABLE = 2
};


__attribute__((visibility("default"))) int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);



__attribute__((visibility("default"))) int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,
    uv_os_sock_t socket);
# 1005 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);


__attribute__((visibility("default"))) int uv_poll_stop(uv_poll_t* handle);
# 1018 "/usr/include/nodejs/uv.h" 3 4
struct uv_prepare_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  uv_prepare_cb prepare_cb; ngx_queue_t queue;
};

__attribute__((visibility("default"))) int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);

__attribute__((visibility("default"))) int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);

__attribute__((visibility("default"))) int uv_prepare_stop(uv_prepare_t* prepare);
# 1036 "/usr/include/nodejs/uv.h" 3 4
struct uv_check_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  uv_check_cb check_cb; ngx_queue_t queue;
};

__attribute__((visibility("default"))) int uv_check_init(uv_loop_t*, uv_check_t* check);

__attribute__((visibility("default"))) int uv_check_start(uv_check_t* check, uv_check_cb cb);

__attribute__((visibility("default"))) int uv_check_stop(uv_check_t* check);
# 1056 "/usr/include/nodejs/uv.h" 3 4
struct uv_idle_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  uv_idle_cb idle_cb; ngx_queue_t queue;
};

__attribute__((visibility("default"))) int uv_idle_init(uv_loop_t*, uv_idle_t* idle);

__attribute__((visibility("default"))) int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);

__attribute__((visibility("default"))) int uv_idle_stop(uv_idle_t* idle);
# 1078 "/usr/include/nodejs/uv.h" 3 4
struct uv_async_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  volatile sig_atomic_t pending; uv_async_cb async_cb; ngx_queue_t queue;
};

__attribute__((visibility("default"))) int uv_async_init(uv_loop_t*, uv_async_t* async,
    uv_async_cb async_cb);






__attribute__((visibility("default"))) int uv_async_send(uv_async_t* async);







struct uv_timer_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  struct { struct uv_timer_s* rbe_left; struct uv_timer_s* rbe_right; struct uv_timer_s* rbe_parent; int rbe_color; } tree_entry; uv_timer_cb timer_cb; uint64_t timeout; uint64_t repeat;
};

__attribute__((visibility("default"))) int uv_timer_init(uv_loop_t*, uv_timer_t* timer);
# 1118 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_timer_start(uv_timer_t* timer,
                             uv_timer_cb cb,
                             int64_t timeout,
                             int64_t repeat);

__attribute__((visibility("default"))) int uv_timer_stop(uv_timer_t* timer);






__attribute__((visibility("default"))) int uv_timer_again(uv_timer_t* timer);







__attribute__((visibility("default"))) void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat);

__attribute__((visibility("default"))) int64_t uv_timer_get_repeat(uv_timer_t* timer);



__attribute__((visibility("default"))) int uv_ares_init_options(uv_loop_t*,
    ares_channel *channelptr, struct ares_options *options, int optmask);


__attribute__((visibility("default"))) void uv_ares_destroy(uv_loop_t*, ares_channel channel);







struct uv_getaddrinfo_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;

  uv_loop_t* loop;
  uv_getaddrinfo_cb cb; struct addrinfo* hints; char* hostname; char* service; struct addrinfo* res; int retcode;
};
# 1176 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_getaddrinfo(uv_loop_t*, uv_getaddrinfo_t* handle,
    uv_getaddrinfo_cb getaddrinfo_cb, const char* node, const char* service,
    const struct addrinfo* hints);

__attribute__((visibility("default"))) void uv_freeaddrinfo(struct addrinfo* ai);


typedef enum {
  UV_IGNORE = 0x00,
  UV_CREATE_PIPE = 0x01,
  UV_INHERIT_FD = 0x02,
  UV_INHERIT_STREAM = 0x04,





  UV_READABLE_PIPE = 0x10,
  UV_WRITABLE_PIPE = 0x20
} uv_stdio_flags;

typedef struct uv_stdio_container_s {
  uv_stdio_flags flags;

  union {
    uv_stream_t* stream;
    int fd;
  } data;
} uv_stdio_container_t;

typedef struct uv_process_options_s {
  uv_exit_cb exit_cb;
  const char* file;






  char** args;




  char** env;




  char* cwd;




  unsigned int flags;





  uv_uid_t uid;
  uv_gid_t gid;
# 1248 "/usr/include/nodejs/uv.h" 3 4
  int stdio_count;
  uv_stdio_container_t* stdio;
} uv_process_options_t;




enum uv_process_flags {





  UV_PROCESS_SETUID = (1 << 0),





  UV_PROCESS_SETGID = (1 << 1),





  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),







  UV_PROCESS_DETACHED = (1 << 3)
};




struct uv_process_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  uv_exit_cb exit_cb;
  int pid;
  ev_child child_watcher;
};


__attribute__((visibility("default"))) int uv_spawn(uv_loop_t*, uv_process_t*,
    uv_process_options_t options);






__attribute__((visibility("default"))) int uv_process_kill(uv_process_t*, int signum);



__attribute__((visibility("default"))) uv_err_t uv_kill(int pid, int signum);





struct uv_work_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;
  uv_loop_t* loop;
  uv_work_cb work_cb;
  uv_after_work_cb after_work_cb;
  eio_req* eio;
};


__attribute__((visibility("default"))) int uv_queue_work(uv_loop_t* loop, uv_work_t* req,
    uv_work_cb work_cb, uv_after_work_cb after_work_cb);


struct uv_cpu_info_s {
  char* model;
  int speed;
  struct uv_cpu_times_s {
    uint64_t user;
    uint64_t nice;
    uint64_t sys;
    uint64_t idle;
    uint64_t irq;
  } cpu_times;
};

struct uv_interface_address_s {
  char* name;
  int is_internal;
  union {
    struct sockaddr_in address4;
    struct sockaddr_in6 address6;
  } address;
};

__attribute__((visibility("default"))) char** uv_setup_args(int argc, char** argv);
__attribute__((visibility("default"))) uv_err_t uv_get_process_title(char* buffer, size_t size);
__attribute__((visibility("default"))) uv_err_t uv_set_process_title(const char* title);
__attribute__((visibility("default"))) uv_err_t uv_resident_set_memory(size_t* rss);
__attribute__((visibility("default"))) uv_err_t uv_uptime(double* uptime);





__attribute__((visibility("default"))) uv_err_t uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);
__attribute__((visibility("default"))) void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);





__attribute__((visibility("default"))) uv_err_t uv_interface_addresses(uv_interface_address_t** addresses,
  int* count);
__attribute__((visibility("default"))) void uv_free_interface_addresses(uv_interface_address_t* addresses,
  int count);
# 1383 "/usr/include/nodejs/uv.h" 3 4
typedef enum {
  UV_FS_UNKNOWN = -1,
  UV_FS_CUSTOM,
  UV_FS_OPEN,
  UV_FS_CLOSE,
  UV_FS_READ,
  UV_FS_WRITE,
  UV_FS_SENDFILE,
  UV_FS_STAT,
  UV_FS_LSTAT,
  UV_FS_FSTAT,
  UV_FS_FTRUNCATE,
  UV_FS_UTIME,
  UV_FS_FUTIME,
  UV_FS_CHMOD,
  UV_FS_FCHMOD,
  UV_FS_FSYNC,
  UV_FS_FDATASYNC,
  UV_FS_UNLINK,
  UV_FS_RMDIR,
  UV_FS_MKDIR,
  UV_FS_RENAME,
  UV_FS_READDIR,
  UV_FS_LINK,
  UV_FS_SYMLINK,
  UV_FS_READLINK,
  UV_FS_CHOWN,
  UV_FS_FCHOWN
} uv_fs_type;


struct uv_fs_s {
  void* data; ngx_queue_t active_queue; uv_req_type type;
  uv_fs_type fs_type;
  uv_loop_t* loop;
  uv_fs_cb cb;
  ssize_t result;
  void* ptr;
  const char* path;
  uv_err_code errorno;
  struct stat statbuf; eio_req* eio;
};

__attribute__((visibility("default"))) void uv_fs_req_cleanup(uv_fs_t* req);

__attribute__((visibility("default"))) int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path,
    int flags, int mode, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    void* buf, size_t length, int64_t offset, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    void* buf, size_t length, int64_t offset, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path,
    int mode, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req,
    const char* path, int flags, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,
    const char* new_path, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    int64_t offset, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,
    uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path,
    int mode, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path,
    double atime, double mtime, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    double atime, double mtime, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,
    const char* new_path, uv_fs_cb cb);
# 1500 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,
    const char* new_path, int flags, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,
    uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    int mode, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path,
    int uid, int gid, uv_fs_cb cb);

__attribute__((visibility("default"))) int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file,
    int uid, int gid, uv_fs_cb cb);


enum uv_fs_event {
  UV_RENAME = 1,
  UV_CHANGE = 2
};


struct uv_fs_event_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;
  char* filename;
  ngx_queue_t watchers; uv_fs_event_cb cb; int wd; void* pad0; void* pad1;
};





struct uv_fs_poll_s {
  uv_loop_t* loop; uv_close_cb close_cb; void* data; uv_handle_type type; ngx_queue_t handle_queue; int flags; uv_handle_t* next_closing;

  void* poll_ctx;

  char padding[sizeof(int)
             + sizeof(unsigned int)
             + sizeof(uint64_t)
             + sizeof(char*)
             + sizeof(uv_fs_poll_cb)
             + sizeof(uv_timer_t)
             + sizeof(uv_fs_t*)
             + sizeof(uv_statbuf_t)
             - sizeof(void*)];
};

__attribute__((visibility("default"))) int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);
# 1565 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) int uv_fs_poll_start(uv_fs_poll_t* handle,
                               uv_fs_poll_cb poll_cb,
                               const char* path,
                               unsigned int interval);

__attribute__((visibility("default"))) int uv_fs_poll_stop(uv_fs_poll_t* handle);






__attribute__((visibility("default"))) void uv_loadavg(double avg[3]);





enum uv_fs_event_flags {







 UV_FS_EVENT_WATCH_ENTRY = 1,
# 1600 "/usr/include/nodejs/uv.h" 3 4
  UV_FS_EVENT_STAT = 2
};


__attribute__((visibility("default"))) int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,
    const char* filename, uv_fs_event_cb cb, int flags);




__attribute__((visibility("default"))) struct sockaddr_in uv_ip4_addr(const char* ip, int port);
__attribute__((visibility("default"))) struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);


__attribute__((visibility("default"))) int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size);
__attribute__((visibility("default"))) int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);


__attribute__((visibility("default"))) int uv_exepath(char* buffer, size_t* size);


__attribute__((visibility("default"))) uv_err_t uv_cwd(char* buffer, size_t size);


__attribute__((visibility("default"))) uv_err_t uv_chdir(const char* dir);


__attribute__((visibility("default"))) uint64_t uv_get_free_memory(void);
__attribute__((visibility("default"))) uint64_t uv_get_total_memory(void);
# 1639 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) extern uint64_t uv_hrtime(void);
# 1656 "/usr/include/nodejs/uv.h" 3 4
__attribute__((visibility("default"))) void uv_disable_stdio_inheritance(void);





__attribute__((visibility("default"))) int uv_dlopen(const char* filename, uv_lib_t* lib);




__attribute__((visibility("default"))) void uv_dlclose(uv_lib_t* lib);





__attribute__((visibility("default"))) int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);




__attribute__((visibility("default"))) const char* uv_dlerror(uv_lib_t* lib);





__attribute__((visibility("default"))) int uv_mutex_init(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_destroy(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_lock(uv_mutex_t* handle);
__attribute__((visibility("default"))) int uv_mutex_trylock(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_unlock(uv_mutex_t* handle);




__attribute__((visibility("default"))) int uv_rwlock_init(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_destroy(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_rdlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_wrlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);




__attribute__((visibility("default"))) int uv_sem_init(uv_sem_t* sem, unsigned int value);
__attribute__((visibility("default"))) void uv_sem_destroy(uv_sem_t* sem);
__attribute__((visibility("default"))) void uv_sem_post(uv_sem_t* sem);
__attribute__((visibility("default"))) void uv_sem_wait(uv_sem_t* sem);
__attribute__((visibility("default"))) int uv_sem_trywait(uv_sem_t* sem);





__attribute__((visibility("default"))) void uv_once(uv_once_t* guard, void (*callback)(void));

__attribute__((visibility("default"))) int uv_thread_create(uv_thread_t *tid,
    void (*entry)(void *arg), void *arg);
__attribute__((visibility("default"))) int uv_thread_join(uv_thread_t *tid);


union uv_any_handle {
  uv_tcp_t tcp;
  uv_pipe_t pipe;
  uv_prepare_t prepare;
  uv_check_t check;
  uv_idle_t idle;
  uv_async_t async;
  uv_timer_t timer;
  uv_getaddrinfo_t getaddrinfo;
  uv_fs_event_t fs_event;
};

union uv_any_req {
  uv_req_t req;
  uv_write_t write;
  uv_connect_t connect;
  uv_shutdown_t shutdown;
  uv_fs_t fs_req;
  uv_work_t work_req;
};


struct uv_counters_s {
  uint64_t async_init;
  uint64_t check_init;
  uint64_t eio_init;
  uint64_t fs_event_init;
  uint64_t fs_poll_init;
  uint64_t handle_init;
  uint64_t idle_init;
  uint64_t pipe_init;
  uint64_t poll_init;
  uint64_t prepare_init;
  uint64_t process_init;
  uint64_t req_init;
  uint64_t stream_init;
  uint64_t tcp_init;
  uint64_t timer_init;
  uint64_t tty_init;
  uint64_t udp_init;
};


struct uv_loop_s {
  eio_channel uv_eio_channel; struct ev_loop* ev; uv_async_t uv_eio_want_poll_notifier; uv_async_t uv_eio_done_poll_notifier; uv_idle_t uv_eio_poller; uv_handle_t* closing_handles; ngx_queue_t prepare_handles; ngx_queue_t check_handles; ngx_queue_t idle_handles; ngx_queue_t async_handles; uv__io_t async_watcher; int async_pipefd[2]; struct uv__timers { struct uv_timer_s* rbh_root; } timer_handles; uint64_t time; uv__io_t inotify_read_watcher; void* inotify_watchers; int inotify_fd;
  ares_channel channel;



  uv_timer_t ares_timer;

  struct uv__ares_tasks { uv_ares_task_t* rbh_root; } ares_handles;

  uv_counters_t counters;

  uv_err_t last_err;

  unsigned int active_handles;
  ngx_queue_t handle_queue;
  ngx_queue_t active_reqs;

  void* data;
};
# 1806 "/usr/include/nodejs/uv.h" 3 4
}
# 62 "/usr/include/nodejs/node.h" 2 3 4
# 1 "/usr/include/nodejs/v8.h" 1 3 4
# 41 "/usr/include/nodejs/v8.h" 3 4
# 1 "/usr/include/nodejs/v8stdint.h" 1 3 4
# 33 "/usr/include/nodejs/v8stdint.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 34 "/usr/include/nodejs/v8stdint.h" 2 3 4
# 42 "/usr/include/nodejs/v8.h" 2 3 4
# 81 "/usr/include/nodejs/v8.h" 3 4
namespace v8 {

class Context;
class String;
class StringObject;
class Value;
class Utils;
class Number;
class NumberObject;
class Object;
class Array;
class Int32;
class Uint32;
class External;
class Primitive;
class Boolean;
class BooleanObject;
class Integer;
class Function;
class Date;
class ImplementationUtilities;
class Signature;
class AccessorSignature;
template <class T> class Handle;
template <class T> class Local;
template <class T> class Persistent;
class FunctionTemplate;
class ObjectTemplate;
class Data;
class AccessorInfo;
class StackTrace;
class StackFrame;
class Isolate;

namespace internal {

class Arguments;
class Object;
class Heap;
class HeapObject;
class Isolate;
}
# 137 "/usr/include/nodejs/v8.h" 3 4
typedef void (*WeakReferenceCallback)(Persistent<Value> object,
                                      void* parameter);
# 173 "/usr/include/nodejs/v8.h" 3 4
template <class T> class Handle {
 public:



  inline Handle() : val_(0) {}




  inline explicit Handle(T* val) : val_(val) {}
# 195 "/usr/include/nodejs/v8.h" 3 4
  template <class S> inline Handle(Handle<S> that)
      : val_(reinterpret_cast<T*>(*that)) {





    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }




  inline bool IsEmpty() const { return val_ == 0; }




  inline void Clear() { val_ = 0; }

  inline T* operator->() const { return val_; }

  inline T* operator*() const { return val_; }







  template <class S> inline bool operator==(Handle<S> that) const {
    internal::Object** a = reinterpret_cast<internal::Object**>(**this);
    internal::Object** b = reinterpret_cast<internal::Object**>(*that);
    if (a == 0) return b == 0;
    if (b == 0) return false;
    return *a == *b;
  }







  template <class S> inline bool operator!=(Handle<S> that) const {
    return !operator==(that);
  }

  template <class S> static inline Handle<T> Cast(Handle<S> that) {





    return Handle<T>(T::Cast(*that));
  }

  template <class S> inline Handle<S> As() {
    return Handle<S>::Cast(*this);
  }

 private:
  T* val_;
};
# 268 "/usr/include/nodejs/v8.h" 3 4
template <class T> class Local : public Handle<T> {
 public:
  inline Local();
  template <class S> inline Local(Local<S> that)
      : Handle<T>(reinterpret_cast<T*>(*that)) {





    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }
  template <class S> inline Local(S* that) : Handle<T>(that) { }
  template <class S> static inline Local<T> Cast(Local<S> that) {





    return Local<T>(T::Cast(*that));
  }

  template <class S> inline Local<S> As() {
    return Local<S>::Cast(*this);
  }





  inline static Local<T> New(Handle<T> that);
};
# 319 "/usr/include/nodejs/v8.h" 3 4
template <class T> class Persistent : public Handle<T> {
 public:




  inline Persistent();
# 338 "/usr/include/nodejs/v8.h" 3 4
  template <class S> inline Persistent(Persistent<S> that)
      : Handle<T>(reinterpret_cast<T*>(*that)) {





    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }

  template <class S> inline Persistent(S* that) : Handle<T>(that) { }





  template <class S> explicit inline Persistent(Handle<S> that)
      : Handle<T>(*that) { }

  template <class S> static inline Persistent<T> Cast(Persistent<S> that) {





    return Persistent<T>(T::Cast(*that));
  }

  template <class S> inline Persistent<S> As() {
    return Persistent<S>::Cast(*this);
  }





  inline static Persistent<T> New(Handle<T> that);







  inline void Dispose();







  inline void MakeWeak(void* parameters, WeakReferenceCallback callback);


  inline void ClearWeak();
# 402 "/usr/include/nodejs/v8.h" 3 4
  inline void MarkIndependent();




  inline bool IsNearDeath() const;




  inline bool IsWeak() const;





  inline void SetWrapperClassId(uint16_t class_id);

 private:
  friend class ImplementationUtilities;
  friend class ObjectTemplate;
};
# 440 "/usr/include/nodejs/v8.h" 3 4
class HandleScope {
 public:
  HandleScope();

  ~HandleScope();





  template <class T> Local<T> Close(Handle<T> value);




  static int NumberOfHandles();




  static internal::Object** CreateHandle(internal::Object* value);

  static internal::Object** CreateHandle(internal::HeapObject* value);

 private:


  HandleScope(const HandleScope&);
  void operator=(const HandleScope&);
  void* operator new(size_t size);
  void operator delete(void*, size_t);



  class Data {
   public:
    internal::Object** next;
    internal::Object** limit;
    int level;
    inline void Initialize() {
      next = limit = __null;
      level = 0;
    }
  };

  void Leave();

  internal::Isolate* isolate_;
  internal::Object** prev_next_;
  internal::Object** prev_limit_;



  bool is_closed_;
  internal::Object** RawClose(internal::Object** value);

  friend class ImplementationUtilities;
};
# 506 "/usr/include/nodejs/v8.h" 3 4
class Data {
 private:
  Data();
};
# 518 "/usr/include/nodejs/v8.h" 3 4
class ScriptData {
 public:
  virtual ~ScriptData() { }







  static ScriptData* PreCompile(const char* input, int length);
# 538 "/usr/include/nodejs/v8.h" 3 4
  static ScriptData* PreCompile(Handle<String> source);
# 547 "/usr/include/nodejs/v8.h" 3 4
  static ScriptData* New(const char* data, int length);




  virtual int Length() = 0;





  virtual const char* Data() = 0;




  virtual bool HasError() = 0;
};





class ScriptOrigin {
 public:
  inline ScriptOrigin(
      Handle<Value> resource_name,
      Handle<Integer> resource_line_offset = Handle<Integer>(),
      Handle<Integer> resource_column_offset = Handle<Integer>())
      : resource_name_(resource_name),
        resource_line_offset_(resource_line_offset),
        resource_column_offset_(resource_column_offset) { }
  inline Handle<Value> ResourceName() const;
  inline Handle<Integer> ResourceLineOffset() const;
  inline Handle<Integer> ResourceColumnOffset() const;
 private:
  Handle<Value> resource_name_;
  Handle<Integer> resource_line_offset_;
  Handle<Integer> resource_column_offset_;
};





class Script {
 public:
# 609 "/usr/include/nodejs/v8.h" 3 4
  static Local<Script> New(Handle<String> source,
                           ScriptOrigin* origin = __null,
                           ScriptData* pre_data = __null,
                           Handle<String> script_data = Handle<String>());
# 624 "/usr/include/nodejs/v8.h" 3 4
  static Local<Script> New(Handle<String> source,
                           Handle<Value> file_name);
# 643 "/usr/include/nodejs/v8.h" 3 4
  static Local<Script> Compile(Handle<String> source,
                               ScriptOrigin* origin = __null,
                               ScriptData* pre_data = __null,
                               Handle<String> script_data = Handle<String>());
# 661 "/usr/include/nodejs/v8.h" 3 4
  static Local<Script> Compile(Handle<String> source,
                               Handle<Value> file_name,
                               Handle<String> script_data = Handle<String>());
# 672 "/usr/include/nodejs/v8.h" 3 4
  Local<Value> Run();




  Local<Value> Id();






  void SetData(Handle<String> data);
};





class Message {
 public:
  Local<String> Get() const;
  Local<String> GetSourceLine() const;





  Handle<Value> GetScriptResourceName() const;





  Handle<Value> GetScriptData() const;






  Handle<StackTrace> GetStackTrace() const;




  int GetLineNumber() const;





  int GetStartPosition() const;





  int GetEndPosition() const;





  int GetStartColumn() const;





  int GetEndColumn() const;


  static void PrintCurrentStackTrace(FILE* out);

  static const int kNoLineNumberInfo = 0;
  static const int kNoColumnInfo = 0;
};







class StackTrace {
 public:




  enum StackTraceOptions {
    kLineNumber = 1,
    kColumnOffset = 1 << 1 | kLineNumber,
    kScriptName = 1 << 2,
    kFunctionName = 1 << 3,
    kIsEval = 1 << 4,
    kIsConstructor = 1 << 5,
    kScriptNameOrSourceURL = 1 << 6,
    kOverview = kLineNumber | kColumnOffset | kScriptName | kFunctionName,
    kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
  };




  Local<StackFrame> GetFrame(uint32_t index) const;




  int GetFrameCount() const;




  Local<Array> AsArray();
# 797 "/usr/include/nodejs/v8.h" 3 4
  static Local<StackTrace> CurrentStackTrace(
      int frame_limit,
      StackTraceOptions options = kOverview);
};





class StackFrame {
 public:






  int GetLineNumber() const;
# 823 "/usr/include/nodejs/v8.h" 3 4
  int GetColumn() const;





  Local<String> GetScriptName() const;






  Local<String> GetScriptNameOrSourceURL() const;




  Local<String> GetFunctionName() const;





  bool IsEval() const;





  bool IsConstructor() const;
};
# 863 "/usr/include/nodejs/v8.h" 3 4
class Value : public Data {
 public:




  inline bool IsUndefined() const;





  inline bool IsNull() const;




  bool IsTrue() const;




  bool IsFalse() const;





  inline bool IsString() const;




  bool IsFunction() const;




  bool IsArray() const;




  bool IsObject() const;




  bool IsBoolean() const;




  bool IsNumber() const;




  bool IsExternal() const;




  bool IsInt32() const;




  bool IsUint32() const;




  bool IsDate() const;




  bool IsBooleanObject() const;




  bool IsNumberObject() const;




  bool IsStringObject() const;




  bool IsNativeError() const;




  bool IsRegExp() const;

  Local<Boolean> ToBoolean() const;
  Local<Number> ToNumber() const;
  Local<String> ToString() const;
  Local<String> ToDetailString() const;
  Local<Object> ToObject() const;
  Local<Integer> ToInteger() const;
  Local<Uint32> ToUint32() const;
  Local<Int32> ToInt32() const;





  Local<Uint32> ToArrayIndex() const;

  bool BooleanValue() const;
  double NumberValue() const;
  int64_t IntegerValue() const;
  uint32_t Uint32Value() const;
  int32_t Int32Value() const;


  bool Equals(Handle<Value> that) const;
  bool StrictEquals(Handle<Value> that) const;

 private:
  inline bool QuickIsUndefined() const;
  inline bool QuickIsNull() const;
  inline bool QuickIsString() const;
  bool FullIsUndefined() const;
  bool FullIsNull() const;
  bool FullIsString() const;
};





class Primitive : public Value { };






class Boolean : public Primitive {
 public:
  bool Value() const;
  static inline Handle<Boolean> New(bool value);
};





class String : public Primitive {
 public:



  int Length() const;





  int Utf8Length() const;







  bool MayContainNonAscii() const;
# 1064 "/usr/include/nodejs/v8.h" 3 4
  enum WriteOptions {
    NO_OPTIONS = 0,
    HINT_MANY_WRITES_EXPECTED = 1,
    NO_NULL_TERMINATION = 2
  };


  int Write(uint16_t* buffer,
                     int start = 0,
                     int length = -1,
                     int options = NO_OPTIONS) const;

  int WriteAscii(char* buffer,
                          int start = 0,
                          int length = -1,
                          int options = NO_OPTIONS) const;

  int WriteUtf8(char* buffer,
                         int length = -1,
                         int* nchars_ref = __null,
                         int options = NO_OPTIONS) const;




  static v8::Local<v8::String> Empty();
  inline static v8::Local<v8::String> Empty(Isolate* isolate);




  bool IsExternal() const;




  bool IsExternalAscii() const;

  class ExternalStringResourceBase {
   public:
    virtual ~ExternalStringResourceBase() {}

   protected:
    ExternalStringResourceBase() {}







    virtual void Dispose() { delete this; }

   private:

    ExternalStringResourceBase(const ExternalStringResourceBase&);
    void operator=(const ExternalStringResourceBase&);

    friend class v8::internal::Heap;
  };







  class ExternalStringResource
      : public ExternalStringResourceBase {
   public:




    virtual ~ExternalStringResource() {}




    virtual const uint16_t* data() const = 0;




    virtual size_t length() const = 0;

   protected:
    ExternalStringResource() {}
  };
# 1165 "/usr/include/nodejs/v8.h" 3 4
  class ExternalAsciiStringResource
      : public ExternalStringResourceBase {
   public:




    virtual ~ExternalAsciiStringResource() {}

    virtual const char* data() const = 0;

    virtual size_t length() const = 0;
   protected:
    ExternalAsciiStringResource() {}
  };





  inline ExternalStringResource* GetExternalStringResource() const;





  const ExternalAsciiStringResource* GetExternalAsciiStringResource()
      const;

  static inline String* Cast(v8::Value* obj);
# 1205 "/usr/include/nodejs/v8.h" 3 4
  static Local<String> New(const char* data, int length = -1);


  static Local<String> New(const uint16_t* data, int length = -1);


  static Local<String> NewSymbol(const char* data, int length = -1);





  static Local<String> Concat(Handle<String> left,
                                       Handle<String> right);
# 1228 "/usr/include/nodejs/v8.h" 3 4
  static Local<String> NewExternal(ExternalStringResource* resource);
# 1239 "/usr/include/nodejs/v8.h" 3 4
  bool MakeExternal(ExternalStringResource* resource);
# 1248 "/usr/include/nodejs/v8.h" 3 4
      static Local<String> NewExternal(
      ExternalAsciiStringResource* resource);
# 1260 "/usr/include/nodejs/v8.h" 3 4
  bool MakeExternal(ExternalAsciiStringResource* resource);




  bool CanMakeExternal();


  static Local<String> NewUndetectable(const char* data,
                                                int length = -1);


  static Local<String> NewUndetectable(const uint16_t* data,
                                                int length = -1);
# 1282 "/usr/include/nodejs/v8.h" 3 4
  class Utf8Value {
   public:
    explicit Utf8Value(Handle<v8::Value> obj);
    ~Utf8Value();
    char* operator*() { return str_; }
    const char* operator*() const { return str_; }
    int length() const { return length_; }
   private:
    char* str_;
    int length_;


    Utf8Value(const Utf8Value&);
    void operator=(const Utf8Value&);
  };
# 1305 "/usr/include/nodejs/v8.h" 3 4
  class AsciiValue {
   public:
    explicit AsciiValue(Handle<v8::Value> obj);
    ~AsciiValue();
    char* operator*() { return str_; }
    const char* operator*() const { return str_; }
    int length() const { return length_; }
   private:
    char* str_;
    int length_;


    AsciiValue(const AsciiValue&);
    void operator=(const AsciiValue&);
  };







  class Value {
   public:
    explicit Value(Handle<v8::Value> obj);
    ~Value();
    uint16_t* operator*() { return str_; }
    const uint16_t* operator*() const { return str_; }
    int length() const { return length_; }
   private:
    uint16_t* str_;
    int length_;


    Value(const Value&);
    void operator=(const Value&);
  };

 private:
  void VerifyExternalStringResource(ExternalStringResource* val) const;
  static void CheckCast(v8::Value* obj);
};





class Number : public Primitive {
 public:
  double Value() const;
  static Local<Number> New(double value);
  static inline Number* Cast(v8::Value* obj);
 private:
  Number();
  static void CheckCast(v8::Value* obj);
};





class Integer : public Number {
 public:
  static Local<Integer> New(int32_t value);
  static Local<Integer> NewFromUnsigned(uint32_t value);
  int64_t Value() const;
  static inline Integer* Cast(v8::Value* obj);
 private:
  Integer();
  static void CheckCast(v8::Value* obj);
};





class Int32 : public Integer {
 public:
  int32_t Value() const;
 private:
  Int32();
};





class Uint32 : public Integer {
 public:
  uint32_t Value() const;
 private:
  Uint32();
};


enum PropertyAttribute {
  None = 0,
  ReadOnly = 1 << 0,
  DontEnum = 1 << 1,
  DontDelete = 1 << 2
};

enum ExternalArrayType {
  kExternalByteArray = 1,
  kExternalUnsignedByteArray,
  kExternalShortArray,
  kExternalUnsignedShortArray,
  kExternalIntArray,
  kExternalUnsignedIntArray,
  kExternalFloatArray,
  kExternalDoubleArray,
  kExternalPixelArray
};






typedef Handle<Value> (*AccessorGetter)(Local<String> property,
                                        const AccessorInfo& info);


typedef void (*AccessorSetter)(Local<String> property,
                               Local<Value> value,
                               const AccessorInfo& info);
# 1446 "/usr/include/nodejs/v8.h" 3 4
enum AccessControl {
  DEFAULT = 0,
  ALL_CAN_READ = 1,
  ALL_CAN_WRITE = 1 << 1,
  PROHIBITS_OVERWRITING = 1 << 2
};





class Object : public Value {
 public:
  bool Set(Handle<Value> key,
                    Handle<Value> value,
                    PropertyAttribute attribs = None);

  bool Set(uint32_t index,
                    Handle<Value> value);
# 1474 "/usr/include/nodejs/v8.h" 3 4
  bool ForceSet(Handle<Value> key,
                         Handle<Value> value,
                         PropertyAttribute attribs = None);

  Local<Value> Get(Handle<Value> key);

  Local<Value> Get(uint32_t index);






  PropertyAttribute GetPropertyAttributes(Handle<Value> key);



  bool Has(Handle<String> key);

  bool Delete(Handle<String> key);



  bool ForceDelete(Handle<Value> key);

  bool Has(uint32_t index);

  bool Delete(uint32_t index);

  bool SetAccessor(Handle<String> name,
                            AccessorGetter getter,
                            AccessorSetter setter = 0,
                            Handle<Value> data = Handle<Value>(),
                            AccessControl settings = DEFAULT,
                            PropertyAttribute attribute = None);







  Local<Array> GetPropertyNames();






  Local<Array> GetOwnPropertyNames();






  Local<Value> GetPrototype();






  bool SetPrototype(Handle<Value> prototype);





  Local<Object> FindInstanceInPrototypeChain(
      Handle<FunctionTemplate> tmpl);






  Local<String> ObjectProtoToString();




  Local<String> GetConstructorName();


  int InternalFieldCount();

  inline Local<Value> GetInternalField(int index);

  void SetInternalField(int index, Handle<Value> value);


  inline void* GetPointerFromInternalField(int index);


  void SetPointerInInternalField(int index, void* value);


  bool HasOwnProperty(Handle<String> key);
  bool HasRealNamedProperty(Handle<String> key);
  bool HasRealIndexedProperty(uint32_t index);
  bool HasRealNamedCallbackProperty(Handle<String> key);





  Local<Value> GetRealNamedPropertyInPrototypeChain(
      Handle<String> key);






  Local<Value> GetRealNamedProperty(Handle<String> key);


  bool HasNamedLookupInterceptor();


  bool HasIndexedLookupInterceptor();






  void TurnOnAccessCheck();
# 1611 "/usr/include/nodejs/v8.h" 3 4
  int GetIdentityHash();







  bool SetHiddenValue(Handle<String> key, Handle<Value> value);
  Local<Value> GetHiddenValue(Handle<String> key);
  bool DeleteHiddenValue(Handle<String> key);
# 1630 "/usr/include/nodejs/v8.h" 3 4
  bool IsDirty();





  Local<Object> Clone();




  Local<Context> CreationContext();
# 1650 "/usr/include/nodejs/v8.h" 3 4
  void SetIndexedPropertiesToPixelData(uint8_t* data, int length);
  bool HasIndexedPropertiesInPixelData();
  uint8_t* GetIndexedPropertiesPixelData();
  int GetIndexedPropertiesPixelDataLength();
# 1662 "/usr/include/nodejs/v8.h" 3 4
  void SetIndexedPropertiesToExternalArrayData(
      void* data,
      ExternalArrayType array_type,
      int number_of_elements);
  bool HasIndexedPropertiesInExternalArrayData();
  void* GetIndexedPropertiesExternalArrayData();
  ExternalArrayType GetIndexedPropertiesExternalArrayDataType();
  int GetIndexedPropertiesExternalArrayDataLength();






  bool IsCallable();





  Local<Value> CallAsFunction(Handle<Object> recv,
                                       int argc,
                                       Handle<Value> argv[]);






  Local<Value> CallAsConstructor(int argc,
                                          Handle<Value> argv[]);

  static Local<Object> New();
  static inline Object* Cast(Value* obj);

 private:
  Object();
  static void CheckCast(Value* obj);
  Local<Value> CheckedGetInternalField(int index);
  void* SlowGetPointerFromInternalField(int index);





  inline Local<Value> UncheckedGetInternalField(int index);
};





class Array : public Object {
 public:
  uint32_t Length() const;





  Local<Object> CloneElementAt(uint32_t index);





  static Local<Array> New(int length = 0);

  static inline Array* Cast(Value* obj);
 private:
  Array();
  static void CheckCast(Value* obj);
};





class Function : public Object {
 public:
  Local<Object> NewInstance() const;
  Local<Object> NewInstance(int argc, Handle<Value> argv[]) const;
  Local<Value> Call(Handle<Object> recv,
                             int argc,
                             Handle<Value> argv[]);
  void SetName(Handle<String> name);
  Handle<Value> GetName() const;







  Handle<Value> GetInferredName() const;





  int GetScriptLineNumber() const;




  int GetScriptColumnNumber() const;
  Handle<Value> GetScriptId() const;
  ScriptOrigin GetScriptOrigin() const;
  static inline Function* Cast(Value* obj);
  static const int kLineOffsetNotFound;

 private:
  Function();
  static void CheckCast(Value* obj);
};





class Date : public Object {
 public:
  static Local<Value> New(double time);





  double NumberValue() const;

  static inline Date* Cast(v8::Value* obj);
# 1806 "/usr/include/nodejs/v8.h" 3 4
  static void DateTimeConfigurationChangeNotification();

 private:
  static void CheckCast(v8::Value* obj);
};





class NumberObject : public Object {
 public:
  static Local<Value> New(double value);




  double NumberValue() const;

  static inline NumberObject* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};





class BooleanObject : public Object {
 public:
  static Local<Value> New(bool value);




  bool BooleanValue() const;

  static inline BooleanObject* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};





class StringObject : public Object {
 public:
  static Local<Value> New(Handle<String> value);




  Local<String> StringValue() const;

  static inline StringObject* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};





class RegExp : public Object {
 public:




  enum Flags {
    kNone = 0,
    kGlobal = 1,
    kIgnoreCase = 2,
    kMultiline = 4
  };
# 1896 "/usr/include/nodejs/v8.h" 3 4
  static Local<RegExp> New(Handle<String> pattern,
                                    Flags flags);





  Local<String> GetSource() const;




  Flags GetFlags() const;

  static inline RegExp* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};
# 1928 "/usr/include/nodejs/v8.h" 3 4
class External : public Value {
 public:
  static Local<Value> Wrap(void* data);
  static inline void* Unwrap(Handle<Value> obj);

  static Local<External> New(void* value);
  static inline External* Cast(Value* obj);
  void* Value() const;
 private:
  External();
  static void CheckCast(v8::Value* obj);
  static inline void* QuickUnwrap(Handle<v8::Value> obj);
  static void* FullUnwrap(Handle<v8::Value> obj);
};
# 1950 "/usr/include/nodejs/v8.h" 3 4
class Template : public Data {
 public:

  void Set(Handle<String> name, Handle<Data> value,
           PropertyAttribute attributes = None);
  inline void Set(const char* name, Handle<Data> value);
 private:
  Template();

  friend class ObjectTemplate;
  friend class FunctionTemplate;
};
# 1970 "/usr/include/nodejs/v8.h" 3 4
class Arguments {
 public:
  inline int Length() const;
  inline Local<Value> operator[](int i) const;
  inline Local<Function> Callee() const;
  inline Local<Object> This() const;
  inline Local<Object> Holder() const;
  inline bool IsConstructCall() const;
  inline Local<Value> Data() const;
  inline Isolate* GetIsolate() const;

 private:
  static const int kIsolateIndex = 0;
  static const int kDataIndex = -1;
  static const int kCalleeIndex = -2;
  static const int kHolderIndex = -3;

  friend class ImplementationUtilities;
  inline Arguments(internal::Object** implicit_args,
                   internal::Object** values,
                   int length,
                   bool is_construct_call);
  internal::Object** implicit_args_;
  internal::Object** values_;
  int length_;
  bool is_construct_call_;
};






class AccessorInfo {
 public:
  inline AccessorInfo(internal::Object** args)
      : args_(args) { }
  inline Isolate* GetIsolate() const;
  inline Local<Value> Data() const;
  inline Local<Object> This() const;
  inline Local<Object> Holder() const;

 private:
  internal::Object** args_;
};


typedef Handle<Value> (*InvocationCallback)(const Arguments& args);





typedef Handle<Value> (*NamedPropertyGetter)(Local<String> property,
                                             const AccessorInfo& info);






typedef Handle<Value> (*NamedPropertySetter)(Local<String> property,
                                             Local<Value> value,
                                             const AccessorInfo& info);






typedef Handle<Integer> (*NamedPropertyQuery)(Local<String> property,
                                              const AccessorInfo& info);







typedef Handle<Boolean> (*NamedPropertyDeleter)(Local<String> property,
                                                const AccessorInfo& info);





typedef Handle<Array> (*NamedPropertyEnumerator)(const AccessorInfo& info);






typedef Handle<Value> (*IndexedPropertyGetter)(uint32_t index,
                                               const AccessorInfo& info);






typedef Handle<Value> (*IndexedPropertySetter)(uint32_t index,
                                               Local<Value> value,
                                               const AccessorInfo& info);






typedef Handle<Integer> (*IndexedPropertyQuery)(uint32_t index,
                                                const AccessorInfo& info);






typedef Handle<Boolean> (*IndexedPropertyDeleter)(uint32_t index,
                                                  const AccessorInfo& info);





typedef Handle<Array> (*IndexedPropertyEnumerator)(const AccessorInfo& info);





enum AccessType {
  ACCESS_GET,
  ACCESS_SET,
  ACCESS_HAS,
  ACCESS_DELETE,
  ACCESS_KEYS
};






typedef bool (*NamedSecurityCallback)(Local<Object> host,
                                      Local<Value> key,
                                      AccessType type,
                                      Local<Value> data);






typedef bool (*IndexedSecurityCallback)(Local<Object> host,
                                        uint32_t index,
                                        AccessType type,
                                        Local<Value> data);
# 2222 "/usr/include/nodejs/v8.h" 3 4
class FunctionTemplate : public Template {
 public:

  static Local<FunctionTemplate> New(
      InvocationCallback callback = 0,
      Handle<Value> data = Handle<Value>(),
      Handle<Signature> signature = Handle<Signature>());

  Local<Function> GetFunction();






  void SetCallHandler(InvocationCallback callback,
                      Handle<Value> data = Handle<Value>());


  Local<ObjectTemplate> InstanceTemplate();


  void Inherit(Handle<FunctionTemplate> parent);





  Local<ObjectTemplate> PrototypeTemplate();







  void SetClassName(Handle<String> name);
# 2272 "/usr/include/nodejs/v8.h" 3 4
  void SetHiddenPrototype(bool value);





  void ReadOnlyPrototype();





  bool HasInstance(Handle<Value> object);

 private:
  FunctionTemplate();
  void AddInstancePropertyAccessor(Handle<String> name,
                                   AccessorGetter getter,
                                   AccessorSetter setter,
                                   Handle<Value> data,
                                   AccessControl settings,
                                   PropertyAttribute attributes,
                                   Handle<AccessorSignature> signature);
  void SetNamedInstancePropertyHandler(NamedPropertyGetter getter,
                                       NamedPropertySetter setter,
                                       NamedPropertyQuery query,
                                       NamedPropertyDeleter remover,
                                       NamedPropertyEnumerator enumerator,
                                       Handle<Value> data);
  void SetIndexedInstancePropertyHandler(IndexedPropertyGetter getter,
                                         IndexedPropertySetter setter,
                                         IndexedPropertyQuery query,
                                         IndexedPropertyDeleter remover,
                                         IndexedPropertyEnumerator enumerator,
                                         Handle<Value> data);
  void SetInstanceCallAsFunctionHandler(InvocationCallback callback,
                                        Handle<Value> data);

  friend class Context;
  friend class ObjectTemplate;
};
# 2321 "/usr/include/nodejs/v8.h" 3 4
class ObjectTemplate : public Template {
 public:

  static Local<ObjectTemplate> New();


  Local<Object> NewInstance();
# 2358 "/usr/include/nodejs/v8.h" 3 4
  void SetAccessor(Handle<String> name,
                   AccessorGetter getter,
                   AccessorSetter setter = 0,
                   Handle<Value> data = Handle<Value>(),
                   AccessControl settings = DEFAULT,
                   PropertyAttribute attribute = None,
                   Handle<AccessorSignature> signature =
                       Handle<AccessorSignature>());
# 2384 "/usr/include/nodejs/v8.h" 3 4
  void SetNamedPropertyHandler(NamedPropertyGetter getter,
                               NamedPropertySetter setter = 0,
                               NamedPropertyQuery query = 0,
                               NamedPropertyDeleter deleter = 0,
                               NamedPropertyEnumerator enumerator = 0,
                               Handle<Value> data = Handle<Value>());
# 2407 "/usr/include/nodejs/v8.h" 3 4
  void SetIndexedPropertyHandler(IndexedPropertyGetter getter,
                                 IndexedPropertySetter setter = 0,
                                 IndexedPropertyQuery query = 0,
                                 IndexedPropertyDeleter deleter = 0,
                                 IndexedPropertyEnumerator enumerator = 0,
                                 Handle<Value> data = Handle<Value>());







  void SetCallAsFunctionHandler(InvocationCallback callback,
                                Handle<Value> data = Handle<Value>());
# 2431 "/usr/include/nodejs/v8.h" 3 4
  void MarkAsUndetectable();
# 2444 "/usr/include/nodejs/v8.h" 3 4
  void SetAccessCheckCallbacks(NamedSecurityCallback named_handler,
                               IndexedSecurityCallback indexed_handler,
                               Handle<Value> data = Handle<Value>(),
                               bool turned_on_by_default = true);





  int InternalFieldCount();





  void SetInternalFieldCount(int value);

 private:
  ObjectTemplate();
  static Local<ObjectTemplate> New(Handle<FunctionTemplate> constructor);
  friend class FunctionTemplate;
};






class Signature : public Data {
 public:
  static Local<Signature> New(Handle<FunctionTemplate> receiver =
                                  Handle<FunctionTemplate>(),
                              int argc = 0,
                              Handle<FunctionTemplate> argv[] = 0);
 private:
  Signature();
};






class AccessorSignature : public Data {
 public:
  static Local<AccessorSignature> New(Handle<FunctionTemplate> receiver =
                                          Handle<FunctionTemplate>());
 private:
  AccessorSignature();
};






class TypeSwitch : public Data {
 public:
  static Local<TypeSwitch> New(Handle<FunctionTemplate> type);
  static Local<TypeSwitch> New(int argc, Handle<FunctionTemplate> types[]);
  int match(Handle<Value> value);
 private:
  TypeSwitch();
};




class ExternalAsciiStringResourceImpl
    : public String::ExternalAsciiStringResource {
 public:
  ExternalAsciiStringResourceImpl() : data_(0), length_(0) {}
  ExternalAsciiStringResourceImpl(const char* data, size_t length)
      : data_(data), length_(length) {}
  const char* data() const { return data_; }
  size_t length() const { return length_; }

 private:
  const char* data_;
  size_t length_;
};




class Extension {
 public:


  Extension(const char* name,
            const char* source = 0,
            int dep_count = 0,
            const char** deps = 0,
            int source_length = -1);
  virtual ~Extension() { }
  virtual v8::Handle<v8::FunctionTemplate>
      GetNativeFunction(v8::Handle<v8::String> name) {
    return v8::Handle<v8::FunctionTemplate>();
  }

  const char* name() const { return name_; }
  size_t source_length() const { return source_length_; }
  const String::ExternalAsciiStringResource* source() const {
    return &source_; }
  int dependency_count() { return dep_count_; }
  const char** dependencies() { return deps_; }
  void set_auto_enable(bool value) { auto_enable_ = value; }
  bool auto_enable() { return auto_enable_; }

 private:
  const char* name_;
  size_t source_length_;
  ExternalAsciiStringResourceImpl source_;
  int dep_count_;
  const char** deps_;
  bool auto_enable_;


  Extension(const Extension&);
  void operator=(const Extension&);
};


void RegisterExtension(Extension* extension);





class DeclareExtension {
 public:
  inline DeclareExtension(Extension* extension) {
    RegisterExtension(extension);
  }
};





Handle<Primitive> Undefined();
Handle<Primitive> Null();
Handle<Boolean> True();
Handle<Boolean> False();

inline Handle<Primitive> Undefined(Isolate* isolate);
inline Handle<Primitive> Null(Isolate* isolate);
inline Handle<Boolean> True(Isolate* isolate);
inline Handle<Boolean> False(Isolate* isolate);
# 2604 "/usr/include/nodejs/v8.h" 3 4
class ResourceConstraints {
 public:
  ResourceConstraints();
  int max_young_space_size() const { return max_young_space_size_; }
  void set_max_young_space_size(int value) { max_young_space_size_ = value; }
  int max_old_space_size() const { return max_old_space_size_; }
  void set_max_old_space_size(int value) { max_old_space_size_ = value; }
  int max_executable_size() { return max_executable_size_; }
  void set_max_executable_size(int value) { max_executable_size_ = value; }
  uint32_t* stack_limit() const { return stack_limit_; }

  void set_stack_limit(uint32_t* value) { stack_limit_ = value; }
 private:
  int max_young_space_size_;
  int max_old_space_size_;
  int max_executable_size_;
  uint32_t* stack_limit_;
};


bool SetResourceConstraints(ResourceConstraints* constraints);





typedef void (*FatalErrorCallback)(const char* location, const char* message);


typedef void (*MessageCallback)(Handle<Message> message, Handle<Value> data);
# 2642 "/usr/include/nodejs/v8.h" 3 4
Handle<Value> ThrowException(Handle<Value> exception);





class Exception {
 public:
  static Local<Value> RangeError(Handle<String> message);
  static Local<Value> ReferenceError(Handle<String> message);
  static Local<Value> SyntaxError(Handle<String> message);
  static Local<Value> TypeError(Handle<String> message);
  static Local<Value> Error(Handle<String> message);
};




typedef int* (*CounterLookupCallback)(const char* name);

typedef void* (*CreateHistogramCallback)(const char* name,
                                         int min,
                                         int max,
                                         size_t buckets);

typedef void (*AddHistogramSampleCallback)(void* histogram, int sample);


  enum ObjectSpace {
    kObjectSpaceNewSpace = 1 << 0,
    kObjectSpaceOldPointerSpace = 1 << 1,
    kObjectSpaceOldDataSpace = 1 << 2,
    kObjectSpaceCodeSpace = 1 << 3,
    kObjectSpaceMapSpace = 1 << 4,
    kObjectSpaceLoSpace = 1 << 5,

    kObjectSpaceAll = kObjectSpaceNewSpace | kObjectSpaceOldPointerSpace |
      kObjectSpaceOldDataSpace | kObjectSpaceCodeSpace | kObjectSpaceMapSpace |
      kObjectSpaceLoSpace
  };

  enum AllocationAction {
    kAllocationActionAllocate = 1 << 0,
    kAllocationActionFree = 1 << 1,
    kAllocationActionAll = kAllocationActionAllocate | kAllocationActionFree
  };

typedef void (*MemoryAllocationCallback)(ObjectSpace space,
                                         AllocationAction action,
                                         int size);


typedef void (*CallCompletedCallback)();


typedef void (*FailedAccessCheckCallback)(Local<Object> target,
                                          AccessType type,
                                          Local<Value> data);







typedef bool (*AllowCodeGenerationFromStringsCallback)(Local<Context> context);
# 2718 "/usr/include/nodejs/v8.h" 3 4
enum GCType {
  kGCTypeScavenge = 1 << 0,
  kGCTypeMarkSweepCompact = 1 << 1,
  kGCTypeAll = kGCTypeScavenge | kGCTypeMarkSweepCompact
};

enum GCCallbackFlags {
  kNoGCCallbackFlags = 0,
  kGCCallbackFlagCompacted = 1 << 0
};

typedef void (*GCPrologueCallback)(GCType type, GCCallbackFlags flags);
typedef void (*GCEpilogueCallback)(GCType type, GCCallbackFlags flags);

typedef void (*GCCallback)();
# 2741 "/usr/include/nodejs/v8.h" 3 4
class HeapStatistics {
 public:
  HeapStatistics();
  size_t total_heap_size() { return total_heap_size_; }
  size_t total_heap_size_executable() { return total_heap_size_executable_; }
  size_t used_heap_size() { return used_heap_size_; }
  size_t heap_size_limit() { return heap_size_limit_; }

 private:
  void set_total_heap_size(size_t size) { total_heap_size_ = size; }
  void set_total_heap_size_executable(size_t size) {
    total_heap_size_executable_ = size;
  }
  void set_used_heap_size(size_t size) { used_heap_size_ = size; }
  void set_heap_size_limit(size_t size) { heap_size_limit_ = size; }

  size_t total_heap_size_;
  size_t total_heap_size_executable_;
  size_t used_heap_size_;
  size_t heap_size_limit_;

  friend class V8;
};


class RetainedObjectInfo;
# 2777 "/usr/include/nodejs/v8.h" 3 4
class Isolate {
 public:




  class Scope {
   public:
    explicit Scope(Isolate* isolate) : isolate_(isolate) {
      isolate->Enter();
    }

    ~Scope() { isolate_->Exit(); }

   private:
    Isolate* const isolate_;


    Scope(const Scope&);
    Scope& operator=(const Scope&);
  };
# 2806 "/usr/include/nodejs/v8.h" 3 4
  static Isolate* New();





  static Isolate* GetCurrent();
# 2824 "/usr/include/nodejs/v8.h" 3 4
  void Enter();
# 2833 "/usr/include/nodejs/v8.h" 3 4
  void Exit();





  void Dispose();




  inline void SetData(void* data);





  inline void* GetData();

 private:
  Isolate();
  Isolate(const Isolate&);
  ~Isolate();
  Isolate& operator=(const Isolate&);
  void* operator new(size_t size);
  void operator delete(void*, size_t);
};


class StartupData {
 public:
  enum CompressionAlgorithm {
    kUncompressed,
    kBZip2
  };

  const char* data;
  int compressed_size;
  int raw_size;
};
# 2883 "/usr/include/nodejs/v8.h" 3 4
class StartupDataDecompressor {
 public:
  StartupDataDecompressor();
  virtual ~StartupDataDecompressor();
  int Decompress();

 protected:
  virtual int DecompressData(char* raw_data,
                             int* raw_data_size,
                             const char* compressed_data,
                             int compressed_data_size) = 0;

 private:
  char** raw_data;
};






typedef bool (*EntropySource)(unsigned char* buffer, size_t length);
# 2917 "/usr/include/nodejs/v8.h" 3 4
typedef uintptr_t (*ReturnAddressLocationResolver)(
    uintptr_t return_addr_location);





class ExternalResourceVisitor {
 public:
  virtual ~ExternalResourceVisitor() {}
  virtual void VisitExternalString(Handle<String> string) {}
};





class V8 {
 public:

  static void SetFatalErrorHandler(FatalErrorCallback that);





  static void SetAllowCodeGenerationFromStringsCallback(
      AllowCodeGenerationFromStringsCallback that);
# 2958 "/usr/include/nodejs/v8.h" 3 4
  static void IgnoreOutOfMemoryException();





  static bool IsDead();
# 2985 "/usr/include/nodejs/v8.h" 3 4
  static StartupData::CompressionAlgorithm GetCompressedStartupDataAlgorithm();
  static int GetCompressedStartupDataCount();
  static void GetCompressedStartupData(StartupData* compressed_data);
  static void SetDecompressedStartupData(StartupData* decompressed_data);







  static bool AddMessageListener(MessageCallback that,
                                 Handle<Value> data = Handle<Value>());




  static void RemoveMessageListeners(MessageCallback that);





  static void SetCaptureStackTraceForUncaughtExceptions(
      bool capture,
      int frame_limit = 10,
      StackTrace::StackTraceOptions options = StackTrace::kOverview);




  static void SetFlagsFromString(const char* str, int length);




  static void SetFlagsFromCommandLine(int* argc,
                                      char** argv,
                                      bool remove_flags);


  static const char* GetVersion();





  static void SetCounterFunction(CounterLookupCallback);







  static void SetCreateHistogramFunction(CreateHistogramCallback);
  static void SetAddHistogramSampleFunction(AddHistogramSampleCallback);





  static void EnableSlidingStateWindow();


  static void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback);
# 3062 "/usr/include/nodejs/v8.h" 3 4
  static void AddGCPrologueCallback(
      GCPrologueCallback callback, GCType gc_type_filter = kGCTypeAll);





  static void RemoveGCPrologueCallback(GCPrologueCallback callback);
# 3079 "/usr/include/nodejs/v8.h" 3 4
  static void SetGlobalGCPrologueCallback(GCCallback);
# 3091 "/usr/include/nodejs/v8.h" 3 4
  static void AddGCEpilogueCallback(
      GCEpilogueCallback callback, GCType gc_type_filter = kGCTypeAll);





  static void RemoveGCEpilogueCallback(GCEpilogueCallback callback);
# 3108 "/usr/include/nodejs/v8.h" 3 4
  static void SetGlobalGCEpilogueCallback(GCCallback);





  static void AddMemoryAllocationCallback(MemoryAllocationCallback callback,
                                          ObjectSpace space,
                                          AllocationAction action);




  static void RemoveMemoryAllocationCallback(MemoryAllocationCallback callback);
# 3130 "/usr/include/nodejs/v8.h" 3 4
  static void AddCallCompletedCallback(CallCompletedCallback callback);




  static void RemoveCallCompletedCallback(CallCompletedCallback callback);
# 3146 "/usr/include/nodejs/v8.h" 3 4
  static void AddObjectGroup(Persistent<Value>* objects,
                             size_t length,
                             RetainedObjectInfo* info = __null);
# 3157 "/usr/include/nodejs/v8.h" 3 4
  static void AddImplicitReferences(Persistent<Object> parent,
                                    Persistent<Value>* children,
                                    size_t length);






  static bool Initialize();





  static void SetEntropySource(EntropySource source);





  static void SetReturnAddressLocationResolver(
      ReturnAddressLocationResolver return_address_resolver);
# 3195 "/usr/include/nodejs/v8.h" 3 4
  static intptr_t AdjustAmountOfExternalAllocatedMemory(
      intptr_t change_in_bytes);
# 3207 "/usr/include/nodejs/v8.h" 3 4
  static void PauseProfiler();





  static void ResumeProfiler();




  static bool IsProfilerPaused();







  static int GetCurrentThreadId();
# 3252 "/usr/include/nodejs/v8.h" 3 4
  static void TerminateExecution(int thread_id);
# 3264 "/usr/include/nodejs/v8.h" 3 4
  static void TerminateExecution(Isolate* isolate = __null);
# 3276 "/usr/include/nodejs/v8.h" 3 4
  static bool IsExecutionTerminating(Isolate* isolate = __null);
# 3287 "/usr/include/nodejs/v8.h" 3 4
  static bool Dispose();




  static void GetHeapStatistics(HeapStatistics* heap_statistics);






  static void VisitExternalResources(ExternalResourceVisitor* visitor);
# 3313 "/usr/include/nodejs/v8.h" 3 4
  static bool IdleNotification(int hint = 1000);





  static void LowMemoryNotification();







  static int ContextDisposedNotification();

 private:
  V8();

  static internal::Object** GlobalizeReference(internal::Object** handle);
  static void DisposeGlobal(internal::Object** global_handle);
  static void MakeWeak(internal::Object** global_handle,
                       void* data,
                       WeakReferenceCallback);
  static void ClearWeak(internal::Object** global_handle);
  static void MarkIndependent(internal::Object** global_handle);
  static bool IsGlobalNearDeath(internal::Object** global_handle);
  static bool IsGlobalWeak(internal::Object** global_handle);
  static void SetWrapperClassId(internal::Object** global_handle,
                                uint16_t class_id);

  template <class T> friend class Handle;
  template <class T> friend class Local;
  template <class T> friend class Persistent;
  friend class Context;
};





class TryCatch {
 public:



  TryCatch();




  ~TryCatch();




  bool HasCaught() const;
# 3384 "/usr/include/nodejs/v8.h" 3 4
  bool CanContinue() const;
# 3393 "/usr/include/nodejs/v8.h" 3 4
  Handle<Value> ReThrow();







  Local<Value> Exception() const;





  Local<Value> StackTrace() const;
# 3416 "/usr/include/nodejs/v8.h" 3 4
  Local<v8::Message> Message() const;
# 3427 "/usr/include/nodejs/v8.h" 3 4
  void Reset();
# 3437 "/usr/include/nodejs/v8.h" 3 4
  void SetVerbose(bool value);






  void SetCaptureMessage(bool value);

 private:
  v8::internal::Isolate* isolate_;
  void* next_;
  void* exception_;
  void* message_;
  bool is_verbose_ : 1;
  bool can_continue_ : 1;
  bool capture_message_ : 1;
  bool rethrow_ : 1;

  friend class v8::internal::Isolate;
};
# 3466 "/usr/include/nodejs/v8.h" 3 4
class ExtensionConfiguration {
 public:
  ExtensionConfiguration(int name_count, const char* names[])
      : name_count_(name_count), names_(names) { }
 private:
  friend class ImplementationUtilities;
  int name_count_;
  const char** names_;
};






class Context {
 public:
# 3499 "/usr/include/nodejs/v8.h" 3 4
  Local<Object> Global();





  void DetachGlobal();
# 3517 "/usr/include/nodejs/v8.h" 3 4
  void ReattachGlobal(Handle<Object> global_object);
# 3537 "/usr/include/nodejs/v8.h" 3 4
  static Persistent<Context> New(
      ExtensionConfiguration* extensions = __null,
      Handle<ObjectTemplate> global_template = Handle<ObjectTemplate>(),
      Handle<Value> global_object = Handle<Value>());


  static Local<Context> GetEntered();


  static Local<Context> GetCurrent();






  static Local<Context> GetCalling();





  void SetSecurityToken(Handle<Value> token);


  void UseDefaultSecurityToken();


  Handle<Value> GetSecurityToken();







  void Enter();





  void Exit();


  bool HasOutOfMemoryException();


  static bool InContext();






  void SetData(Handle<String> data);
  Local<Value> GetData();
# 3608 "/usr/include/nodejs/v8.h" 3 4
  void AllowCodeGenerationFromStrings(bool allow);





  bool IsCodeGenerationFromStringsAllowed();





  class Scope {
   public:
    explicit inline Scope(Handle<Context> context) : context_(context) {
      context_->Enter();
    }
    inline ~Scope() { context_->Exit(); }
   private:
    Handle<Context> context_;
  };

 private:
  friend class Value;
  friend class Script;
  friend class Object;
  friend class Function;
};
# 3720 "/usr/include/nodejs/v8.h" 3 4
class Unlocker {
 public:



  explicit Unlocker(Isolate* isolate = __null);
  ~Unlocker();
 private:
  internal::Isolate* isolate_;
};


class Locker {
 public:



  explicit Locker(Isolate* isolate = __null);
  ~Locker();
# 3747 "/usr/include/nodejs/v8.h" 3 4
  static void StartPreemption(int every_n_ms);




  static void StopPreemption();





  static bool IsLocked(Isolate* isolate = __null);




  static bool IsActive();

 private:
  bool has_lock_;
  bool top_level_;
  internal::Isolate* isolate_;

  static bool active_;


  Locker(const Locker&);
  void operator=(const Locker&);
};





struct HeapStatsUpdate;





class OutputStream {
 public:
  enum OutputEncoding {
    kAscii = 0
  };
  enum WriteResult {
    kContinue = 0,
    kAbort = 1
  };
  virtual ~OutputStream() {}

  virtual void EndOfStream() = 0;

  virtual int GetChunkSize() { return 1024; }

  virtual OutputEncoding GetOutputEncoding() { return kAscii; }





  virtual WriteResult WriteAsciiChunk(char* data, int size) = 0;





  virtual WriteResult WriteHeapStatsChunk(HeapStatsUpdate* data, int count) {
    return kAbort;
  };
};






class ActivityControl {
 public:
  enum ControlOption {
    kContinue = 0,
    kAbort = 1
  };
  virtual ~ActivityControl() {}




  virtual ControlOption ReportProgressValue(int done, int total) = 0;
};





namespace internal {

const int kApiPointerSize = sizeof(void*);
const int kApiIntSize = sizeof(int);


const int kHeapObjectTag = 1;
const int kHeapObjectTagSize = 2;
const intptr_t kHeapObjectTagMask = (1 << kHeapObjectTagSize) - 1;


const int kSmiTag = 0;
const int kSmiTagSize = 1;
const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;

template <size_t ptr_size> struct SmiTagging;


template <> struct SmiTagging<4> {
  static const int kSmiShiftSize = 0;
  static const int kSmiValueSize = 31;
  static inline int SmiToInt(internal::Object* value) {
    int shift_bits = kSmiTagSize + kSmiShiftSize;

    return static_cast<int>(reinterpret_cast<intptr_t>(value)) >> shift_bits;
  }



  static const uintptr_t kEncodablePointerMask = 0x1;
  static const int kPointerToSmiShift = 0;
};


template <> struct SmiTagging<8> {
  static const int kSmiShiftSize = 31;
  static const int kSmiValueSize = 32;
  static inline int SmiToInt(internal::Object* value) {
    int shift_bits = kSmiTagSize + kSmiShiftSize;

    return static_cast<int>(reinterpret_cast<intptr_t>(value) >> shift_bits);
  }





  static const int kPointerAlignment = 3;

  static const uintptr_t kEncodablePointerMask =
      ~(uintptr_t(0xffffffff) << kPointerAlignment);

  static const int kPointerToSmiShift =
      kSmiTagSize + kSmiShiftSize - kPointerAlignment;
};

typedef SmiTagging<kApiPointerSize> PlatformSmiTagging;
const int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;
const int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;
const uintptr_t kEncodablePointerMask =
    PlatformSmiTagging::kEncodablePointerMask;
const int kPointerToSmiShift = PlatformSmiTagging::kPointerToSmiShift;






class Internals {
 public:


  static const int kHeapObjectMapOffset = 0;
  static const int kMapInstanceTypeOffset = 1 * kApiPointerSize + kApiIntSize;
  static const int kStringResourceOffset = 3 * kApiPointerSize;

  static const int kOddballKindOffset = 3 * kApiPointerSize;
  static const int kForeignAddressOffset = kApiPointerSize;
  static const int kJSObjectHeaderSize = 3 * kApiPointerSize;
  static const int kFullStringRepresentationMask = 0x07;
  static const int kExternalTwoByteRepresentationTag = 0x02;

  static const int kIsolateStateOffset = 0;
  static const int kIsolateEmbedderDataOffset = 1 * kApiPointerSize;
  static const int kIsolateRootsOffset = 3 * kApiPointerSize;
  static const int kUndefinedValueRootIndex = 5;
  static const int kNullValueRootIndex = 7;
  static const int kTrueValueRootIndex = 8;
  static const int kFalseValueRootIndex = 9;
  static const int kEmptySymbolRootIndex = 128;

  static const int kJSObjectType = 0xaa;
  static const int kFirstNonstringType = 0x80;
  static const int kOddballType = 0x82;
  static const int kForeignType = 0x85;

  static const int kUndefinedOddballKind = 5;
  static const int kNullOddballKind = 3;

  static inline bool HasHeapObjectTag(internal::Object* value) {
    return ((reinterpret_cast<intptr_t>(value) & kHeapObjectTagMask) ==
            kHeapObjectTag);
  }

  static inline bool HasSmiTag(internal::Object* value) {
    return ((reinterpret_cast<intptr_t>(value) & kSmiTagMask) == kSmiTag);
  }

  static inline int SmiValue(internal::Object* value) {
    return PlatformSmiTagging::SmiToInt(value);
  }

  static inline int GetInstanceType(internal::Object* obj) {
    typedef internal::Object O;
    O* map = ReadField<O*>(obj, kHeapObjectMapOffset);
    return ReadField<uint8_t>(map, kMapInstanceTypeOffset);
  }

  static inline int GetOddballKind(internal::Object* obj) {
    typedef internal::Object O;
    return SmiValue(ReadField<O*>(obj, kOddballKindOffset));
  }

  static inline void* GetExternalPointerFromSmi(internal::Object* value) {
    const uintptr_t address = reinterpret_cast<uintptr_t>(value);
    return reinterpret_cast<void*>(address >> kPointerToSmiShift);
  }

  static inline void* GetExternalPointer(internal::Object* obj) {
    if (HasSmiTag(obj)) {
      return GetExternalPointerFromSmi(obj);
    } else if (GetInstanceType(obj) == kForeignType) {
      return ReadField<void*>(obj, kForeignAddressOffset);
    } else {
      return __null;
    }
  }

  static inline bool IsExternalTwoByteString(int instance_type) {
    int representation = (instance_type & kFullStringRepresentationMask);
    return representation == kExternalTwoByteRepresentationTag;
  }

  static inline bool IsInitialized(v8::Isolate* isolate) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) + kIsolateStateOffset;
    return *reinterpret_cast<int*>(addr) == 1;
  }

  static inline void SetEmbedderData(v8::Isolate* isolate, void* data) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) +
        kIsolateEmbedderDataOffset;
    *reinterpret_cast<void**>(addr) = data;
  }

  static inline void* GetEmbedderData(v8::Isolate* isolate) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) +
        kIsolateEmbedderDataOffset;
    return *reinterpret_cast<void**>(addr);
  }

  static inline internal::Object** GetRoot(v8::Isolate* isolate, int index) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) + kIsolateRootsOffset;
    return reinterpret_cast<internal::Object**>(addr + index * kApiPointerSize);
  }

  template <typename T>
  static inline T ReadField(Object* ptr, int offset) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(ptr) + offset - kHeapObjectTag;
    return *reinterpret_cast<T*>(addr);
  }

  static inline bool CanCastToHeapObject(void* o) { return false; }
  static inline bool CanCastToHeapObject(Context* o) { return true; }
  static inline bool CanCastToHeapObject(String* o) { return true; }
  static inline bool CanCastToHeapObject(Object* o) { return true; }
  static inline bool CanCastToHeapObject(Message* o) { return true; }
  static inline bool CanCastToHeapObject(StackTrace* o) { return true; }
  static inline bool CanCastToHeapObject(StackFrame* o) { return true; }
};

}


template <class T>
Local<T>::Local() : Handle<T>() { }


template <class T>
Local<T> Local<T>::New(Handle<T> that) {
  if (that.IsEmpty()) return Local<T>();
  T* that_ptr = *that;
  internal::Object** p = reinterpret_cast<internal::Object**>(that_ptr);
  if (internal::Internals::CanCastToHeapObject(that_ptr)) {
    return Local<T>(reinterpret_cast<T*>(HandleScope::CreateHandle(
        reinterpret_cast<internal::HeapObject*>(*p))));
  }
  return Local<T>(reinterpret_cast<T*>(HandleScope::CreateHandle(*p)));
}


template <class T>
Persistent<T> Persistent<T>::New(Handle<T> that) {
  if (that.IsEmpty()) return Persistent<T>();
  internal::Object** p = reinterpret_cast<internal::Object**>(*that);
  return Persistent<T>(reinterpret_cast<T*>(V8::GlobalizeReference(p)));
}


template <class T>
bool Persistent<T>::IsNearDeath() const {
  if (this->IsEmpty()) return false;
  return V8::IsGlobalNearDeath(reinterpret_cast<internal::Object**>(**this));
}


template <class T>
bool Persistent<T>::IsWeak() const {
  if (this->IsEmpty()) return false;
  return V8::IsGlobalWeak(reinterpret_cast<internal::Object**>(**this));
}


template <class T>
void Persistent<T>::Dispose() {
  if (this->IsEmpty()) return;
  V8::DisposeGlobal(reinterpret_cast<internal::Object**>(**this));
}


template <class T>
Persistent<T>::Persistent() : Handle<T>() { }

template <class T>
void Persistent<T>::MakeWeak(void* parameters, WeakReferenceCallback callback) {
  V8::MakeWeak(reinterpret_cast<internal::Object**>(**this),
               parameters,
               callback);
}

template <class T>
void Persistent<T>::ClearWeak() {
  V8::ClearWeak(reinterpret_cast<internal::Object**>(**this));
}

template <class T>
void Persistent<T>::MarkIndependent() {
  V8::MarkIndependent(reinterpret_cast<internal::Object**>(**this));
}

template <class T>
void Persistent<T>::SetWrapperClassId(uint16_t class_id) {
  V8::SetWrapperClassId(reinterpret_cast<internal::Object**>(**this), class_id);
}

Arguments::Arguments(internal::Object** implicit_args,
                     internal::Object** values, int length,
                     bool is_construct_call)
    : implicit_args_(implicit_args),
      values_(values),
      length_(length),
      is_construct_call_(is_construct_call) { }


Local<Value> Arguments::operator[](int i) const {
  if (i < 0 || length_ <= i) return Local<Value>(*Undefined());
  return Local<Value>(reinterpret_cast<Value*>(values_ - i));
}


Local<Function> Arguments::Callee() const {
  return Local<Function>(reinterpret_cast<Function*>(
      &implicit_args_[kCalleeIndex]));
}


Local<Object> Arguments::This() const {
  return Local<Object>(reinterpret_cast<Object*>(values_ + 1));
}


Local<Object> Arguments::Holder() const {
  return Local<Object>(reinterpret_cast<Object*>(
      &implicit_args_[kHolderIndex]));
}


Local<Value> Arguments::Data() const {
  return Local<Value>(reinterpret_cast<Value*>(&implicit_args_[kDataIndex]));
}


Isolate* Arguments::GetIsolate() const {
  return *reinterpret_cast<Isolate**>(&implicit_args_[kIsolateIndex]);
}


bool Arguments::IsConstructCall() const {
  return is_construct_call_;
}


int Arguments::Length() const {
  return length_;
}


template <class T>
Local<T> HandleScope::Close(Handle<T> value) {
  internal::Object** before = reinterpret_cast<internal::Object**>(*value);
  internal::Object** after = RawClose(before);
  return Local<T>(reinterpret_cast<T*>(after));
}

Handle<Value> ScriptOrigin::ResourceName() const {
  return resource_name_;
}


Handle<Integer> ScriptOrigin::ResourceLineOffset() const {
  return resource_line_offset_;
}


Handle<Integer> ScriptOrigin::ResourceColumnOffset() const {
  return resource_column_offset_;
}


Handle<Boolean> Boolean::New(bool value) {
  return value ? True() : False();
}


void Template::Set(const char* name, v8::Handle<Data> value) {
  Set(v8::String::New(name), value);
}


Local<Value> Object::GetInternalField(int index) {

  Local<Value> quick_result = UncheckedGetInternalField(index);
  if (!quick_result.IsEmpty()) return quick_result;

  return CheckedGetInternalField(index);
}


Local<Value> Object::UncheckedGetInternalField(int index) {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O**>(this);
  if (I::GetInstanceType(obj) == I::kJSObjectType) {



    int offset = I::kJSObjectHeaderSize + (internal::kApiPointerSize * index);
    O* value = I::ReadField<O*>(obj, offset);
    O** result = HandleScope::CreateHandle(value);
    return Local<Value>(reinterpret_cast<Value*>(result));
  } else {
    return Local<Value>();
  }
}


void* External::Unwrap(Handle<v8::Value> obj) {



  return QuickUnwrap(obj);

}


void* External::QuickUnwrap(Handle<v8::Value> wrapper) {
  typedef internal::Object O;
  O* obj = *reinterpret_cast<O**>(const_cast<v8::Value*>(*wrapper));
  return internal::Internals::GetExternalPointer(obj);
}


void* Object::GetPointerFromInternalField(int index) {
  typedef internal::Object O;
  typedef internal::Internals I;

  O* obj = *reinterpret_cast<O**>(this);

  if (I::GetInstanceType(obj) == I::kJSObjectType) {



    int offset = I::kJSObjectHeaderSize + (internal::kApiPointerSize * index);
    O* value = I::ReadField<O*>(obj, offset);
    return I::GetExternalPointer(value);
  }

  return SlowGetPointerFromInternalField(index);
}


String* String::Cast(v8::Value* value) {



  return static_cast<String*>(value);
}


Local<String> String::Empty(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  if (!I::IsInitialized(isolate)) return Empty();
  S* slot = I::GetRoot(isolate, I::kEmptySymbolRootIndex);
  return Local<String>(reinterpret_cast<String*>(slot));
}


String::ExternalStringResource* String::GetExternalStringResource() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O**>(const_cast<String*>(this));
  String::ExternalStringResource* result;
  if (I::IsExternalTwoByteString(I::GetInstanceType(obj))) {
    void* value = I::ReadField<void*>(obj, I::kStringResourceOffset);
    result = reinterpret_cast<String::ExternalStringResource*>(value);
  } else {
    result = __null;
  }



  return result;
}


bool Value::IsUndefined() const {



  return QuickIsUndefined();

}

bool Value::QuickIsUndefined() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O**>(const_cast<Value*>(this));
  if (!I::HasHeapObjectTag(obj)) return false;
  if (I::GetInstanceType(obj) != I::kOddballType) return false;
  return (I::GetOddballKind(obj) == I::kUndefinedOddballKind);
}


bool Value::IsNull() const {



  return QuickIsNull();

}

bool Value::QuickIsNull() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O**>(const_cast<Value*>(this));
  if (!I::HasHeapObjectTag(obj)) return false;
  if (I::GetInstanceType(obj) != I::kOddballType) return false;
  return (I::GetOddballKind(obj) == I::kNullOddballKind);
}


bool Value::IsString() const {



  return QuickIsString();

}

bool Value::QuickIsString() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O**>(const_cast<Value*>(this));
  if (!I::HasHeapObjectTag(obj)) return false;
  return (I::GetInstanceType(obj) < I::kFirstNonstringType);
}


Number* Number::Cast(v8::Value* value) {



  return static_cast<Number*>(value);
}


Integer* Integer::Cast(v8::Value* value) {



  return static_cast<Integer*>(value);
}


Date* Date::Cast(v8::Value* value) {



  return static_cast<Date*>(value);
}


StringObject* StringObject::Cast(v8::Value* value) {



  return static_cast<StringObject*>(value);
}


NumberObject* NumberObject::Cast(v8::Value* value) {



  return static_cast<NumberObject*>(value);
}


BooleanObject* BooleanObject::Cast(v8::Value* value) {



  return static_cast<BooleanObject*>(value);
}


RegExp* RegExp::Cast(v8::Value* value) {



  return static_cast<RegExp*>(value);
}


Object* Object::Cast(v8::Value* value) {



  return static_cast<Object*>(value);
}


Array* Array::Cast(v8::Value* value) {



  return static_cast<Array*>(value);
}


Function* Function::Cast(v8::Value* value) {



  return static_cast<Function*>(value);
}


External* External::Cast(v8::Value* value) {



  return static_cast<External*>(value);
}


Isolate* AccessorInfo::GetIsolate() const {
  return *reinterpret_cast<Isolate**>(&args_[-3]);
}


Local<Value> AccessorInfo::Data() const {
  return Local<Value>(reinterpret_cast<Value*>(&args_[-2]));
}


Local<Object> AccessorInfo::This() const {
  return Local<Object>(reinterpret_cast<Object*>(&args_[0]));
}


Local<Object> AccessorInfo::Holder() const {
  return Local<Object>(reinterpret_cast<Object*>(&args_[-1]));
}


Handle<Primitive> Undefined(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  if (!I::IsInitialized(isolate)) return Undefined();
  S* slot = I::GetRoot(isolate, I::kUndefinedValueRootIndex);
  return Handle<Primitive>(reinterpret_cast<Primitive*>(slot));
}


Handle<Primitive> Null(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  if (!I::IsInitialized(isolate)) return Null();
  S* slot = I::GetRoot(isolate, I::kNullValueRootIndex);
  return Handle<Primitive>(reinterpret_cast<Primitive*>(slot));
}


Handle<Boolean> True(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  if (!I::IsInitialized(isolate)) return True();
  S* slot = I::GetRoot(isolate, I::kTrueValueRootIndex);
  return Handle<Boolean>(reinterpret_cast<Boolean*>(slot));
}


Handle<Boolean> False(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  if (!I::IsInitialized(isolate)) return False();
  S* slot = I::GetRoot(isolate, I::kFalseValueRootIndex);
  return Handle<Boolean>(reinterpret_cast<Boolean*>(slot));
}


void Isolate::SetData(void* data) {
  typedef internal::Internals I;
  I::SetEmbedderData(this, data);
}


void* Isolate::GetData() {
  typedef internal::Internals I;
  return I::GetEmbedderData(this);
}
# 4498 "/usr/include/nodejs/v8.h" 3 4
}
# 63 "/usr/include/nodejs/node.h" 2 3 4


# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/nodejs/node.h" 2 3 4

# 1 "/usr/include/nodejs/node_object_wrap.h" 1 3 4
# 25 "/usr/include/nodejs/node_object_wrap.h" 3 4
# 1 "/usr/include/nodejs/node.h" 1 3 4
# 26 "/usr/include/nodejs/node_object_wrap.h" 2 3 4

# 1 "/usr/include/assert.h" 1 3 4
# 28 "/usr/include/nodejs/node_object_wrap.h" 2 3 4
# 38 "/usr/include/nodejs/node_object_wrap.h" 3 4
namespace node {

class ObjectWrap {
 public:
  ObjectWrap ( ) {
    refs_ = 0;
  }


  virtual ~ObjectWrap ( ) {
    if (!handle_.IsEmpty()) {
      ((handle_.IsNearDeath()) ? static_cast<void> (0) : __assert_fail ("handle_.IsNearDeath()", "/usr/include/nodejs/node_object_wrap.h", 49, __PRETTY_FUNCTION__));
      handle_.ClearWeak();
      handle_->SetInternalField(0, v8::Undefined());
      handle_.Dispose();
      handle_.Clear();
    }
  }


  template <class T>
  static inline T* Unwrap (v8::Handle<v8::Object> handle) {
    ((!handle.IsEmpty()) ? static_cast<void> (0) : __assert_fail ("!handle.IsEmpty()", "/usr/include/nodejs/node_object_wrap.h", 60, __PRETTY_FUNCTION__));
    ((handle->InternalFieldCount() > 0) ? static_cast<void> (0) : __assert_fail ("handle->InternalFieldCount() > 0", "/usr/include/nodejs/node_object_wrap.h", 61, __PRETTY_FUNCTION__));
    return static_cast<T*>(handle->GetPointerFromInternalField(0));
  }


  v8::Persistent<v8::Object> handle_;

 protected:
  inline void Wrap (v8::Handle<v8::Object> handle) {
    ((handle_.IsEmpty()) ? static_cast<void> (0) : __assert_fail ("handle_.IsEmpty()", "/usr/include/nodejs/node_object_wrap.h", 70, __PRETTY_FUNCTION__));
    ((handle->InternalFieldCount() > 0) ? static_cast<void> (0) : __assert_fail ("handle->InternalFieldCount() > 0", "/usr/include/nodejs/node_object_wrap.h", 71, __PRETTY_FUNCTION__));
    handle_ = v8::Persistent<v8::Object>::New(handle);
    handle_->SetPointerInInternalField(0, this);
    MakeWeak();
  }


  inline void MakeWeak (void) {
    handle_.MakeWeak(this, WeakCallback);
    handle_.MarkIndependent();
  }





  virtual void Ref() {
    ((!handle_.IsEmpty()) ? static_cast<void> (0) : __assert_fail ("!handle_.IsEmpty()", "/usr/include/nodejs/node_object_wrap.h", 88, __PRETTY_FUNCTION__));
    refs_++;
    handle_.ClearWeak();
  }
# 102 "/usr/include/nodejs/node_object_wrap.h" 3 4
  virtual void Unref() {
    ((!handle_.IsEmpty()) ? static_cast<void> (0) : __assert_fail ("!handle_.IsEmpty()", "/usr/include/nodejs/node_object_wrap.h", 103, __PRETTY_FUNCTION__));
    ((!handle_.IsWeak()) ? static_cast<void> (0) : __assert_fail ("!handle_.IsWeak()", "/usr/include/nodejs/node_object_wrap.h", 104, __PRETTY_FUNCTION__));
    ((refs_ > 0) ? static_cast<void> (0) : __assert_fail ("refs_ > 0", "/usr/include/nodejs/node_object_wrap.h", 105, __PRETTY_FUNCTION__));
    if (--refs_ == 0) { MakeWeak(); }
  }


  int refs_;


 private:
  static void WeakCallback (v8::Persistent<v8::Value> value, void *data) {
    ObjectWrap *obj = static_cast<ObjectWrap*>(data);
    ((value == obj->handle_) ? static_cast<void> (0) : __assert_fail ("value == obj->handle_", "/usr/include/nodejs/node_object_wrap.h", 116, __PRETTY_FUNCTION__));
    ((!obj->refs_) ? static_cast<void> (0) : __assert_fail ("!obj->refs_", "/usr/include/nodejs/node_object_wrap.h", 117, __PRETTY_FUNCTION__));
    ((value.IsNearDeath()) ? static_cast<void> (0) : __assert_fail ("value.IsNearDeath()", "/usr/include/nodejs/node_object_wrap.h", 118, __PRETTY_FUNCTION__));
    delete obj;
  }
};

}
# 68 "/usr/include/nodejs/node.h" 2 3 4
# 86 "/usr/include/nodejs/node.h" 3 4
namespace node {

 extern bool no_deprecation;

 int Start(int argc, char *argv[]);

char** Init(int argc, char *argv[]);
v8::Handle<v8::Object> SetupProcessObject(int argc, char *argv[]);
void Load(v8::Handle<v8::Object> process);
void EmitExit(v8::Handle<v8::Object> process);
# 110 "/usr/include/nodejs/node.h" 3 4
template <typename target_t>
void SetMethod(target_t obj, const char* name,
        v8::InvocationCallback callback)
{
    obj->Set(v8::String::NewSymbol(name),
        v8::FunctionTemplate::New(callback)->GetFunction());
}

template <typename target_t>
void SetPrototypeMethod(target_t target,
        const char* name, v8::InvocationCallback callback)
{
    v8::Local<v8::FunctionTemplate> templ = v8::FunctionTemplate::New(callback);
    target->PrototypeTemplate()->Set(v8::String::NewSymbol(name), templ);
}





enum encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX};
enum encoding ParseEncoding(v8::Handle<v8::Value> encoding_v,
                            enum encoding _default = BINARY);
 void FatalException(v8::TryCatch &try_catch);
void DisplayExceptionLine(v8::TryCatch &try_catch);

 v8::Local<v8::Value> Encode(const void *buf, size_t len,
                                        enum encoding encoding = BINARY);


 ssize_t DecodeBytes(v8::Handle<v8::Value>,
                                enum encoding encoding = BINARY);


 ssize_t DecodeWrite(char *buf,
                                size_t buflen,
                                v8::Handle<v8::Value>,
                                enum encoding encoding = BINARY);

v8::Local<v8::Object> BuildStatsObject(const uv_statbuf_t* s);
# 159 "/usr/include/nodejs/node.h" 3 4
v8::Handle<v8::Value> FromConstructorTemplate(
    v8::Persistent<v8::FunctionTemplate>& constructorTemplate,
    const v8::Arguments& args);


static inline v8::Persistent<v8::Function>* cb_persist(
    const v8::Local<v8::Value> &v) {
  v8::Persistent<v8::Function> *fn = new v8::Persistent<v8::Function>();
  *fn = v8::Persistent<v8::Function>::New(v8::Local<v8::Function>::Cast(v));
  return fn;
}

static inline v8::Persistent<v8::Function>* cb_unwrap(void *data) {
  v8::Persistent<v8::Function> *cb =
    reinterpret_cast<v8::Persistent<v8::Function>*>(data);
  (((*cb)->IsFunction()) ? static_cast<void> (0) : __assert_fail ("(*cb)->IsFunction()", "/usr/include/nodejs/node.h", 174, __PRETTY_FUNCTION__));
  return cb;
}

static inline void cb_destroy(v8::Persistent<v8::Function> * cb) {
  cb->Dispose();
  delete cb;
}

 v8::Local<v8::Value> ErrnoException(int errorno,
                                                const char *syscall = __null,
                                                const char *msg = "",
                                                const char *path = __null);

 v8::Local<v8::Value> UVException(int errorno,
                                             const char *syscall = __null,
                                             const char *msg = __null,
                                             const char *path = __null);







const char *signo_string(int errorno);

struct node_module_struct {
  int version;
  void *dso_handle;
  const char *filename;
  void (*register_func) (v8::Handle<v8::Object> target);
  const char *modname;
};

node_module_struct* get_builtin_module(const char *name);
# 246 "/usr/include/nodejs/node.h" 3 4
 void AtExit(void (*cb)(void* arg), void* arg = 0);

 void SetErrno(uv_err_t err);
 v8::Handle<v8::Value>
MakeCallback(const v8::Handle<v8::Object> object,
             const char* method,
             int argc,
             v8::Handle<v8::Value> argv[]);

 v8::Handle<v8::Value>
MakeCallback(const v8::Handle<v8::Object> object,
             const v8::Handle<v8::String> symbol,
             int argc,
             v8::Handle<v8::Value> argv[]);

 v8::Handle<v8::Value>
MakeCallback(const v8::Handle<v8::Object> object,
             const v8::Handle<v8::Function> callback,
             int argc,
             v8::Handle<v8::Value> argv[]);

}


# 1 "/usr/include/nodejs/ev-emul.h" 1 3 4
# 29 "/usr/include/nodejs/ev-emul.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 30 "/usr/include/nodejs/ev-emul.h" 2 3 4




extern "C" {
# 92 "/usr/include/nodejs/ev-emul.h" 3 4
static int __uv_warn_ev_io __attribute__((unused));
static int __uv_warn_ev_timer __attribute__((unused));
static int __uv_warn_ev_ref __attribute__((unused));
static int __uv_warn_ev_unref __attribute__((unused));

struct __ev_io;
typedef struct __ev_io __ev_io;
typedef void (*__ev_io_cb)(__ev_io*, int);

struct __ev_timer;
typedef struct __ev_timer __ev_timer;
typedef void (*__ev_timer_cb)(__ev_timer*, int);


struct __ev_io {
  __ev_io_cb cb;
  void* data;
  int flags;
  uv_poll_t handle;
  int fd;
  int events;
};


struct __ev_timer {
  __ev_timer_cb cb;
  void* data;
  int flags;
  uv_timer_t handle;
  double delay;
  double repeat;
};


inline static void __uv_poll_cb(uv_poll_t* handle, int status, int events) {
  __ev_io* w = ((__ev_io*) ((char*) (handle) - __builtin_offsetof (__ev_io, handle)));
  w->cb(w, events);
  (void) status;
}


inline static void __uv_timer_cb(uv_timer_t* handle, int status) {
  __ev_timer* w = ((__ev_timer*) ((char*) (handle) - __builtin_offsetof (__ev_timer, handle)));
  w->cb(w, 0);
  (void) status;
}


inline static void __ev_io_init(__ev_io* w, __ev_io_cb cb, int fd, int events) {
  do { if (__uv_warn_ev_io || node::no_deprecation) break; __uv_warn_ev_io = 1; fputs("WARNING: " "ev_io" " is deprecated, use " "uv_poll_t" "\n", stderr); } while (0);
  do { void* data = (w)->data; memset((w), 0, sizeof(*(w))); (w)->data = data; (w)->cb = (cb); } while (0);
  w->fd = fd;
  w->events = events;
}


inline static void __ev_io_set(__ev_io* w, int fd, int events) {
  do { if (__uv_warn_ev_io || node::no_deprecation) break; __uv_warn_ev_io = 1; fputs("WARNING: " "ev_io" " is deprecated, use " "uv_poll_t" "\n", stderr); } while (0);
  w->fd = fd;
  w->events = events;
}


inline static void __ev_io_start(__ev_io* w) {
  do { if (__uv_warn_ev_io || node::no_deprecation) break; __uv_warn_ev_io = 1; fputs("WARNING: " "ev_io" " is deprecated, use " "uv_poll_t" "\n", stderr); } while (0);
  if (!(w->flags & 1)) {
    uv_poll_init(uv_default_loop(), &w->handle, w->fd);
    w->flags |= 1;
  }
  uv_poll_start(&w->handle, w->events, __uv_poll_cb);
}


inline static void __ev_io_stop(__ev_io* w) {
  do { if (__uv_warn_ev_io || node::no_deprecation) break; __uv_warn_ev_io = 1; fputs("WARNING: " "ev_io" " is deprecated, use " "uv_poll_t" "\n", stderr); } while (0);
  uv_poll_stop(&w->handle);
}


inline static void __ev_timer_init(__ev_timer* w,
                                   __ev_timer_cb cb,
                                   double delay,
                                   double repeat) {
  do { if (__uv_warn_ev_timer || node::no_deprecation) break; __uv_warn_ev_timer = 1; fputs("WARNING: " "ev_timer" " is deprecated, use " "uv_timer_t" "\n", stderr); } while (0);
  do { void* data = (w)->data; memset((w), 0, sizeof(*(w))); (w)->data = data; (w)->cb = (cb); } while (0);
  w->delay = delay;
  w->repeat = repeat;
}


inline static void __ev_timer_set(__ev_timer* w,
                                  double delay,
                                  double repeat) {
  do { if (__uv_warn_ev_timer || node::no_deprecation) break; __uv_warn_ev_timer = 1; fputs("WARNING: " "ev_timer" " is deprecated, use " "uv_timer_t" "\n", stderr); } while (0);
  w->delay = delay;
  w->repeat = repeat;
}


inline static void __ev_timer_start(__ev_timer* w) {
  do { if (__uv_warn_ev_timer || node::no_deprecation) break; __uv_warn_ev_timer = 1; fputs("WARNING: " "ev_timer" " is deprecated, use " "uv_timer_t" "\n", stderr); } while (0);
  if (!(w->flags & 1)) {
    uv_timer_init(uv_default_loop(), &w->handle);
    w->flags |= 1;
  }
  uv_timer_start(&w->handle,
                 __uv_timer_cb,
                 (int64_t) (w->delay * 1000),
                 (int64_t) (w->repeat * 1000));
}


inline static void __ev_timer_stop(__ev_timer* w) {
  do { if (__uv_warn_ev_timer || node::no_deprecation) break; __uv_warn_ev_timer = 1; fputs("WARNING: " "ev_timer" " is deprecated, use " "uv_timer_t" "\n", stderr); } while (0);
  uv_timer_stop(&w->handle);
}


inline static void __ev_timer_again(__ev_timer* w) {
  do { if (__uv_warn_ev_timer || node::no_deprecation) break; __uv_warn_ev_timer = 1; fputs("WARNING: " "ev_timer" " is deprecated, use " "uv_timer_t" "\n", stderr); } while (0);
  if (w->flags & 1)
    uv_timer_again(&w->handle);
  else
    __ev_timer_start(w);
}



inline static void __ev_ref(void) {
  do { if (__uv_warn_ev_ref || node::no_deprecation) break; __uv_warn_ev_ref = 1; fputs("WARNING: " "ev_ref" " is deprecated, use " "uv_ref" "\n", stderr); } while (0);
  uv_default_loop()->active_handles++;
}



inline static void __ev_unref(void) {
  do { if (__uv_warn_ev_unref || node::no_deprecation) break; __uv_warn_ev_unref = 1; fputs("WARNING: " "ev_unref" " is deprecated, use " "uv_unref" "\n", stderr); } while (0);
  uv_default_loop()->active_handles--;
}


inline static double __ev_now(...) {
  return uv_hrtime() / 1e9;
}


inline static void __ev_set_priority(...) {
}
# 265 "/usr/include/nodejs/ev-emul.h" 3 4
}
# 271 "/usr/include/nodejs/node.h" 2 3 4
# 1 "/usr/include/nodejs/eio-emul.h" 1 3 4
# 272 "/usr/include/nodejs/node.h" 2 3 4
# 13 "../src/worker.hpp" 2

namespace cocaine { namespace engine {

    struct worker_config_t {
      std::string app;
      std::string profile;
      std::string uuid;
    };

    class worker_t:
    public boost::noncopyable
    {
    public:
      worker_t(context_t& context,
               worker_config_t config);

      ~worker_t();

      void
      run();

      template<class Event, typename... Args>
      void
      send(Args&&... args);

    private:
      void
      on_event(ev::io&, int);

      void
      on_check(ev::prepare&, int);

      void
      on_heartbeat(ev::timer&, int);

      void
      on_disown(ev::timer&, int);

      void
      process();

      void
      terminate(io::rpc::suicide::reasons reason,
                const std::string& message);

    private:
      context_t& m_context;
      std::unique_ptr<logging::log_t> m_log;



      const unique_id_t m_id;



      io::unique_channel_t m_channel;



      ev::default_loop m_loop;

      ev::io m_watcher;
      ev::prepare m_checker;

      ev::timer m_heartbeat_timer,
        m_disown_timer;

      uv_poll_t* m_uv_poll_handle_;



      std::unique_ptr<const manifest_t> m_manifest;
      std::unique_ptr<const profile_t> m_profile;
      std::unique_ptr<api::sandbox_t> m_sandbox;

      struct io_pair_t {
        boost::shared_ptr<api::stream_t> upstream;
        boost::shared_ptr<api::stream_t> downstream;
      };


      typedef boost::unordered_map<



          unique_id_t,
          io_pair_t
          > stream_map_t;


      stream_map_t m_streams;
    };

    template<class Event, typename... Args>
    void
    worker_t::send(Args&&... args) {
      m_channel.send<Event>(std::forward<Args>(args)...);
    }

  }}
# 3 "../src/worker.cpp" 2

# 1 "/usr/include/cocaine/context.hpp" 1 3 4
# 25 "/usr/include/cocaine/context.hpp" 3 4
# 1 "/usr/include/cocaine/repository.hpp" 1 3 4
# 29 "/usr/include/cocaine/repository.hpp" 3 4
# 1 "/usr/include/ltdl.h" 1 3 4
# 36 "/usr/include/ltdl.h" 3 4
# 1 "/usr/include/libltdl/lt_system.h" 1 3 4
# 34 "/usr/include/libltdl/lt_system.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.4.6/include/stddef.h" 1 3 4
# 35 "/usr/include/libltdl/lt_system.h" 2 3 4
# 37 "/usr/include/ltdl.h" 2 3 4
# 1 "/usr/include/libltdl/lt_error.h" 1 3 4
# 37 "/usr/include/libltdl/lt_error.h" 3 4
extern "C" {
# 67 "/usr/include/libltdl/lt_error.h" 3 4
enum {

 LT_ERROR_UNKNOWN, LT_ERROR_DLOPEN_NOT_SUPPORTED, LT_ERROR_INVALID_LOADER, LT_ERROR_INIT_LOADER, LT_ERROR_REMOVE_LOADER, LT_ERROR_FILE_NOT_FOUND, LT_ERROR_DEPLIB_NOT_FOUND, LT_ERROR_NO_SYMBOLS, LT_ERROR_CANNOT_OPEN, LT_ERROR_CANNOT_CLOSE, LT_ERROR_SYMBOL_NOT_FOUND, LT_ERROR_NO_MEMORY, LT_ERROR_INVALID_HANDLE, LT_ERROR_BUFFER_OVERFLOW, LT_ERROR_INVALID_ERRORCODE, LT_ERROR_SHUTDOWN, LT_ERROR_CLOSE_RESIDENT_MODULE, LT_ERROR_INVALID_MUTEX_ARGS, LT_ERROR_INVALID_POSITION, LT_ERROR_CONFLICTING_FLAGS,


 LT_ERROR_MAX
};





extern int lt_dladderror (const char *diagnostic);
extern int lt_dlseterror (int errorcode);


}
# 38 "/usr/include/ltdl.h" 2 3 4
# 1 "/usr/include/libltdl/lt_dlloader.h" 1 3 4
# 36 "/usr/include/libltdl/lt_dlloader.h" 3 4
extern "C" {

typedef void * lt_dlloader;
typedef void * lt_module;
typedef void * lt_user_data;
typedef struct lt__advise * lt_dladvise;


typedef lt_module lt_module_open (lt_user_data data,
      const char *filename,
      lt_dladvise advise);
typedef int lt_module_close (lt_user_data data,
      lt_module module);
typedef void * lt_find_sym (lt_user_data data, lt_module module,
      const char *symbolname);
typedef int lt_dlloader_init (lt_user_data data);
typedef int lt_dlloader_exit (lt_user_data data);


typedef enum {
  LT_DLLOADER_PREPEND = 0, LT_DLLOADER_APPEND
} lt_dlloader_priority;



typedef struct {
  const char * name;
  const char * sym_prefix;
  lt_module_open * module_open;
  lt_module_close * module_close;
  lt_find_sym * find_sym;
  lt_dlloader_init * dlloader_init;
  lt_dlloader_exit * dlloader_exit;
  lt_user_data dlloader_data;
  lt_dlloader_priority priority;
} lt_dlvtable;

extern int lt_dlloader_add (const lt_dlvtable *vtable);
extern lt_dlloader lt_dlloader_next (const lt_dlloader loader);

extern lt_dlvtable * lt_dlloader_remove (char *name);
extern const lt_dlvtable *lt_dlloader_find (char *name);
extern const lt_dlvtable *lt_dlloader_get (lt_dlloader loader);



typedef const lt_dlvtable *lt_get_vtable (lt_user_data data);





}
# 39 "/usr/include/ltdl.h" 2 3 4

extern "C" {
# 50 "/usr/include/ltdl.h" 3 4
typedef struct lt__handle *lt_dlhandle;


extern int lt_dlinit (void);
extern int lt_dlexit (void);


extern int lt_dladdsearchdir (const char *search_dir);
extern int lt_dlinsertsearchdir (const char *before,
        const char *search_dir);
extern int lt_dlsetsearchpath (const char *search_path);
extern const char *lt_dlgetsearchpath (void);
extern int lt_dlforeachfile (
   const char *search_path,
   int (*func) (const char *filename, void *data),
   void *data);


extern int lt_dladvise_init (lt_dladvise *advise);
extern int lt_dladvise_destroy (lt_dladvise *advise);
extern int lt_dladvise_ext (lt_dladvise *advise);
extern int lt_dladvise_resident (lt_dladvise *advise);
extern int lt_dladvise_local (lt_dladvise *advise);
extern int lt_dladvise_global (lt_dladvise *advise);
extern int lt_dladvise_preload (lt_dladvise *advise);


extern lt_dlhandle lt_dlopen (const char *filename);
extern lt_dlhandle lt_dlopenext (const char *filename);
extern lt_dlhandle lt_dlopenadvise (const char *filename,
      lt_dladvise advise);
extern void * lt_dlsym (lt_dlhandle handle, const char *name);
extern const char *lt_dlerror (void);
extern int lt_dlclose (lt_dlhandle handle);
# 92 "/usr/include/ltdl.h" 3 4
typedef struct {
  const char *name;
  void *address;
} lt_dlsymlist;

typedef int lt_dlpreload_callback_func (lt_dlhandle handle);

extern int lt_dlpreload (const lt_dlsymlist *preloaded);
extern int lt_dlpreload_default (const lt_dlsymlist *preloaded);
extern int lt_dlpreload_open (const char *originator,
          lt_dlpreload_callback_func *func);
# 117 "/usr/include/ltdl.h" 3 4
typedef void * lt_dlinterface_id;
typedef int lt_dlhandle_interface (lt_dlhandle handle, const char *id_string);

extern lt_dlinterface_id lt_dlinterface_register (const char *id_string,
       lt_dlhandle_interface *iface);
extern void lt_dlinterface_free (lt_dlinterface_id key);
extern void * lt_dlcaller_set_data (lt_dlinterface_id key,
       lt_dlhandle handle, void *data);
extern void * lt_dlcaller_get_data (lt_dlinterface_id key,
       lt_dlhandle handle);



typedef struct {
  char * filename;
  char * name;
  int ref_count;

  unsigned int is_resident:1;
  unsigned int is_symglobal:1;

  unsigned int is_symlocal:1;

} lt_dlinfo;

extern const lt_dlinfo *lt_dlgetinfo (lt_dlhandle handle);

extern lt_dlhandle lt_dlhandle_iterate (lt_dlinterface_id iface,
          lt_dlhandle place);
extern lt_dlhandle lt_dlhandle_fetch (lt_dlinterface_id iface,
          const char *module_name);
extern int lt_dlhandle_map (lt_dlinterface_id iface,
    int (*func) (lt_dlhandle handle, void *data),
    void *data);




extern int lt_dlmakeresident (lt_dlhandle handle);
extern int lt_dlisresident (lt_dlhandle handle);



}
# 30 "/usr/include/cocaine/repository.hpp" 2 3 4

namespace cocaine { namespace api {

template<class Category>
struct category_traits;

struct factory_concept_t {
    virtual
    ~factory_concept_t() {

    }

    virtual
    const std::type_info&
    id() const = 0;
};

template<class Category>
struct factory_base:
    public factory_concept_t
{
    virtual
    const std::type_info&
    id() const {
        return typeid(Category);
    }
};



template<class T>
struct plugin_traits {
    typedef typename category_traits<
        typename T::category_type
    >::template default_factory<T> factory_type;
};



struct repository_error_t:
    public error_t
{
    template<typename... Args>
    repository_error_t(const std::string& format,
                       const Args&... args):
        error_t(format, args...)
    { }
};

class repository_t:
    public boost::noncopyable
{
    public:
        repository_t();
        ~repository_t();

        void
        load(const std::string& path);

        template<class Category, typename... Args>
        typename category_traits<Category>::ptr_type
        get(const std::string& type,
            Args&&... args);

        template<class Category>
        boost::shared_ptr<factory_concept_t>
        get_factory(const std::string& type);

        template<class T>
        void
        insert(const std::string& type);

        template<class Category>
        void
        dispose();

    private:
        void
        open(const std::string& target);

    private:



        std::vector<lt_dlhandle> m_plugins;


        typedef boost::unordered_map<



            std::string,
            boost::shared_ptr<factory_concept_t>
        > factory_map_t;


        typedef boost::unordered_map<



            std::string,
            factory_map_t
        > category_map_t;

        category_map_t m_categories;
};

template<class Category, typename... Args>
typename category_traits<Category>::ptr_type
repository_t::get(const std::string& type,
                  Args&&... args)
{
    std::string id = typeid(Category).name();

    factory_map_t& factories = m_categories[id];
    factory_map_t::iterator it = factories.find(type);

    if(it == factories.end()) {
        throw repository_error_t("the '%s' component is not available", type);
    }

    const std::type_info* ti1 = &typeid(Category);
    const std::type_info* ti2 = &(it->second->id());

    printf("trying to get plugin <name %s> <category %s>, got <category %s>\n",
           type.c_str(),ti1->name(),ti2->name());
    fflush(stdout);


    ((it->second->id() == typeid(Category)) ? static_cast<void> (0) : __assert_fail ("it->second->id() == typeid(Category)", "/usr/include/cocaine/repository.hpp", 159, __PRETTY_FUNCTION__));

    typedef category_traits<Category> traits;

    return dynamic_cast<typename traits::factory_type&>(
        *it->second).get(std::forward<Args>(args)...);
}

template<class Category>
boost::shared_ptr<factory_concept_t>
repository_t::get_factory(const std::string& type)
{
    std::string id = typeid(Category).name();

    factory_map_t& factories = m_categories[id];
    factory_map_t::iterator it = factories.find(type);

    if(it == factories.end()) {
        throw repository_error_t("the '%s' component is not available", type);
    }

    const std::type_info* ti1 = &typeid(Category);
    const std::type_info* ti2 = &(it->second->id());

    printf("trying to get factory <name %s> <category %s@%p>, got <category %s:@%p>\n",
           type.c_str(),ti1->name(),ti1,ti2->name(),ti2);
    fflush(stdout);


    ((it->second->id() == typeid(Category)) ? static_cast<void> (0) : __assert_fail ("it->second->id() == typeid(Category)", "/usr/include/cocaine/repository.hpp", 188, __PRETTY_FUNCTION__));

    return it->second;
}


template<class T>
void
repository_t::insert(const std::string& type) {
    typedef typename T::category_type category_type;

    static_assert(
        std::is_base_of<
            category_type,
            T
        >::value,
        "component is not derived from its category"
    );

    static_assert(
        std::is_base_of<
            typename category_traits<category_type>::factory_type,
            typename plugin_traits<T>::factory_type
        >::value,
        "component factory is not derived from its category"
    );

    factory_map_t& factories = m_categories[typeid(category_type).name()];

    if(factories.find(type) != factories.end()) {
        throw repository_error_t("the '%s' component is a duplicate", type);
    }

    factories.emplace(
        type,
        boost::make_shared<typename plugin_traits<T>::factory_type>()
    );
    printf("inserting plugin <type %s> <category %s> <name %s>\n",
           typeid(T).name(), typeid(category_type).name(), type.c_str());
}

template<class Category>
void
repository_t::dispose() {
    m_categories.erase(typeid(Category).name());
}

typedef void (*initialize_fn_t)(repository_t&);

}}
# 26 "/usr/include/cocaine/context.hpp" 2 3 4

# 1 "/usr/include/cocaine/helpers/json.hpp" 1 3 4
# 24 "/usr/include/cocaine/helpers/json.hpp" 3 4
# 1 "/usr/include/json/json.h" 1 3 4
# 9 "/usr/include/json/json.h" 3 4
# 1 "/usr/include/json/autolink.h" 1 3 4
# 9 "/usr/include/json/autolink.h" 3 4
# 1 "/usr/include/json/config.h" 1 3 4
# 73 "/usr/include/json/config.h" 3 4
namespace Json {
   typedef int Int;
   typedef unsigned int UInt;
# 86 "/usr/include/json/config.h" 3 4
   typedef long long int Int64;
   typedef unsigned long long int UInt64;

   typedef Int64 LargestInt;
   typedef UInt64 LargestUInt;


}
# 10 "/usr/include/json/autolink.h" 2 3 4
# 21 "/usr/include/json/autolink.h" 3 4
# 1 "/usr/include/json/autolink.h" 1 3 4
# 22 "/usr/include/json/autolink.h" 2 3 4
# 10 "/usr/include/json/json.h" 2 3 4
# 1 "/usr/include/json/value.h" 1 3 4
# 10 "/usr/include/json/value.h" 3 4
# 1 "/usr/include/json/forwards.h" 1 3 4
# 13 "/usr/include/json/forwards.h" 3 4
namespace Json {


   class FastWriter;
   class StyledWriter;


   class Reader;


   class Features;


   typedef unsigned int ArrayIndex;
   class StaticString;
   class Path;
   class PathArgument;
   class Value;
   class ValueIteratorBase;
   class ValueIterator;
   class ValueConstIterator;







}
# 11 "/usr/include/json/value.h" 2 3 4
# 26 "/usr/include/json/value.h" 3 4
namespace Json {



   enum ValueType
   {
      nullValue = 0,
      intValue,
      uintValue,
      realValue,
      stringValue,
      booleanValue,
      arrayValue,
      objectValue
   };

   enum CommentPlacement
   {
      commentBefore = 0,
      commentAfterOnSameLine,
      commentAfter,
      numberOfCommentPlacement
   };
# 69 "/usr/include/json/value.h" 3 4
   class StaticString
   {
   public:
      explicit StaticString( const char *czstring )
         : str_( czstring )
      {
      }

      operator const char *() const
      {
         return str_;
      }

      const char *c_str() const
      {
         return str_;
      }

   private:
      const char *str_;
   };
# 118 "/usr/include/json/value.h" 3 4
   class Value
   {
      friend class ValueIteratorBase;




   public:
      typedef std::vector<std::string> Members;
      typedef ValueIterator iterator;
      typedef ValueConstIterator const_iterator;
      typedef Json::UInt UInt;
      typedef Json::Int Int;

      typedef Json::UInt64 UInt64;
      typedef Json::Int64 Int64;

      typedef Json::LargestInt LargestInt;
      typedef Json::LargestUInt LargestUInt;
      typedef Json::ArrayIndex ArrayIndex;

      static const Value null;

      static const LargestInt minLargestInt;

      static const LargestInt maxLargestInt;

      static const LargestUInt maxLargestUInt;


      static const Int minInt;

      static const Int maxInt;

      static const UInt maxUInt;


      static const Int64 minInt64;

      static const Int64 maxInt64;

      static const UInt64 maxUInt64;

   private:


      class CZString
      {
      public:
         enum DuplicationPolicy
         {
            noDuplication = 0,
            duplicate,
            duplicateOnCopy
         };
         CZString( ArrayIndex index );
         CZString( const char *cstr, DuplicationPolicy allocate );
         CZString( const CZString &other );
         ~CZString();
         CZString &operator =( const CZString &other );
         bool operator<( const CZString &other ) const;
         bool operator==( const CZString &other ) const;
         ArrayIndex index() const;
         const char *c_str() const;
         bool isStaticString() const;
      private:
         void swap( CZString &other );
         const char *cstr_;
         ArrayIndex index_;
      };

   public:

      typedef std::map<CZString, Value> ObjectValues;






   public:
# 214 "/usr/include/json/value.h" 3 4
      Value( ValueType type = nullValue );
      Value( Int value );
      Value( UInt value );

      Value( Int64 value );
      Value( UInt64 value );

      Value( double value );
      Value( const char *value );
      Value( const char *beginValue, const char *endValue );
# 234 "/usr/include/json/value.h" 3 4
      Value( const StaticString &value );
      Value( const std::string &value );



      Value( bool value );
      Value( const Value &other );
      ~Value();

      Value &operator=( const Value &other );



      void swap( Value &other );

      ValueType type() const;

      bool operator <( const Value &other ) const;
      bool operator <=( const Value &other ) const;
      bool operator >=( const Value &other ) const;
      bool operator >( const Value &other ) const;

      bool operator ==( const Value &other ) const;
      bool operator !=( const Value &other ) const;

      int compare( const Value &other ) const;

      const char *asCString() const;
      std::string asString() const;



      Int asInt() const;
      UInt asUInt() const;
      Int64 asInt64() const;
      UInt64 asUInt64() const;
      LargestInt asLargestInt() const;
      LargestUInt asLargestUInt() const;
      float asFloat() const;
      double asDouble() const;
      bool asBool() const;

      bool isNull() const;
      bool isBool() const;
      bool isInt() const;
      bool isUInt() const;
      bool isIntegral() const;
      bool isDouble() const;
      bool isNumeric() const;
      bool isString() const;
      bool isArray() const;
      bool isObject() const;

      bool isConvertibleTo( ValueType other ) const;


      ArrayIndex size() const;



      bool empty() const;


      bool operator!() const;




      void clear();






      void resize( ArrayIndex size );






      Value &operator[]( ArrayIndex index );






      Value &operator[]( int index );




      const Value &operator[]( ArrayIndex index ) const;




      const Value &operator[]( int index ) const;



      Value get( ArrayIndex index,
                 const Value &defaultValue ) const;

      bool isValidIndex( ArrayIndex index ) const;



      Value &append( const Value &value );


      Value &operator[]( const char *key );

      const Value &operator[]( const char *key ) const;

      Value &operator[]( const std::string &key );

      const Value &operator[]( const std::string &key ) const;
# 365 "/usr/include/json/value.h" 3 4
      Value &operator[]( const StaticString &key );







      Value get( const char *key,
                 const Value &defaultValue ) const;

      Value get( const std::string &key,
                 const Value &defaultValue ) const;
# 389 "/usr/include/json/value.h" 3 4
      Value removeMember( const char* key );

      Value removeMember( const std::string &key );


      bool isMember( const char *key ) const;

      bool isMember( const std::string &key ) const;
# 407 "/usr/include/json/value.h" 3 4
      Members getMemberNames() const;







      void setComment( const char *comment,
                       CommentPlacement placement );

      void setComment( const std::string &comment,
                       CommentPlacement placement );
      bool hasComment( CommentPlacement placement ) const;

      std::string getComment( CommentPlacement placement ) const;

      std::string toStyledString() const;

      const_iterator begin() const;
      const_iterator end() const;

      iterator begin();
      iterator end();

   private:
      Value &resolveReference( const char *key,
                               bool isStatic );
# 458 "/usr/include/json/value.h" 3 4
   private:
      struct CommentInfo
      {
         CommentInfo();
         ~CommentInfo();

         void setComment( const char *text );

         char *comment_;
      };
# 478 "/usr/include/json/value.h" 3 4
      union ValueHolder
      {
         LargestInt int_;
         LargestUInt uint_;
         double real_;
         bool bool_;
         char *string_;




         ObjectValues *map_;

      } value_;
      ValueType type_ : 8;
      int allocated_ : 1;




      CommentInfo *comments_;
   };




   class PathArgument
   {
   public:
      friend class Path;

      PathArgument();
      PathArgument( ArrayIndex index );
      PathArgument( const char *key );
      PathArgument( const std::string &key );

   private:
      enum Kind
      {
         kindNone = 0,
         kindIndex,
         kindKey
      };
      std::string key_;
      ArrayIndex index_;
      Kind kind_;
   };
# 537 "/usr/include/json/value.h" 3 4
   class Path
   {
   public:
      Path( const std::string &path,
            const PathArgument &a1 = PathArgument(),
            const PathArgument &a2 = PathArgument(),
            const PathArgument &a3 = PathArgument(),
            const PathArgument &a4 = PathArgument(),
            const PathArgument &a5 = PathArgument() );

      const Value &resolve( const Value &root ) const;
      Value resolve( const Value &root,
                     const Value &defaultValue ) const;

      Value &make( Value &root ) const;

   private:
      typedef std::vector<const PathArgument *> InArgs;
      typedef std::vector<PathArgument> Args;

      void makePath( const std::string &path,
                     const InArgs &in );
      void addPathInArg( const std::string &path,
                         const InArgs &in,
                         InArgs::const_iterator &itInArg,
                         PathArgument::Kind kind );
      void invalidPath( const std::string &path,
                        int location );

      Args args_;
   };
# 913 "/usr/include/json/value.h" 3 4
   class ValueIteratorBase
   {
   public:
      typedef unsigned int size_t;
      typedef int difference_type;
      typedef ValueIteratorBase SelfType;

      ValueIteratorBase();

      explicit ValueIteratorBase( const Value::ObjectValues::iterator &current );





      bool operator ==( const SelfType &other ) const
      {
         return isEqual( other );
      }

      bool operator !=( const SelfType &other ) const
      {
         return !isEqual( other );
      }

      difference_type operator -( const SelfType &other ) const
      {
         return computeDistance( other );
      }


      Value key() const;


      UInt index() const;


      const char *memberName() const;

   protected:
      Value &deref() const;

      void increment();

      void decrement();

      difference_type computeDistance( const SelfType &other ) const;

      bool isEqual( const SelfType &other ) const;

      void copy( const SelfType &other );

   private:

      Value::ObjectValues::iterator current_;

      bool isNull_;
# 978 "/usr/include/json/value.h" 3 4
   };




   class ValueConstIterator : public ValueIteratorBase
   {
      friend class Value;
   public:
      typedef unsigned int size_t;
      typedef int difference_type;
      typedef const Value &reference;
      typedef const Value *pointer;
      typedef ValueConstIterator SelfType;

      ValueConstIterator();
   private:



      explicit ValueConstIterator( const Value::ObjectValues::iterator &current );




   public:
      SelfType &operator =( const ValueIteratorBase &other );

      SelfType operator++( int )
      {
         SelfType temp( *this );
         ++*this;
         return temp;
      }

      SelfType operator--( int )
      {
         SelfType temp( *this );
         --*this;
         return temp;
      }

      SelfType &operator--()
      {
         decrement();
         return *this;
      }

      SelfType &operator++()
      {
         increment();
         return *this;
      }

      reference operator *() const
      {
         return deref();
      }
   };




   class ValueIterator : public ValueIteratorBase
   {
      friend class Value;
   public:
      typedef unsigned int size_t;
      typedef int difference_type;
      typedef Value &reference;
      typedef Value *pointer;
      typedef ValueIterator SelfType;

      ValueIterator();
      ValueIterator( const ValueConstIterator &other );
      ValueIterator( const ValueIterator &other );
   private:



      explicit ValueIterator( const Value::ObjectValues::iterator &current );




   public:

      SelfType &operator =( const SelfType &other );

      SelfType operator++( int )
      {
         SelfType temp( *this );
         ++*this;
         return temp;
      }

      SelfType operator--( int )
      {
         SelfType temp( *this );
         --*this;
         return temp;
      }

      SelfType &operator--()
      {
         decrement();
         return *this;
      }

      SelfType &operator++()
      {
         increment();
         return *this;
      }

      reference operator *() const
      {
         return deref();
      }
   };


}
# 11 "/usr/include/json/json.h" 2 3 4
# 1 "/usr/include/json/reader.h" 1 3 4
# 10 "/usr/include/json/reader.h" 3 4
# 1 "/usr/include/json/features.h" 1 3 4
# 13 "/usr/include/json/features.h" 3 4
namespace Json {





   class Features
   {
   public:





      static Features all();






      static Features strictMode();



      Features();


      bool allowComments_;


      bool strictRoot_;
   };

}
# 11 "/usr/include/json/reader.h" 2 3 4



# 1 "/usr/include/c++/4.4/stack" 1 3 4
# 59 "/usr/include/c++/4.4/stack" 3 4
       
# 60 "/usr/include/c++/4.4/stack" 3


# 1 "/usr/include/c++/4.4/bits/stl_stack.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_stack.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 91 "/usr/include/c++/4.4/bits/stl_stack.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class stack
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;

    public:
# 129 "/usr/include/c++/4.4/bits/stl_stack.h" 3
      explicit
      stack(const _Sequence& __c)
      : c(__c) { }

      explicit
      stack(_Sequence&& __c = _Sequence())
      : c(std::move(__c)) { }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      top()
      {
 ;
 return c.back();
      }





      const_reference
      top() const
      {
 ;
 return c.back();
      }
# 181 "/usr/include/c++/4.4/bits/stl_stack.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
# 207 "/usr/include/c++/4.4/bits/stl_stack.h" 3
      void
      pop()
      {
 ;
 c.pop_back();
      }


      void
      swap(stack&& __s)
      { c.swap(__s.c); }

    };
# 233 "/usr/include/c++/4.4/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 251 "/usr/include/c++/4.4/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline void
    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq>
    inline void
    swap(stack<_Tp, _Seq>&& __x, stack<_Tp, _Seq>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq>
    inline void
    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>&& __y)
    { __x.swap(__y); }


}
# 63 "/usr/include/c++/4.4/stack" 2 3
# 15 "/usr/include/json/reader.h" 2 3 4

# 1 "/usr/include/c++/4.4/iostream" 1 3 4
# 37 "/usr/include/c++/4.4/iostream" 3 4
       
# 38 "/usr/include/c++/4.4/iostream" 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/include/c++/4.4/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 17 "/usr/include/json/reader.h" 2 3 4

namespace Json {




   class Reader
   {
   public:
      typedef char Char;
      typedef const Char *Location;




      Reader();




      Reader( const Features &features );
# 49 "/usr/include/json/reader.h" 3 4
      bool parse( const std::string &document,
                  Value &root,
                  bool collectComments = true );
# 65 "/usr/include/json/reader.h" 3 4
      bool parse( const char *beginDoc, const char *endDoc,
                  Value &root,
                  bool collectComments = true );



      bool parse( std::istream &is,
                  Value &root,
                  bool collectComments = true );







     
      std::string getFormatedErrorMessages() const;






      std::string getFormattedErrorMessages() const;

   private:
      enum TokenType
      {
         tokenEndOfStream = 0,
         tokenObjectBegin,
         tokenObjectEnd,
         tokenArrayBegin,
         tokenArrayEnd,
         tokenString,
         tokenNumber,
         tokenTrue,
         tokenFalse,
         tokenNull,
         tokenArraySeparator,
         tokenMemberSeparator,
         tokenComment,
         tokenError
      };

      class Token
      {
      public:
         TokenType type_;
         Location start_;
         Location end_;
      };

      class ErrorInfo
      {
      public:
         Token token_;
         std::string message_;
         Location extra_;
      };

      typedef std::deque<ErrorInfo> Errors;

      bool expectToken( TokenType type, Token &token, const char *message );
      bool readToken( Token &token );
      void skipSpaces();
      bool match( Location pattern,
                  int patternLength );
      bool readComment();
      bool readCStyleComment();
      bool readCppStyleComment();
      bool readString();
      void readNumber();
      bool readValue();
      bool readObject( Token &token );
      bool readArray( Token &token );
      bool decodeNumber( Token &token );
      bool decodeString( Token &token );
      bool decodeString( Token &token, std::string &decoded );
      bool decodeDouble( Token &token );
      bool decodeUnicodeCodePoint( Token &token,
                                   Location &current,
                                   Location end,
                                   unsigned int &unicode );
      bool decodeUnicodeEscapeSequence( Token &token,
                                        Location &current,
                                        Location end,
                                        unsigned int &unicode );
      bool addError( const std::string &message,
                     Token &token,
                     Location extra = 0 );
      bool recoverFromError( TokenType skipUntilToken );
      bool addErrorAndRecover( const std::string &message,
                               Token &token,
                               TokenType skipUntilToken );
      void skipUntilSpace();
      Value &currentValue();
      Char getNextChar();
      void getLocationLineAndColumn( Location location,
                                     int &line,
                                     int &column ) const;
      std::string getLocationLineAndColumn( Location location ) const;
      void addComment( Location begin,
                       Location end,
                       CommentPlacement placement );
      void skipCommentTokens( Token &token );

      typedef std::stack<Value *> Nodes;
      Nodes nodes_;
      Errors errors_;
      std::string document_;
      Location begin_;
      Location end_;
      Location current_;
      Location lastValueEnd_;
      Value *lastValue_;
      std::string commentsBefore_;
      Features features_;
      bool collectComments_;
   };
# 210 "/usr/include/json/reader.h" 3 4
   std::istream& operator>>( std::istream&, Value& );

}
# 12 "/usr/include/json/json.h" 2 3 4
# 1 "/usr/include/json/writer.h" 1 3 4
# 16 "/usr/include/json/writer.h" 3 4
namespace Json {

   class Value;



   class Writer
   {
   public:
      virtual ~Writer();

      virtual std::string write( const Value &root ) = 0;
   };







   class FastWriter : public Writer
   {
   public:
      FastWriter();
      virtual ~FastWriter(){}

      void enableYAMLCompatibility();

   public:
      virtual std::string write( const Value &root );

   private:
      void writeValue( const Value &value );

      std::string document_;
      bool yamlCompatiblityEnabled_;
   };
# 72 "/usr/include/json/writer.h" 3 4
   class StyledWriter: public Writer
   {
   public:
      StyledWriter();
      virtual ~StyledWriter(){}

   public:




      virtual std::string write( const Value &root );

   private:
      void writeValue( const Value &value );
      void writeArrayValue( const Value &value );
      bool isMultineArray( const Value &value );
      void pushValue( const std::string &value );
      void writeIndent();
      void writeWithIndent( const std::string &value );
      void indent();
      void unindent();
      void writeCommentBeforeValue( const Value &root );
      void writeCommentAfterValueOnSameLine( const Value &root );
      bool hasCommentForValue( const Value &value );
      static std::string normalizeEOL( const std::string &text );

      typedef std::vector<std::string> ChildValues;

      ChildValues childValues_;
      std::string document_;
      std::string indentString_;
      int rightMargin_;
      int indentSize_;
      bool addChildValues_;
   };
# 129 "/usr/include/json/writer.h" 3 4
   class StyledStreamWriter
   {
   public:
      StyledStreamWriter( std::string indentation="\t" );
      ~StyledStreamWriter(){}

   public:





      void write( std::ostream &out, const Value &root );

   private:
      void writeValue( const Value &value );
      void writeArrayValue( const Value &value );
      bool isMultineArray( const Value &value );
      void pushValue( const std::string &value );
      void writeIndent();
      void writeWithIndent( const std::string &value );
      void indent();
      void unindent();
      void writeCommentBeforeValue( const Value &root );
      void writeCommentAfterValueOnSameLine( const Value &root );
      bool hasCommentForValue( const Value &value );
      static std::string normalizeEOL( const std::string &text );

      typedef std::vector<std::string> ChildValues;

      ChildValues childValues_;
      std::ostream* document_;
      std::string indentString_;
      int rightMargin_;
      std::string indentation_;
      bool addChildValues_;
   };


   std::string valueToString( Int value );
   std::string valueToString( UInt value );

   std::string valueToString( LargestInt value );
   std::string valueToString( LargestUInt value );
   std::string valueToString( double value );
   std::string valueToString( bool value );
   std::string valueToQuotedString( const char *value );



   std::ostream& operator<<( std::ostream&, const Value &root );

}
# 13 "/usr/include/json/json.h" 2 3 4
# 25 "/usr/include/cocaine/helpers/json.hpp" 2 3 4
# 28 "/usr/include/cocaine/context.hpp" 2 3 4

# 1 "/usr/include/c++/4.4/queue" 1 3 4
# 59 "/usr/include/c++/4.4/queue" 3 4
       
# 60 "/usr/include/c++/4.4/queue" 3





# 1 "/usr/include/c++/4.4/bits/stl_queue.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_queue.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 88 "/usr/include/c++/4.4/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     
     

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 122 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      _Sequence c;

    public:
# 133 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      explicit
      queue(const _Sequence& __c)
      : c(__c) { }

      explicit
      queue(_Sequence&& __c = _Sequence())
      : c(std::move(__c)) { }

      queue(queue&& __q)
      : c(std::move(__q.c)) { }

      queue&
      operator=(queue&& __q)
      {
 c = std::move(__q.c);
 return *this;
      }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
 ;
 return c.front();
      }





      const_reference
      front() const
      {
 ;
 return c.front();
      }





      reference
      back()
      {
 ;
 return c.back();
      }





      const_reference
      back() const
      {
 ;
 return c.back();
      }
# 217 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
# 243 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 c.pop_front();
      }


      void
      swap(queue&& __q)
      { c.swap(__q.c); }

    };
# 268 "/usr/include/c++/4.4/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 286 "/usr/include/c++/4.4/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline void
    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq>
    inline void
    swap(queue<_Tp, _Seq>&& __x, queue<_Tp, _Seq>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq>
    inline void
    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>&& __y)
    { __x.swap(__y); }
# 367 "/usr/include/c++/4.4/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     
     
     


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;
      _Compare comp;

    public:
# 403 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      explicit
      priority_queue(const _Compare& __x,
       const _Sequence& __s)
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      explicit
      priority_queue(const _Compare& __x = _Compare(),
       _Sequence&& __s = _Sequence())
      : c(std::move(__s)), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }
# 443 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x,
         const _Sequence& __s)
 : c(__s), comp(__x)
        {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }

      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         _Sequence&& __s = _Sequence())
 : c(std::move(__s)), comp(__x)
        {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }

      priority_queue(priority_queue&& __pq)
      : c(std::move(__pq.c)), comp(std::move(__pq.comp)) { }

      priority_queue&
      operator=(priority_queue&& __pq)
      {
 c = std::move(__pq.c);
 comp = std::move(__pq.comp);
 return *this;
      }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
 ;
 return c.front();
      }
# 508 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }


      void
      push(value_type&& __x)
      {
 c.push_back(std::move(__x));
 std::push_heap(c.begin(), c.end(), comp);
      }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 {
   c.emplace_back(std::forward<_Args>(__args)...);
   std::push_heap(c.begin(), c.end(), comp);
 }
# 543 "/usr/include/c++/4.4/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }


      void
      swap(priority_queue&& __pq)
      {
 using std::swap;
 c.swap(__pq.c);
 swap(comp, __pq.comp);
      }

    };




  template<typename _Tp, typename _Sequence, typename _Compare>
    inline void
    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
  priority_queue<_Tp, _Sequence, _Compare>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Sequence, typename _Compare>
    inline void
    swap(priority_queue<_Tp, _Sequence, _Compare>&& __x,
  priority_queue<_Tp, _Sequence, _Compare>& __y)
    { __x.swap(__y); }

  template<typename _Tp, typename _Sequence, typename _Compare>
    inline void
    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
  priority_queue<_Tp, _Sequence, _Compare>&& __y)
    { __x.swap(__y); }


}
# 66 "/usr/include/c++/4.4/queue" 2 3
# 30 "/usr/include/cocaine/context.hpp" 2 3 4



namespace cocaine {

struct defaults {

    static const char slave[];


    static const float heartbeat_timeout;
    static const float idle_timeout;
    static const float startup_timeout;
    static const float termination_timeout;
    static const unsigned long pool_limit;
    static const unsigned long queue_limit;
    static const unsigned long concurrency;


    static const long control_timeout;
    static const unsigned long io_bulk_size;


    static const char plugins_path[];
    static const char runtime_path[];
    static const char spool_path[];
};



struct config_t {
    config_t(const std::string& config_path);

    struct {
        std::string config;
        std::string plugins;
        std::string runtime;
        std::string spool;
    } path;

    struct {
        std::string hostname;
        std::pair<uint16_t, uint16_t> ports;
        unsigned int threads;
    } network;

    struct component_t {
        std::string type;
        Json::Value args;
    };


    typedef boost::unordered_map<



        std::string,
        component_t
    > component_map_t;

    component_map_t storages;
    component_map_t loggers;
    component_map_t services;

public:
    static
    component_map_t
    parse(const Json::Value& config);
};



struct port_mapper_t {
    port_mapper_t(const std::pair<uint16_t, uint16_t>& limits);

    uint16_t
    get();

    void
    retain(uint16_t port);

private:
    std::priority_queue<
        uint16_t,
        std::vector<uint16_t>,
        std::greater<uint16_t>
    > m_ports;

    boost::mutex m_mutex;
};



class context_t:
    public boost::noncopyable
{
    public:
        context_t(config_t config,
                  const std::string& logger);

        context_t(config_t config,
                  std::unique_ptr<api::logger_t>&& logger);

        ~context_t();



        zmq::context_t&
        io() {
            return *m_io;
        }



        port_mapper_t&
        ports() {
            return *m_port_mapper;
        }



        template<class Category, typename... Args>
        typename api::category_traits<Category>::ptr_type
        get(const std::string& type,
            Args&&... args);

        template<class Category>
        boost::shared_ptr<api::factory_concept_t>
        get_factory(const std::string& type);



        api::logger_t&
        logger() {
            return *m_logger;
        }

    private:
        void
        initialize();

    public:
        const config_t config;

    private:
        std::unique_ptr<zmq::context_t> m_io;
        std::unique_ptr<port_mapper_t> m_port_mapper;




        std::unique_ptr<api::repository_t> m_repository;



        std::unique_ptr<api::logger_t> m_logger;
};

template<class Category, typename... Args>
typename api::category_traits<Category>::ptr_type
context_t::get(const std::string& type,
               Args&&... args)
{
    return m_repository->get<Category>(
        type,
        std::forward<Args>(args)...
    );
}

template<class Category>
boost::shared_ptr<api::factory_concept_t>
context_t::get_factory(const std::string& type)
{
    return m_repository->get_factory<Category>(type);
}

}
# 5 "../src/worker.cpp" 2
# 1 "/usr/include/cocaine/logging.hpp" 1 3 4
# 26 "/usr/include/cocaine/logging.hpp" 3 4
# 1 "/usr/include/cocaine/api/logger.hpp" 1 3 4
# 30 "/usr/include/cocaine/api/logger.hpp" 3 4
namespace cocaine { namespace api {

static inline
logging::priorities
resolve(const Json::Value& args) {
    const std::string& verbosity = args["verbosity"].asString();

    if(verbosity == "ignore") {
        return logging::ignore;
    } else if(verbosity == "debug") {
        return logging::debug;
    } else if(verbosity == "warning") {
        return logging::warning;
    } else if(verbosity == "error") {
        return logging::error;
    } else {
        return logging::info;
    }
}

class logger_t:
    public boost::noncopyable
{
    public:
        virtual
        ~logger_t() {

        }

        logging::priorities
        verbosity() const {
            return m_verbosity;
        }

        virtual
        void
        emit(logging::priorities priority,
             const std::string& source,
             const std::string& message) = 0;

    protected:
        logger_t(context_t&,
                 const std::string& ,
                 const Json::Value& args):
            m_verbosity(resolve(args))
        { }

    private:
        const logging::priorities m_verbosity;
};

template<>
struct category_traits<logger_t> {
    typedef std::unique_ptr<logger_t> ptr_type;

    struct factory_type:
        public factory_base<logger_t>
    {
        virtual
        ptr_type
        get(context_t& context,
            const std::string& name,
            const Json::Value& args) = 0;
    };

    template<class T>
    struct default_factory:
        public factory_type
    {
        virtual
        ptr_type
        get(context_t& context,
            const std::string& name,
            const Json::Value& args)
        {
            return ptr_type(new T(context, name, args));
        }
    };
};

static inline
category_traits<logger_t>::ptr_type
logger(context_t& context,
        const std::string& name)
{
    config_t::component_map_t::const_iterator it = context.config.loggers.find(name);

    if(it == context.config.loggers.end()) {
        throw configuration_error_t("the '%s' logger is not configured", name);
    }

    return context.get<logger_t>(
        it->second.type,
        context,
        name,
        it->second.args
    );
}

}}
# 27 "/usr/include/cocaine/logging.hpp" 2 3 4
# 45 "/usr/include/cocaine/logging.hpp" 3 4
namespace cocaine { namespace logging {

struct log_t {
    log_t(context_t& context,
          const std::string& source):
        m_logger(context.logger()),
        m_source(source)
    { }

    logging::priorities
    verbosity() const {
        return m_logger.verbosity();
    }

    template<typename... Args>
    void
    emit(logging::priorities level,
         const std::string& format,
         const Args&... args)
    {
        m_logger.emit(level, m_source, cocaine::format(format, args...));
    }

    void
    emit(logging::priorities level,
         const std::string& message)
    {
        m_logger.emit(level, m_source, message);
    }

private:
    api::logger_t& m_logger;


    const std::string m_source;
};

}}
# 6 "../src/worker.cpp" 2
# 1 "/usr/include/cocaine/manifest.hpp" 1 3 4
# 25 "/usr/include/cocaine/manifest.hpp" 3 4
# 1 "/usr/include/cocaine/cached.hpp" 1 3 4
# 27 "/usr/include/cocaine/cached.hpp" 3 4
# 1 "/usr/include/cocaine/api/storage.hpp" 1 3 4
# 31 "/usr/include/cocaine/api/storage.hpp" 3 4
# 1 "/usr/include/boost/ref.hpp" 1 3 4
# 29 "/usr/include/boost/ref.hpp" 3 4
namespace boost
{

template<class T> class reference_wrapper
{
public:
    typedef T type;







    explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}



    operator T& () const { return *t_; }

    T& get() const { return *t_; }

    T* get_pointer() const { return t_; }

private:

    T* t_;
};







template<class T> inline reference_wrapper<T> const ref(T & t)
{
    return reference_wrapper<T>(t);
}

template<class T> inline reference_wrapper<T const> const cref(T const & t)
{
    return reference_wrapper<T const>(t);
}





template<typename T>
class is_reference_wrapper
    : public mpl::false_
{
};

template<typename T>
class unwrap_reference
{
 public:
    typedef T type;
};
# 106 "/usr/include/boost/ref.hpp" 3 4
template<typename T> class is_reference_wrapper< reference_wrapper<T> > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> > { public: typedef T type; };

template<typename T> class is_reference_wrapper< reference_wrapper<T> const > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> volatile > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> const volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const volatile > { public: typedef T type; };
# 176 "/usr/include/boost/ref.hpp" 3 4
template <class T> inline typename unwrap_reference<T>::type&
unwrap_ref(T& t)
{
    return t;
}

template<class T> inline T* get_pointer( reference_wrapper<T> const & r )
{
    return r.get_pointer();
}

}
# 32 "/usr/include/cocaine/api/storage.hpp" 2 3 4

# 1 "/usr/include/boost/weak_ptr.hpp" 1 3 4
# 16 "/usr/include/boost/weak_ptr.hpp" 3 4
# 1 "/usr/include/boost/smart_ptr/weak_ptr.hpp" 1 3 4
# 25 "/usr/include/boost/smart_ptr/weak_ptr.hpp" 3 4
namespace boost
{

template<class T> class weak_ptr
{
private:


    typedef weak_ptr<T> this_type;

public:

    typedef T element_type;

    weak_ptr(): px(0), pn()
    {
    }
# 63 "/usr/include/boost/smart_ptr/weak_ptr.hpp" 3 4
    template<class Y>


    weak_ptr( weak_ptr<Y> const & r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : px(r.lock().get()), pn(r.pn)
    {
    }



    template<class Y>


    weak_ptr( weak_ptr<Y> && r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : px(r.lock().get()), pn(std::move(r.pn))
    {
        r.px = 0;
    }


    weak_ptr( weak_ptr && r ): px( r.px ), pn(std::move(r.pn))
    {
        r.px = 0;
    }


    weak_ptr & operator=( weak_ptr && r )
    {
        this_type( std::move( r ) ).swap( *this );
        return *this;
    }




    template<class Y>


    weak_ptr( shared_ptr<Y> const & r, typename detail::sp_enable_if_convertible<Y,T>::type = detail::sp_empty() )






    : px( r.px ), pn( r.pn )
    {
    }



    template<class Y>
    weak_ptr & operator=(weak_ptr<Y> const & r)
    {
        px = r.lock().get();
        pn = r.pn;
        return *this;
    }



    template<class Y>
    weak_ptr & operator=(weak_ptr<Y> && r)
    {
        this_type( std::move( r ) ).swap( *this );
        return *this;
    }



    template<class Y>
    weak_ptr & operator=(shared_ptr<Y> const & r)
    {
        px = r.px;
        pn = r.pn;
        return *this;
    }



    shared_ptr<T> lock() const
    {
        return shared_ptr<element_type>( *this, boost::detail::sp_nothrow_tag() );
    }

    long use_count() const
    {
        return pn.use_count();
    }

    bool expired() const
    {
        return pn.use_count() == 0;
    }

    bool _empty() const
    {
        return pn.empty();
    }

    void reset()
    {
        this_type().swap(*this);
    }

    void swap(this_type & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }

    void _internal_assign(T * px2, boost::detail::shared_count const & pn2)
    {
        px = px2;
        pn = pn2;
    }

    template<class Y> bool _internal_less(weak_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }






private:

    template<class Y> friend class weak_ptr;
    template<class Y> friend class shared_ptr;



    T * px;
    boost::detail::weak_count pn;

};

template<class T, class U> inline bool operator<(weak_ptr<T> const & a, weak_ptr<U> const & b)
{
    return a._internal_less(b);
}

template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b)
{
    a.swap(b);
}

}
# 17 "/usr/include/boost/weak_ptr.hpp" 2 3 4
# 34 "/usr/include/cocaine/api/storage.hpp" 2 3 4

namespace cocaine {

struct storage_error_t:
    public error_t
{
    template<typename... Args>
    storage_error_t(const std::string& format,
                    const Args&... args):
        error_t(format, args...)
    { }
};

namespace api {

class storage_t:
    public boost::noncopyable
{
    public:
        virtual
        ~storage_t() {

        }

        template<class T>
        T
        get(const std::string& collection,
            const std::string& key);

        template<class T>
        void
        put(const std::string& collection,
            const std::string& key,
            const T& object);

        virtual
        std::vector<std::string>
        list(const std::string& collection) = 0;

        virtual
        void
        remove(const std::string& collection,
               const std::string& key) = 0;

    protected:
        storage_t(context_t&,
                  const std::string& ,
                  const Json::Value& )
        { }

        virtual
        std::string
        read(const std::string& collection,
             const std::string& key) = 0;

        virtual
        void
        write(const std::string& collection,
              const std::string& key,
              const std::string& blob) = 0;
};

template<class T>
T
storage_t::get(const std::string& collection,
               const std::string& key)
{
    T result;
    msgpack::unpacked unpacked;

    std::string blob(read(collection, key));

    try {
        msgpack::unpack(&unpacked, blob.data(), blob.size());
    } catch(const msgpack::unpack_error& e) {
        throw storage_error_t("corrupted object");
    }

    try {
        io::type_traits<T>::unpack(unpacked.get(), result);
    } catch(const msgpack::type_error& e) {
        throw storage_error_t("corrupted object");
    } catch(const std::bad_cast& e) {
        throw storage_error_t("corrupted object - type mismatch");
    }

    return result;
}

template<class T>
void
storage_t::put(const std::string& collection,
               const std::string& key,
               const T& object)
{
    msgpack::sbuffer buffer;
    msgpack::packer<msgpack::sbuffer> packer(buffer);

    io::type_traits<T>::pack(packer, object);

    write(
        collection,
        key,
        std::string(buffer.data(), buffer.size())
    );
}

template<>
struct category_traits<storage_t> {
    typedef boost::shared_ptr<storage_t> ptr_type;

    struct factory_type:
        public factory_base<storage_t>
    {
        virtual
        ptr_type
        get(context_t& context,
            const std::string& name,
            const Json::Value& args) = 0;
    };

    template<class T>
    struct default_factory:
        public factory_type
    {
        virtual
        ptr_type
        get(context_t& context,
            const std::string& name,
            const Json::Value& args)
        {
            boost::lock_guard<boost::mutex> lock(m_mutex);

            typename instance_map_t::iterator it(m_instances.find(name));

            ptr_type instance;

            if(it != m_instances.end()) {
                instance = it->second.lock();
            }

            if(!instance) {
                instance = boost::make_shared<T>(
                    boost::ref(context),
                    name,
                    args
                );

                m_instances.emplace(name, instance);
            }

            return instance;
        }

    private:

        typedef boost::unordered_map<



            std::string,
            boost::weak_ptr<storage_t>
        > instance_map_t;

        instance_map_t m_instances;
        boost::mutex m_mutex;
    };
};

static inline
category_traits<storage_t>::ptr_type
storage(context_t& context,
        const std::string& name)
{
    config_t::component_map_t::const_iterator it(
        context.config.storages.find(name)
    );

    if(it == context.config.storages.end()) {
        throw configuration_error_t("the '%s' storage is not configured", name);
    }

    return context.get<storage_t>(
        it->second.type,
        context,
        name,
        it->second.args
    );
}

}}
# 28 "/usr/include/cocaine/cached.hpp" 2 3 4

namespace cocaine {

template<class T>
struct cached:
    protected T
{
    cached(context_t& context,
           const std::string& collection,
           const std::string& name);
};

template<class T>
cached<T>::cached(context_t& context,
                  const std::string& collection,
                  const std::string& name)
{
    T& object = static_cast<T&>(*this);

    auto cache = api::storage(context, "cache");

    try {

        object = cache->get<T>(collection, name);
    } catch(const storage_error_t& e) {
        auto storage = api::storage(context, "core");

        try {

            object = storage->get<T>(collection, name);
        } catch(const storage_error_t& e) {
            throw storage_error_t(
                "unable to fetch the '%s/%s' object from the storage - %s",
                collection,
                name,
                e.what()
            );
        }

        try {

            cache->put(collection, name, object);
        } catch(const storage_error_t& e) {
            throw storage_error_t(
                "unable to cache the '%s/%s' object - %s",
                collection,
                name,
                e.what()
            );
        }
    }
}

}
# 26 "/usr/include/cocaine/manifest.hpp" 2 3 4



namespace cocaine {

struct manifest_t:
    private cached<Json::Value>
{
    manifest_t(context_t& context,
               const std::string& name);

    std::string name;
    std::string slave;



    config_t::component_t sandbox;



    config_t::component_map_t drivers;
};

}
# 7 "../src/worker.cpp" 2
# 1 "/usr/include/cocaine/profile.hpp" 1 3 4
# 29 "/usr/include/cocaine/profile.hpp" 3 4
namespace cocaine {

struct profile_t:
    private cached<Json::Value>
{
    profile_t(context_t& context,
              const std::string& name);

    std::string name;

    float heartbeat_timeout;
    float idle_timeout;
    float startup_timeout;
    float termination_timeout;
    unsigned long pool_limit;
    unsigned long queue_limit;
    unsigned long grow_threshold;
    unsigned long concurrency;



    config_t::component_t isolate;
};

}
# 8 "../src/worker.cpp" 2

# 1 "/usr/include/cocaine/api/sandbox.hpp" 1 3 4
# 29 "/usr/include/cocaine/api/sandbox.hpp" 3 4
namespace cocaine { namespace api {

class sandbox_t:
    public boost::noncopyable
{
    public:
        virtual
        ~sandbox_t() {

        }

        virtual
        boost::shared_ptr<stream_t>
        invoke(const std::string& event,
               const boost::shared_ptr<stream_t>& upstream) = 0;

    protected:
        sandbox_t(context_t&,
                  const std::string& ,
                  const Json::Value& ,
                  const std::string& )
        { }
};

template<>
struct category_traits<sandbox_t> {
    typedef std::unique_ptr<sandbox_t> ptr_type;

    struct factory_type:
        public factory_base<sandbox_t>
    {
        virtual
        ptr_type
        get(context_t& context,
            const std::string& name,
            const Json::Value& args,
            const std::string& spool) = 0;
    };

    template<class T>
    struct default_factory:
        public factory_type
    {
        virtual
        ptr_type
        get(context_t& context,
            const std::string& name,
            const Json::Value& args,
            const std::string& spool)
        {
            return ptr_type(
                new T(context, name, args, spool)
            );
        }
    };
};

}}
# 10 "../src/worker.cpp" 2

# 1 "/usr/include/cocaine/traits/unique_id.hpp" 1 3 4
# 28 "/usr/include/cocaine/traits/unique_id.hpp" 3 4
namespace cocaine { namespace io {

template<>
struct type_traits<unique_id_t> {
    template<class Stream>
    static
    void
    pack(msgpack::packer<Stream>& packer,
         const unique_id_t& object)
    {
        packer.pack_array(2);

        packer << object.uuid[0];
        packer << object.uuid[1];
    }

    static
    void
    unpack(const msgpack::object& packed,
           unique_id_t& object)
    {
        if(packed.type != msgpack::type::ARRAY || packed.via.array.size != 2) {
            throw msgpack::type_error();
        }

        msgpack::object &_1 = packed.via.array.ptr[0],
                        &_2 = packed.via.array.ptr[1];

        _1 >> object.uuid[0];
        _2 >> object.uuid[1];
    }
};

}}
# 12 "../src/worker.cpp" 2

# 1 "/usr/include/boost/filesystem/path.hpp" 1 3 4
# 20 "/usr/include/boost/filesystem/path.hpp" 3 4
# 1 "/usr/include/boost/filesystem/config.hpp" 1 3 4
# 110 "/usr/include/boost/filesystem/config.hpp" 3 4
# 1 "/usr/include/boost/config/auto_link.hpp" 1 3 4
# 111 "/usr/include/boost/filesystem/config.hpp" 2 3 4
# 21 "/usr/include/boost/filesystem/path.hpp" 2 3 4
# 1 "/usr/include/boost/system/system_error.hpp" 1 3 4
# 13 "/usr/include/boost/system/system_error.hpp" 3 4
# 1 "/usr/include/c++/4.4/cassert" 1 3 4
# 43 "/usr/include/c++/4.4/cassert" 3 4
       
# 44 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 14 "/usr/include/boost/system/system_error.hpp" 2 3 4
# 1 "/usr/include/boost/system/error_code.hpp" 1 3 4
# 14 "/usr/include/boost/system/error_code.hpp" 3 4
# 1 "/usr/include/boost/system/config.hpp" 1 3 4
# 71 "/usr/include/boost/system/config.hpp" 3 4
# 1 "/usr/include/boost/config/auto_link.hpp" 1 3 4
# 72 "/usr/include/boost/system/config.hpp" 2 3 4
# 15 "/usr/include/boost/system/error_code.hpp" 2 3 4
# 1 "/usr/include/boost/cstdint.hpp" 1 3 4
# 16 "/usr/include/boost/system/error_code.hpp" 2 3 4
# 1 "/usr/include/boost/assert.hpp" 1 3 4
# 36 "/usr/include/boost/assert.hpp" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 37 "/usr/include/boost/assert.hpp" 2 3 4
# 17 "/usr/include/boost/system/error_code.hpp" 2 3 4
# 26 "/usr/include/boost/system/error_code.hpp" 3 4
# 1 "/usr/include/boost/cerrno.hpp" 1 3 4
# 13 "/usr/include/boost/cerrno.hpp" 3 4
# 1 "/usr/include/c++/4.4/cerrno" 1 3 4
# 41 "/usr/include/c++/4.4/cerrno" 3 4
       
# 42 "/usr/include/c++/4.4/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 44 "/usr/include/c++/4.4/cerrno" 2 3
# 14 "/usr/include/boost/cerrno.hpp" 2 3 4
# 27 "/usr/include/boost/system/error_code.hpp" 2 3 4





# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 33 "/usr/include/boost/system/error_code.hpp" 2 3 4

namespace boost
{
  namespace system
  {

    class error_code;
    class error_condition;



    template< class T >
    struct is_error_code_enum { static const bool value = false; };

    template< class T >
    struct is_error_condition_enum { static const bool value = false; };



    namespace errc
    {
      enum errc_t
      {
        success = 0,
        address_family_not_supported = 97,
        address_in_use = 98,
        address_not_available = 99,
        already_connected = 106,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 74,
        broken_pipe = 32,
        connection_aborted = 103,
        connection_already_in_progress = 114,
        connection_refused = 111,
        connection_reset = 104,
        cross_device_link = 18,
        destination_address_required = 89,
        device_or_resource_busy = 16,
        directory_not_empty = 39,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 36,
        function_not_supported = 38,
        host_unreachable = 113,
        identifier_removed = 43,
        illegal_byte_sequence = 84,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 90,
        network_down = 100,
        network_reset = 102,
        network_unreachable = 101,
        no_buffer_space = 105,
        no_child_process = 10,
        no_link = 67,
        no_lock_available = 37,
        no_message_available = 61,
        no_message = 42,
        no_protocol_option = 92,
        no_space_on_device = 28,
        no_stream_resources = 63,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 88,
        not_a_stream = 60,
        not_connected = 107,
        not_enough_memory = 12,
        not_supported = 95,
        operation_canceled = 125,
        operation_in_progress = 115,
        operation_not_permitted = 1,
        operation_not_supported = 95,
        operation_would_block = 11,
        owner_dead = 130,
        permission_denied = 13,
        protocol_error = 71,
        protocol_not_supported = 93,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 35,
        resource_unavailable_try_again = 11,
        result_out_of_range = 34,
        state_not_recoverable = 131,
        stream_timeout = 62,
        text_file_busy = 26,
        timed_out = 110,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_synbolic_link_levels = 40,
        value_too_large = 75,
        wrong_protocol_type = 91
      };

    }


    namespace posix = errc;
    namespace posix_error = errc;


    template<> struct is_error_condition_enum<errc::errc_t>
      { static const bool value = true; };
# 182 "/usr/include/boost/system/error_code.hpp" 3 4
    class error_category : public noncopyable
    {
    public:
      virtual ~error_category(){}
      virtual inline const char * name() const;
      virtual inline std::string message( int ev ) const;
      virtual inline error_condition default_error_condition( int ev ) const;
      virtual inline bool equivalent( int code, const error_condition & condition ) const;
      virtual inline bool equivalent( const error_code & code, int condition ) const;

      bool operator==(const error_category & rhs) const { return this == &rhs; }
      bool operator!=(const error_category & rhs) const { return this != &rhs; }
      bool operator<( const error_category & rhs ) const
      {
        return std::less<const error_category*>()( this, &rhs );
      }
    };



    const error_category & get_system_category();
    const error_category & get_generic_category();

    static const error_category & system_category = get_system_category();
    static const error_category & generic_category = get_generic_category();



    inline const error_category & get_posix_category() { return get_generic_category(); }
    static const error_category & posix_category = get_generic_category();
    static const error_category & errno_ecat = get_generic_category();
    static const error_category & native_ecat = get_system_category();






    class error_condition
    {
    public:


      error_condition() : m_val(0), m_cat(&get_generic_category()) {}
      error_condition( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}

      template <class ErrorConditionEnum>
        error_condition(ErrorConditionEnum e,
          typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum> >::type* = 0)
      {
        *this = make_error_condition(e);
      }



      void assign( int val, const error_category & cat )
      {
        m_val = val;
        m_cat = &cat;
      }

      template<typename ErrorConditionEnum>
        typename boost::enable_if<is_error_condition_enum<ErrorConditionEnum>, error_condition>::type &
          operator=( ErrorConditionEnum val )
      {
        *this = make_error_condition(val);
        return *this;
      }

      void clear()
      {
        m_val = 0;
        m_cat = &get_generic_category();
      }


      int value() const { return m_val; }
      const error_category & category() const { return *m_cat; }
      std::string message() const { return m_cat->message(value()); }

      typedef void (*unspecified_bool_type)();
      static void unspecified_bool_true() {}

      operator unspecified_bool_type() const
      {
        return m_val == 0 ? 0 : unspecified_bool_true;
      }

      bool operator!() const
      {
        return m_val == 0;
      }




      inline friend bool operator==( const error_condition & lhs,
                                     const error_condition & rhs )
      {
        return lhs.m_cat == rhs.m_cat && lhs.m_val == rhs.m_val;
      }

      inline friend bool operator<( const error_condition & lhs,
                                    const error_condition & rhs )


      {
        return lhs.m_cat < rhs.m_cat
          || (lhs.m_cat == rhs.m_cat && lhs.m_val < rhs.m_val);
      }

    private:
      int m_val;
      const error_category * m_cat;

    };
# 307 "/usr/include/boost/system/error_code.hpp" 3 4
    class error_code
    {
    public:


      error_code() : m_val(0), m_cat(&get_system_category()) {}
      error_code( int val, const error_category & cat ) : m_val(val), m_cat(&cat) {}

      template <class ErrorCodeEnum>
        error_code(ErrorCodeEnum e,
          typename boost::enable_if<is_error_code_enum<ErrorCodeEnum> >::type* = 0)
      {
        *this = make_error_code(e);
      }


      void assign( int val, const error_category & cat )
      {
        m_val = val;
        m_cat = &cat;
      }

      template<typename ErrorCodeEnum>
        typename boost::enable_if<is_error_code_enum<ErrorCodeEnum>, error_code>::type &
          operator=( ErrorCodeEnum val )
      {
        *this = make_error_code(val);
        return *this;
      }

      void clear()
      {
        m_val = 0;
        m_cat = &get_system_category();
      }


      int value() const { return m_val; }
      const error_category & category() const { return *m_cat; }
      error_condition default_error_condition() const { return m_cat->default_error_condition(value()); }
      std::string message() const { return m_cat->message(value()); }

      typedef void (*unspecified_bool_type)();
      static void unspecified_bool_true() {}

      operator unspecified_bool_type() const
      {
        return m_val == 0 ? 0 : unspecified_bool_true;
      }

      bool operator!() const
      {
        return m_val == 0;
      }


      inline friend bool operator==( const error_code & lhs,
                                     const error_code & rhs )


      {
        return lhs.m_cat == rhs.m_cat && lhs.m_val == rhs.m_val;
      }

      inline friend bool operator<( const error_code & lhs,
                                    const error_code & rhs )


      {
        return lhs.m_cat < rhs.m_cat
          || (lhs.m_cat == rhs.m_cat && lhs.m_val < rhs.m_val);
      }

      private:
      int m_val;
      const error_category * m_cat;

    };



    extern error_code throws;






  }

  namespace detail { inline system::error_code * throws() { return 0; } }
# 406 "/usr/include/boost/system/error_code.hpp" 3 4
  inline system::error_code & throws()
    { return *detail::throws(); }

  namespace system
  {


    inline bool operator!=( const error_code & lhs,
                            const error_code & rhs )
    {
      return !(lhs == rhs);
    }

    inline bool operator!=( const error_condition & lhs,
                            const error_condition & rhs )
    {
      return !(lhs == rhs);
    }

    inline bool operator==( const error_code & code,
                            const error_condition & condition )
    {
      return code.category().equivalent( code.value(), condition )
        || condition.category().equivalent( code, condition.value() );
    }

    inline bool operator!=( const error_code & lhs,
                            const error_condition & rhs )
    {
      return !(lhs == rhs);
    }

    inline bool operator==( const error_condition & condition,
                            const error_code & code )
    {
      return condition.category().equivalent( code, condition.value() )
        || code.category().equivalent( code.value(), condition );
    }

    inline bool operator!=( const error_condition & lhs,
                            const error_code & rhs )
    {
      return !(lhs == rhs);
    }



    template <class charT, class traits>
    inline std::basic_ostream<charT,traits>&
      operator<< (std::basic_ostream<charT,traits>& os, error_code ec)
    {
      os << ec.category().name() << ':' << ec.value();
      return os;
    }

    inline std::size_t hash_value( const error_code & ec )
    {
      return static_cast<std::size_t>(ec.value())
        + reinterpret_cast<std::size_t>(&ec.category());
    }



    namespace errc
    {

      inline error_code make_error_code( errc_t e )
        { return error_code( e, get_generic_category() ); }


      inline error_condition make_error_condition( errc_t e )
        { return error_condition( e, get_generic_category() ); }
    }



    inline error_condition error_category::default_error_condition( int ev ) const
    {
      return error_condition( ev, *this );
    }

    inline bool error_category::equivalent( int code,
      const error_condition & condition ) const
    {
      return default_error_condition( code ) == condition;
    }

    inline bool error_category::equivalent( const error_code & code,
      int condition ) const
    {
      return *this == code.category() && code.value() == condition;
    }



    inline const char * error_category::name() const
    {
      return "error: should never be called";
    }

    inline std::string error_category::message( int ) const
    {
      static std::string s("error: should never be called");
      return s;
    }

  }
}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 516 "/usr/include/boost/system/error_code.hpp" 2 3 4
# 15 "/usr/include/boost/system/system_error.hpp" 2 3 4

namespace boost
{
  namespace system
  {


    class system_error : public std::runtime_error
    {
    public:
      system_error( error_code ec )
          : std::runtime_error(""), m_error_code(ec) {}

      system_error( error_code ec, const std::string & what_arg )
          : std::runtime_error(what_arg), m_error_code(ec) {}

      system_error( error_code ec, const char* what_arg )
          : std::runtime_error(what_arg), m_error_code(ec) {}

      system_error( int ev, const error_category & ecat )
          : std::runtime_error(""), m_error_code(ev,ecat) {}

      system_error( int ev, const error_category & ecat,
        const std::string & what_arg )
          : std::runtime_error(what_arg), m_error_code(ev,ecat) {}

      system_error( int ev, const error_category & ecat,
        const char * what_arg )
          : std::runtime_error(what_arg), m_error_code(ev,ecat) {}

      virtual ~system_error() throw() {}

      const error_code & code() const throw() { return m_error_code; }
      const char * what() const throw();

    private:
      error_code m_error_code;
      mutable std::string m_what;
    };



    inline const char * system_error::what() const throw()

    {
      if ( m_what.empty() )
      {
        try
        {
          m_what = this->std::runtime_error::what();
          if ( m_error_code )
          {
            if ( !m_what.empty() ) m_what += ": ";
            m_what += m_error_code.message();
          }
        }
        catch (...) { return std::runtime_error::what(); }
      }
      return m_what.c_str();
    }

  }
}
# 22 "/usr/include/boost/filesystem/path.hpp" 2 3 4
# 1 "/usr/include/boost/iterator/iterator_facade.hpp" 1 3 4
# 11 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
# 1 "/usr/include/boost/iterator/interoperable.hpp" 1 3 4
# 15 "/usr/include/boost/iterator/interoperable.hpp" 3 4
# 1 "/usr/include/boost/iterator/detail/config_def.hpp" 1 3 4
# 16 "/usr/include/boost/iterator/interoperable.hpp" 2 3 4

namespace boost
{
# 34 "/usr/include/boost/iterator/interoperable.hpp" 3 4
  template <typename A, typename B>
  struct is_interoperable



    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >

  {
  };

}

# 1 "/usr/include/boost/iterator/detail/config_undef.hpp" 1 3 4
# 49 "/usr/include/boost/iterator/interoperable.hpp" 2 3 4
# 12 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4
# 1 "/usr/include/boost/iterator/iterator_traits.hpp" 1 3 4
# 11 "/usr/include/boost/iterator/iterator_traits.hpp" 3 4
namespace boost {
# 27 "/usr/include/boost/iterator/iterator_traits.hpp" 3 4
template <class Iterator>
struct iterator_value
{
    typedef typename boost::detail::iterator_traits<Iterator>::value_type type;
};

template <class Iterator>
struct iterator_reference
{
    typedef typename boost::detail::iterator_traits<Iterator>::reference type;
};


template <class Iterator>
struct iterator_pointer
{
    typedef typename boost::detail::iterator_traits<Iterator>::pointer type;
};

template <class Iterator>
struct iterator_difference
{
    typedef typename boost::detail::iterator_traits<Iterator>::difference_type type;
};

template <class Iterator>
struct iterator_category
{
    typedef typename boost::detail::iterator_traits<Iterator>::iterator_category type;
};
# 90 "/usr/include/boost/iterator/iterator_traits.hpp" 3 4
}
# 13 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4

# 1 "/usr/include/boost/iterator/detail/facade_iterator_category.hpp" 1 3 4
# 17 "/usr/include/boost/iterator/detail/facade_iterator_category.hpp" 3 4
# 1 "/usr/include/boost/type_traits/is_const.hpp" 1 3 4
# 43 "/usr/include/boost/type_traits/is_const.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 44 "/usr/include/boost/type_traits/is_const.hpp" 2 3 4

namespace boost {
# 57 "/usr/include/boost/type_traits/is_const.hpp" 3 4
   template< typename T > struct is_const : ::boost::integral_constant<bool,::boost::detail::cv_traits_imp<T*>::is_const> { };

template< typename T > struct is_const< T& > : ::boost::integral_constant<bool,false> { };
# 141 "/usr/include/boost/type_traits/is_const.hpp" 3 4
}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 144 "/usr/include/boost/type_traits/is_const.hpp" 2 3 4
# 18 "/usr/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3 4





# 1 "/usr/include/boost/iterator/detail/config_def.hpp" 1 3 4
# 24 "/usr/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3 4


# 1 "/usr/include/boost/detail/indirect_traits.hpp" 1 3 4






# 1 "/usr/include/boost/type_traits/is_function.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/is_function.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/false_result.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/false_result.hpp" 3 4
namespace boost {
namespace type_traits {


struct false_result
{
    template <typename T> struct result_
    {
        static const bool value = false;
    };
};

}}
# 16 "/usr/include/boost/type_traits/is_function.hpp" 2 3 4



# 1 "/usr/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 1 3 4
# 26 "/usr/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 3 4
namespace boost {
namespace type_traits {

template <class R>
struct is_function_ptr_helper
{
    static const bool value = false;
};




template <class R >
struct is_function_ptr_helper<R (*)()> { static const bool value = true; };

template <class R >
struct is_function_ptr_helper<R (*)( ...)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0)> { static const bool value = true; };

template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0 ...)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1)> { static const bool value = true; };

template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24)> { static const bool value = true; };

template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...)> { static const bool value = true; };
# 203 "/usr/include/boost/type_traits/detail/is_function_ptr_helper.hpp" 3 4
}
}
# 20 "/usr/include/boost/type_traits/is_function.hpp" 2 3 4






# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 27 "/usr/include/boost/type_traits/is_function.hpp" 2 3 4







namespace boost {



namespace detail {


template<bool is_ref = true>
struct is_function_chooser
    : ::boost::type_traits::false_result
{
};

template <>
struct is_function_chooser<false>
{
    template< typename T > struct result_
        : ::boost::type_traits::is_function_ptr_helper<T*>
    {
    };
};

template <typename T>
struct is_function_impl
    : is_function_chooser< ::boost::is_reference<T>::value >
        ::template result_<T>
{
};
# 90 "/usr/include/boost/type_traits/is_function.hpp" 3 4
}






template< typename T > struct is_function : ::boost::integral_constant<bool,::boost::detail::is_function_impl<T>::value> { };

}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 102 "/usr/include/boost/type_traits/is_function.hpp" 2 3 4
# 8 "/usr/include/boost/detail/indirect_traits.hpp" 2 3 4


# 1 "/usr/include/boost/type_traits/is_class.hpp" 1 3 4
# 37 "/usr/include/boost/type_traits/is_class.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/bool_trait_def.hpp" 2 3 4
# 38 "/usr/include/boost/type_traits/is_class.hpp" 2 3 4

namespace boost {

namespace detail {
# 120 "/usr/include/boost/type_traits/is_class.hpp" 3 4
template <typename T>
struct is_class_impl
{
    static const bool value = __is_class(T);
};


}





template< typename T > struct is_class : ::boost::integral_constant<bool,::boost::detail::is_class_impl<T>::value> { };


}

# 1 "/usr/include/boost/type_traits/detail/bool_trait_undef.hpp" 1 3 4
# 139 "/usr/include/boost/type_traits/is_class.hpp" 2 3 4
# 11 "/usr/include/boost/detail/indirect_traits.hpp" 2 3 4






# 1 "/usr/include/boost/type_traits/remove_pointer.hpp" 1 3 4
# 21 "/usr/include/boost/type_traits/remove_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 22 "/usr/include/boost/type_traits/remove_pointer.hpp" 2 3 4

namespace boost {



template< typename T > struct remove_pointer { typedef T type; };
template< typename T > struct remove_pointer<T*> { typedef T type; };
template< typename T > struct remove_pointer<T* const> { typedef T type; };
template< typename T > struct remove_pointer<T* volatile> { typedef T type; };
template< typename T > struct remove_pointer<T* const volatile> { typedef T type; };







}

# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 42 "/usr/include/boost/type_traits/remove_pointer.hpp" 2 3 4
# 18 "/usr/include/boost/detail/indirect_traits.hpp" 2 3 4
# 33 "/usr/include/boost/detail/indirect_traits.hpp" 3 4
namespace boost { namespace detail {

namespace indirect_traits {


template <class T>
struct is_reference_to_const : mpl::false_
{
};

template <class T>
struct is_reference_to_const<T const&> : mpl::true_
{
};
# 55 "/usr/include/boost/detail/indirect_traits.hpp" 3 4
template <class T>
struct is_reference_to_function : mpl::false_
{
};

template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};

template <class T>
struct is_pointer_to_function : mpl::false_
{
};



template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl : mpl::false_
{
};

template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};


template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
   
};

template <class T>
struct is_reference_to_function_pointer_aux
    : mpl::and_<
          is_reference<T>
        , is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{

};

template <class T>
struct is_reference_to_function_pointer
    : mpl::if_<
          is_reference_to_function<T>
        , mpl::false_
        , is_reference_to_function_pointer_aux<T>
     >::type
{
};

template <class T>
struct is_reference_to_non_const
    : mpl::and_<
          is_reference<T>
        , mpl::not_<
             is_reference_to_const<T>
          >
      >
{
};

template <class T>
struct is_reference_to_volatile : mpl::false_
{
};

template <class T>
struct is_reference_to_volatile<T volatile&> : mpl::true_
{
};
# 149 "/usr/include/boost/detail/indirect_traits.hpp" 3 4
template <class T>
struct is_reference_to_pointer : mpl::false_
{
};

template <class T>
struct is_reference_to_pointer<T*&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_pointer<T* const volatile&> : mpl::true_
{
};

template <class T>
struct is_reference_to_class
    : mpl::and_<
          is_reference<T>
        , is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{
   
};

template <class T>
struct is_pointer_to_class
    : mpl::and_<
          is_pointer<T>
        , is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >
      >
{
   
};
# 481 "/usr/include/boost/detail/indirect_traits.hpp" 3 4
}

using namespace indirect_traits;

}}
# 27 "/usr/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3 4







namespace boost { struct use_default; }

namespace boost { namespace detail {

struct input_output_iterator_tag
  : std::input_iterator_tag
{






    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};






template <class ValueParam, class Reference>
struct iterator_writability_disabled

  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >



{};
# 86 "/usr/include/boost/iterator/detail/facade_iterator_category.hpp" 3 4
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>


              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};


template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};

template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};







template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{




    enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) ( is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >))0, 1 ) ) ) };





    enum { mpl_assertion_in_line_151 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_category<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_152 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_153 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_traversal<Category>))0, 1 ) ) ) };

    enum { mpl_assertion_in_line_155 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_traversal<Traversal>))0, 1 ) ) ) };


};



template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{

    enum { mpl_assertion_in_line_166 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };


    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;

    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};




template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};

}}

# 1 "/usr/include/boost/iterator/detail/config_undef.hpp" 1 3 4
# 199 "/usr/include/boost/iterator/detail/facade_iterator_category.hpp" 2 3 4
# 15 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4
# 1 "/usr/include/boost/iterator/detail/enable_if.hpp" 1 3 4
# 13 "/usr/include/boost/iterator/detail/enable_if.hpp" 3 4
# 1 "/usr/include/boost/iterator/detail/config_def.hpp" 1 3 4
# 14 "/usr/include/boost/iterator/detail/enable_if.hpp" 2 3 4







namespace boost
{

  namespace iterators
  {



    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };






    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
# 62 "/usr/include/boost/iterator/detail/enable_if.hpp" 3 4
      };
    };


    template <class Cond,
              class Return>
    struct enable_if

      : enabled<(Cond::value)>::template base<Return>



    {



    };

  }

}

# 1 "/usr/include/boost/iterator/detail/config_undef.hpp" 1 3 4
# 85 "/usr/include/boost/iterator/detail/enable_if.hpp" 2 3 4
# 16 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4

# 1 "/usr/include/boost/implicit_cast.hpp" 1 3 4
# 10 "/usr/include/boost/implicit_cast.hpp" 3 4
namespace boost {






template <typename T>
inline T implicit_cast (typename mpl::identity<T>::type x) {
    return x;
}





}
# 18 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4



# 1 "/usr/include/boost/type_traits/add_const.hpp" 1 3 4
# 16 "/usr/include/boost/type_traits/add_const.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 17 "/usr/include/boost/type_traits/add_const.hpp" 2 3 4

namespace boost {
# 33 "/usr/include/boost/type_traits/add_const.hpp" 3 4
template< typename T > struct add_const { typedef T const type; };






template< typename T > struct add_const<T&> { typedef T& type; };


}

# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 46 "/usr/include/boost/type_traits/add_const.hpp" 2 3 4
# 22 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4
# 1 "/usr/include/boost/type_traits/add_pointer.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/add_pointer.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 1 3 4
# 14 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 3 4
# 1 "/usr/include/boost/type_traits/detail/template_arity_spec.hpp" 1 3 4
# 15 "/usr/include/boost/type_traits/detail/type_trait_def.hpp" 2 3 4
# 16 "/usr/include/boost/type_traits/add_pointer.hpp" 2 3 4

namespace boost {

namespace detail {
# 55 "/usr/include/boost/type_traits/add_pointer.hpp" 3 4
template <typename T>
struct add_pointer_impl
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};



}

template< typename T > struct add_pointer { typedef typename boost::detail::add_pointer_impl<T>::type type; };

}

# 1 "/usr/include/boost/type_traits/detail/type_trait_undef.hpp" 1 3 4
# 71 "/usr/include/boost/type_traits/add_pointer.hpp" 2 3 4
# 23 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4
# 34 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
# 1 "/usr/include/boost/mpl/apply.hpp" 1 3 4
# 35 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4


# 1 "/usr/include/boost/iterator/detail/config_def.hpp" 1 3 4
# 38 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4

namespace boost
{


  template <class I, class V, class TC, class R, class D> class iterator_facade;

  namespace detail
  {



    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };




    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable
# 80 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
      : ::boost::iterators::enable_if<
           mpl::or_<
               is_convertible<Facade1, Facade2>
             , is_convertible<Facade2, Facade1>
           >
         , Return
        >
    {};






    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;

        typedef typename remove_const<ValueParam>::type value_type;

        typedef typename mpl::eval_if<
            boost::detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
# 130 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
    };







    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}





        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };





    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}





        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }


        operator value_type&() const
        {
            return stored_value;
        }


        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }


        operator Iterator const&() const
        {
            return stored_iterator;
        }

     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
# 244 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
# 269 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<

                is_convertible<Reference,Value const&>



              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};





    template <class T>
    struct operator_arrow_proxy
    {
        operator_arrow_proxy(T const* px) : m_value(*px) {}
        T* operator->() const { return &m_value; }


        operator T*() const { return &m_value; }
        mutable T m_value;
    };




    template <class ValueType, class Reference, class Pointer>
    struct operator_arrow_result
    {



        typedef typename mpl::if_<
            is_reference<Reference>
          , Pointer
          , operator_arrow_proxy<ValueType>
        >::type type;

        static type make(Reference x)
        {
            return implicit_cast<type>(&x);
        }
    };
# 342 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
    template <class Iterator>
    class operator_brackets_proxy
    {


        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;

     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}

        operator reference() const
        {
            return *m_iter;
        }

        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }

     private:
        Iterator m_iter;
    };



    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<


                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};

    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };

    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }

    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }

    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :
# 420 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >

        {};

    };
  }
# 471 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
  class iterator_core_access
  {






      template <class I, class V, class TC, class R, class D> friend class iterator_facade;




      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);

      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);


      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)

      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)




      ;

      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)




      ;



      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }

      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }

      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }

      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }

      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }

      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }

      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }




      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }

      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }

   private:

      iterator_core_access();
  };





  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade






  {
   private:



      Derived& derived()
      {
          return *static_cast<Derived*>(this);
      }

      Derived const& derived() const
      {
          return *static_cast<Derived const*>(this);
      }

      typedef boost::detail::iterator_facade_types<
         Value, CategoryOrTraversal, Reference, Difference
      > associated_types;

   protected:

      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;

   public:

      typedef typename associated_types::value_type value_type;
      typedef Reference reference;
      typedef Difference difference_type;
      typedef typename associated_types::pointer pointer;
      typedef typename associated_types::iterator_category iterator_category;

      reference operator*() const
      {
          return iterator_core_access::dereference(this->derived());
      }

      typename boost::detail::operator_arrow_result<
          value_type
        , reference
        , pointer
      >::type
      operator->() const
      {
          return boost::detail::operator_arrow_result<
              value_type
            , reference
            , pointer
          >::make(*this->derived());
      }

      typename boost::detail::operator_brackets_result<Derived,Value,reference>::type
      operator[](difference_type n) const
      {
          typedef boost::detail::use_operator_brackets_proxy<Value,Reference> use_proxy;

          return boost::detail::make_operator_brackets_result<Derived>(
              this->derived() + n
            , use_proxy()
          );
      }

      Derived& operator++()
      {
          iterator_core_access::increment(this->derived());
          return this->derived();
      }
# 679 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
      Derived& operator--()
      {
          iterator_core_access::decrement(this->derived());
          return this->derived();
      }

      Derived operator--(int)
      {
          Derived tmp(this->derived());
          --*this;
          return tmp;
      }

      Derived& operator+=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), n);
          return this->derived();
      }

      Derived& operator-=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), -n);
          return this->derived();
      }

      Derived operator-(difference_type x) const
      {
          Derived result(this->derived());
          return result -= x;
      }
# 721 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
  };


  template <class I, class V, class TC, class R, class D>
  inline typename boost::detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename boost::detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));

      ++i;

      return tmp;
  }
# 836 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }

  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }



  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
# 862 "/usr/include/boost/iterator/iterator_facade.hpp" 3 4
template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }




template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }






}

# 1 "/usr/include/boost/iterator/detail/config_undef.hpp" 1 3 4
# 877 "/usr/include/boost/iterator/iterator_facade.hpp" 2 3 4
# 23 "/usr/include/boost/filesystem/path.hpp" 2 3 4
# 32 "/usr/include/boost/filesystem/path.hpp" 3 4
# 1 "/usr/include/c++/4.4/cassert" 1 3 4
# 43 "/usr/include/c++/4.4/cassert" 3 4
       
# 44 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 33 "/usr/include/boost/filesystem/path.hpp" 2 3 4





# 1 "/usr/include/boost/config/abi_prefix.hpp" 1 3 4
# 39 "/usr/include/boost/filesystem/path.hpp" 2 3 4



namespace boost
{
  namespace filesystem
  {
    template<class String, class Traits> class basic_path;

    struct path_traits;
    typedef basic_path< std::string, path_traits > path;

    struct path_traits
    {
      typedef std::string internal_string_type;
      typedef std::string external_string_type;
      static external_string_type to_external( const path &,
        const internal_string_type & src ) { return src; }
      static internal_string_type to_internal(
        const external_string_type & src ) { return src; }
    };



    struct wpath_traits;

    typedef basic_path< std::wstring, wpath_traits > wpath;

    struct wpath_traits
    {
      typedef std::wstring internal_string_type;







      typedef std::string external_string_type;
      static external_string_type to_external( const wpath & ph,
        const internal_string_type & src );
      static internal_string_type to_internal(
        const external_string_type & src );

      static void imbue( const std::locale & loc );
      static bool imbue( const std::locale & loc, const std::nothrow_t & );
    };





    template<class Path> struct is_basic_path
      { static const bool value = false; };
    template<> struct is_basic_path<path>
      { static const bool value = true; };

    template<> struct is_basic_path<wpath>
      { static const bool value = true; };





    template<class Path> struct slash
      { static const char value = '/'; };

    template<class Path> struct dot
      { static const char value = '.'; };

    template<class Path> struct colon
      { static const char value = ':'; };


    template<> struct slash<wpath>
      { static const wchar_t value = L'/'; };
    template<> struct dot<wpath>
      { static const wchar_t value = L'.'; };
    template<> struct colon<wpath>
      { static const wchar_t value = L':'; };
# 131 "/usr/include/boost/filesystem/path.hpp" 3 4
    namespace detail
    {
      template<class Path>
      class iterator_helper
      {
      public:
        typedef typename Path::iterator iterator;
        static void do_increment( iterator & ph );
        static void do_decrement( iterator & ph );
      };
    }



    template<class String, class Traits>
    class basic_path
    {







    public:


      typedef basic_path<String, Traits> path_type;
      typedef String string_type;
      typedef typename String::value_type value_type;
      typedef Traits traits_type;
      typedef typename Traits::external_string_type external_string_type;


      basic_path() {}
      basic_path( const string_type & s ) { operator/=( s ); }
      basic_path( const value_type * s ) { operator/=( s ); }

        template <class InputIterator>
          basic_path( InputIterator first, InputIterator last )
            { append( first, last ); }

     ~basic_path() {}


      basic_path & operator=( const string_type & s )
      {



        m_path.erase( m_path.begin(), m_path.end() );

        operator/=( s );
        return *this;
      }
      basic_path & operator=( const value_type * s )
      {



        m_path.erase( m_path.begin(), m_path.end() );

        operator/=( s );
        return *this;
      }

        template <class InputIterator>
          basic_path & assign( InputIterator first, InputIterator last )
            { m_path.clear(); append( first, last ); return *this; }



      basic_path & operator/=( const basic_path & rhs ) { return operator /=( rhs.string().c_str() ); }
      basic_path & operator/=( const string_type & rhs ) { return operator /=( rhs.c_str() ); }
      basic_path & operator/=( const value_type * s );

        template <class InputIterator>
          basic_path & append( InputIterator first, InputIterator last );


      void clear()
      {



        m_path.erase( m_path.begin(), m_path.end() );

      }

      void swap( basic_path & rhs )
      {
        m_path.swap( rhs.m_path );



      }

      basic_path & remove_filename();
      basic_path & replace_extension( const string_type & new_extension = string_type() );


      basic_path & remove_leaf() { return remove_filename(); }



      const string_type & string() const { return m_path; }
      const string_type file_string() const;
      const string_type directory_string() const { return file_string(); }

      const external_string_type external_file_string() const { return Traits::to_external( *this, file_string() ); }
      const external_string_type external_directory_string() const { return Traits::to_external( *this, directory_string() ); }

      basic_path root_path() const;
      string_type root_name() const;
      string_type root_directory() const;
      basic_path relative_path() const;
      basic_path parent_path() const;
      string_type filename() const;
      string_type stem() const;
      string_type extension() const;


      string_type leaf() const { return filename(); }
      basic_path branch_path() const { return parent_path(); }
      bool has_leaf() const { return !m_path.empty(); }
      bool has_branch_path() const { return !parent_path().empty(); }


      bool empty() const { return m_path.empty(); }
      bool is_complete() const;
      bool has_root_path() const;
      bool has_root_name() const;
      bool has_root_directory() const;
      bool has_relative_path() const { return !relative_path().empty(); }
      bool has_filename() const { return !m_path.empty(); }
      bool has_parent_path() const { return !parent_path().empty(); }


      class iterator : public boost::iterator_facade<
        iterator,
        string_type const,
        boost::bidirectional_traversal_tag >
      {
      private:
        friend class boost::iterator_core_access;
        friend class boost::filesystem::basic_path<String, Traits>;

        const string_type & dereference() const
          { return m_name; }
        bool equal( const iterator & rhs ) const
          { return m_path_ptr == rhs.m_path_ptr && m_pos == rhs.m_pos; }

        friend class boost::filesystem::detail::iterator_helper<path_type>;

        void increment()
        {
          boost::filesystem::detail::iterator_helper<path_type>::do_increment(
            *this );
        }
        void decrement()
        {
          boost::filesystem::detail::iterator_helper<path_type>::do_decrement(
            *this );
        }

        string_type m_name;
        const basic_path * m_path_ptr;
        typename string_type::size_type m_pos;



      };

      typedef iterator const_iterator;

      iterator begin() const;
      iterator end() const;

    private:
# 319 "/usr/include/boost/filesystem/path.hpp" 3 4
      string_type m_path;







      void m_append_separator_if_needed();
      void m_append( value_type value );



      friend class iterator;
      friend class boost::filesystem::detail::iterator_helper<path_type>;




    public:
      typedef bool (*name_check)( const std::string & name );
      basic_path( const string_type & str, name_check ) { operator/=( str ); }
      basic_path( const typename string_type::value_type * s, name_check )
        { operator/=( s );}
      string_type native_file_string() const { return file_string(); }
      string_type native_directory_string() const { return directory_string(); }
      static bool default_name_check_writable() { return false; }
      static void default_name_check( name_check ) {}
      static name_check default_name_check() { return 0; }
      basic_path & canonize();
      basic_path & normalize();

    };



    template< class String, class Traits >
    inline void swap( basic_path<String, Traits> & lhs,
               basic_path<String, Traits> & rhs ) { lhs.swap( rhs ); }

    template< class String, class Traits >
    bool operator<( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs )
    {
      return std::lexicographical_compare(
        lhs.begin(), lhs.end(), rhs.begin(), rhs.end() );
    }

    template< class String, class Traits >
    bool operator<( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs )
    {
      basic_path<String, Traits> tmp( lhs );
      return std::lexicographical_compare(
        tmp.begin(), tmp.end(), rhs.begin(), rhs.end() );
    }

    template< class String, class Traits >
    bool operator<( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs )
    {
      basic_path<String, Traits> tmp( lhs );
      return std::lexicographical_compare(
        tmp.begin(), tmp.end(), rhs.begin(), rhs.end() );
    }

    template< class String, class Traits >
    bool operator<( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
    {
      basic_path<String, Traits> tmp( rhs );
      return std::lexicographical_compare(
        lhs.begin(), lhs.end(), tmp.begin(), tmp.end() );
    }

    template< class String, class Traits >
    bool operator<( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
    {
      basic_path<String, Traits> tmp( rhs );
      return std::lexicographical_compare(
        lhs.begin(), lhs.end(), tmp.begin(), tmp.end() );
    }





    template< class String, class Traits >
    inline bool operator==( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs )
    {
      return lhs.string() == rhs.string();
    }

    template< class String, class Traits >
    inline bool operator==( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs )
    {
      return lhs == rhs.string();
    }

    template< class String, class Traits >
    inline bool operator==( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs )
    {
      return lhs == rhs.string();
    }

    template< class String, class Traits >
    inline bool operator==( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
    {
      return lhs.string() == rhs;
    }

    template< class String, class Traits >
    inline bool operator==( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
    {
      return lhs.string() == rhs;
    }

    template< class String, class Traits >
    inline bool operator!=( const basic_path<String, Traits> & lhs,
      const basic_path<String, Traits> & rhs )
        { return !(lhs == rhs); }

    template< class String, class Traits >
    inline bool operator!=( const typename basic_path<String,
      Traits>::string_type::value_type * lhs,
        const basic_path<String, Traits> & rhs )
        { return !(lhs == rhs); }

    template< class String, class Traits >
    inline bool operator!=( const typename basic_path<String, Traits>::string_type & lhs,
      const basic_path<String, Traits> & rhs )
        { return !(lhs == rhs); }

    template< class String, class Traits >
    inline bool operator!=( const basic_path<String, Traits> & lhs,
      const typename basic_path<String, Traits>::string_type::value_type * rhs )
        { return !(lhs == rhs); }

    template< class String, class Traits >
    inline bool operator!=( const basic_path<String, Traits> & lhs,
      const typename basic_path<String, Traits>::string_type & rhs )
        { return !(lhs == rhs); }

    template< class String, class Traits >
    inline bool operator>( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs ) { return rhs < lhs; }

    template< class String, class Traits >
    inline bool operator>( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs ) { return rhs < basic_path<String, Traits>(lhs); }

    template< class String, class Traits >
    inline bool operator>( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs ) { return rhs < basic_path<String, Traits>(lhs); }

    template< class String, class Traits >
    inline bool operator>( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
                    { return basic_path<String, Traits>(rhs) < lhs; }

    template< class String, class Traits >
    inline bool operator>( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
                    { return basic_path<String, Traits>(rhs) < lhs; }

    template< class String, class Traits >
    inline bool operator<=( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs ) { return !(rhs < lhs); }

    template< class String, class Traits >
    inline bool operator<=( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs ) { return !(rhs < basic_path<String, Traits>(lhs)); }

    template< class String, class Traits >
    inline bool operator<=( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs ) { return !(rhs < basic_path<String, Traits>(lhs)); }

    template< class String, class Traits >
    inline bool operator<=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
                    { return !(basic_path<String, Traits>(rhs) < lhs); }

    template< class String, class Traits >
    inline bool operator<=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
                    { return !(basic_path<String, Traits>(rhs) < lhs); }

    template< class String, class Traits >
    inline bool operator>=( const basic_path<String, Traits> & lhs, const basic_path<String, Traits> & rhs ) { return !(lhs < rhs); }

    template< class String, class Traits >
    inline bool operator>=( const typename basic_path<String, Traits>::string_type::value_type * lhs,
                    const basic_path<String, Traits> & rhs ) { return !(lhs < basic_path<String, Traits>(rhs)); }

    template< class String, class Traits >
    inline bool operator>=( const typename basic_path<String, Traits>::string_type & lhs,
                    const basic_path<String, Traits> & rhs ) { return !(lhs < basic_path<String, Traits>(rhs)); }

    template< class String, class Traits >
    inline bool operator>=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type::value_type * rhs )
                    { return !(basic_path<String, Traits>(lhs) < rhs); }

    template< class String, class Traits >
    inline bool operator>=( const basic_path<String, Traits> & lhs,
                    const typename basic_path<String, Traits>::string_type & rhs )
                    { return !(basic_path<String, Traits>(lhs) < rhs); }



    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const basic_path<String, Traits> & lhs,
      const basic_path<String, Traits> & rhs )
      { return basic_path<String, Traits>( lhs ) /= rhs; }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const basic_path<String, Traits> & lhs,
      const typename String::value_type * rhs )
      { return basic_path<String, Traits>( lhs ) /=
          basic_path<String, Traits>( rhs ); }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const basic_path<String, Traits> & lhs, const String & rhs )
      { return basic_path<String, Traits>( lhs ) /=
          basic_path<String, Traits>( rhs ); }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const typename String::value_type * lhs,
      const basic_path<String, Traits> & rhs )
      { return basic_path<String, Traits>( lhs ) /= rhs; }

    template< class String, class Traits >
    inline basic_path<String, Traits> operator/(
      const String & lhs, const basic_path<String, Traits> & rhs )
      { return basic_path<String, Traits>( lhs ) /= rhs; }





    template< class Path >
    std::basic_ostream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type > &
      operator<<
      ( std::basic_ostream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type >& os, const Path & ph )
    {
      os << ph.string();
      return os;
    }

    template< class Path >
    std::basic_istream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type > &
      operator>>
      ( std::basic_istream< typename Path::string_type::value_type,
      typename Path::string_type::traits_type >& is, Path & ph )
    {
      typename Path::string_type str;
      is >> str;
      ph = str;
      return is;
    }
# 622 "/usr/include/boost/filesystem/path.hpp" 3 4
    namespace detail
    {

      inline
      const char * what( const char * sys_err_what,
        const path & path1_arg, const path & path2_arg, std::string & target )
      {
        try
        {
          if ( target.empty() )
          {
            target = sys_err_what;
            if ( !path1_arg.empty() )
            {
              target += ": \"";
              target += path1_arg.file_string();
              target += "\"";
            }
            if ( !path2_arg.empty() )
            {
              target += ", \"";
              target += path2_arg.file_string();
              target += "\"";
            }
          }
          return target.c_str();
        }
        catch (...)
        {
          return sys_err_what;
        }
      }

      template<class Path>
      const char * what( const char * sys_err_what,
        const Path & , const Path & , std::string & )
      {
        return sys_err_what;
      }
    }



    template<class Path>
    class basic_filesystem_error : public system::system_error
    {

    public:


      typedef Path path_type;

      basic_filesystem_error( const std::string & what_arg,
        system::error_code ec );

      basic_filesystem_error( const std::string & what_arg,
        const path_type & path1_arg, system::error_code ec );

      basic_filesystem_error( const std::string & what_arg, const path_type & path1_arg,
        const path_type & path2_arg, system::error_code ec );

      ~basic_filesystem_error() throw() {}

      const path_type & path1() const
      {
        static const path_type empty_path;
        return m_imp_ptr.get() ? m_imp_ptr->m_path1 : empty_path ;
      }
      const path_type & path2() const
      {
        static const path_type empty_path;
        return m_imp_ptr.get() ? m_imp_ptr->m_path2 : empty_path ;
      }

      const char * what() const throw()
      {
        if ( !m_imp_ptr.get() )
          return system::system_error::what();
        return detail::what( system::system_error::what(), m_imp_ptr->m_path1,
          m_imp_ptr->m_path2, m_imp_ptr->m_what );
      }

    private:
      struct m_imp
      {
        path_type m_path1;
        path_type m_path2;
        std::string m_what;
      };
      boost::shared_ptr<m_imp> m_imp_ptr;
    };

    typedef basic_filesystem_error<path> filesystem_error;


    typedef basic_filesystem_error<wpath> wfilesystem_error;




    bool portable_posix_name( const std::string & name );
    bool windows_name( const std::string & name );
    bool portable_name( const std::string & name );
    bool portable_directory_name( const std::string & name );
    bool portable_file_name( const std::string & name );
    bool native( const std::string & name );
    inline bool no_check( const std::string & )
      { return true; }



    namespace detail
    {



      template<class Path>
      inline bool is_separator( typename Path::string_type::value_type c )
      {
        return c == slash<Path>::value



          ;
      }



      template<class String, class Traits>
      typename String::size_type filename_pos(
        const String & str,
        typename String::size_type end_pos )

      {
        typedef typename
          boost::filesystem::basic_path<String, Traits> path_type;


        if ( end_pos == 2
          && str[0] == slash<path_type>::value
          && str[1] == slash<path_type>::value ) return 0;


        if ( end_pos && str[end_pos-1] == slash<path_type>::value )
          return end_pos-1;


        typename String::size_type pos(
          str.find_last_of( slash<path_type>::value, end_pos-1 ) );







        return ( pos == String::npos
          || (pos == 1 && str[0] == slash<path_type>::value) )
            ? 0
            : pos + 1;
      }





      template<class String, class Traits>
        void first_element(
          const String & src,
          typename String::size_type & element_pos,
          typename String::size_type & element_size,

          typename String::size_type size = String::npos



          )
      {
        if ( size == String::npos ) size = src.size();
        element_pos = 0;
        element_size = 0;
        if ( src.empty() ) return;

        typedef typename boost::filesystem::basic_path<String, Traits> path_type;

        typename String::size_type cur(0);


        if ( size >= 2 && src[0] == slash<path_type>::value
          && src[1] == slash<path_type>::value
          && (size == 2
            || src[2] != slash<path_type>::value) )
        {
          cur += 2;
          element_size += 2;
        }


        else if ( src[0] == slash<path_type>::value )
        {
          ++element_size;

          while ( cur+1 < size
            && src[cur+1] == slash<path_type>::value )
          {
            ++cur;
            ++element_pos;
          }
          return;
        }





        while ( cur < size



          && src[cur] != slash<path_type>::value )
        {
          ++cur;
          ++element_size;
        }
# 854 "/usr/include/boost/filesystem/path.hpp" 3 4
        return;
      }



      template<class String, class Traits>
      typename String::size_type root_directory_start(
        const String & s,
        typename String::size_type size )

      {
        typedef typename boost::filesystem::basic_path<String, Traits> path_type;
# 875 "/usr/include/boost/filesystem/path.hpp" 3 4
        if ( size == 2
          && s[0] == slash<path_type>::value
          && s[1] == slash<path_type>::value ) return String::npos;


        if ( size > 3
          && s[0] == slash<path_type>::value
          && s[1] == slash<path_type>::value
          && s[2] != slash<path_type>::value )
        {
          typename String::size_type pos(
            s.find( slash<path_type>::value, 2 ) );
          return pos < size ? pos : String::npos;
        }


        if ( size > 0 && s[0] == slash<path_type>::value ) return 0;

        return String::npos;
      }



      template<class String, class Traits>
      bool is_non_root_slash( const String & str,
        typename String::size_type pos )
      {
        typedef typename
          boost::filesystem::basic_path<String, Traits>
            path_type;

        ((!str.empty() && str[pos] == slash<path_type>::value && "precondition violation") ? static_cast<void> (0) : __assert_fail ("!str.empty() && str[pos] == slash<path_type>::value && \"precondition violation\"", "/usr/include/boost/filesystem/path.hpp", 907, __PRETTY_FUNCTION__));



        while ( pos > 0 && str[pos-1] == slash<path_type>::value )
          --pos;

        return pos != 0
          && (pos <= 2 || str[1] != slash<path_type>::value
            || str.find( slash<path_type>::value, 2 ) != pos)



            ;
      }
    }



    template<class String, class Traits>
    String basic_path<String, Traits>::filename() const
    {
      typename String::size_type end_pos(
        detail::filename_pos<String, Traits>( m_path, m_path.size() ) );
      return (m_path.size()
                && end_pos
                && m_path[end_pos] == slash<path_type>::value
                && detail::is_non_root_slash< String, Traits >(m_path, end_pos))
        ? String( 1, dot<path_type>::value )
        : m_path.substr( end_pos );
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::stem() const
    {
      string_type name = filename();
      typename string_type::size_type n = name.rfind(dot<path_type>::value);
      return name.substr(0, n);
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::extension() const
    {
      string_type name = filename();
      typename string_type::size_type n = name.rfind(dot<path_type>::value);
      if (n != string_type::npos)
        return name.substr(n);
      else
        return string_type();
    }

    template<class String, class Traits>
    basic_path<String, Traits> basic_path<String, Traits>::parent_path() const
    {
      typename String::size_type end_pos(
        detail::filename_pos<String, Traits>( m_path, m_path.size() ) );

      bool filename_was_separator( m_path.size()
        && m_path[end_pos] == slash<path_type>::value );


      typename string_type::size_type root_dir_pos( detail::root_directory_start
        <string_type, traits_type>( m_path, end_pos ) );
      for ( ;
        end_pos > 0
        && (end_pos-1) != root_dir_pos
        && m_path[end_pos-1] == slash<path_type>::value
        ;
        --end_pos ) {}

     return (end_pos == 1 && root_dir_pos == 0 && filename_was_separator)
       ? path_type()
       : path_type( m_path.substr( 0, end_pos ) );
    }

    template<class String, class Traits>
    basic_path<String, Traits> basic_path<String, Traits>::relative_path() const
    {
      iterator itr( begin() );
      for ( ; itr.m_pos != m_path.size()
          && (itr.m_name[0] == slash<path_type>::value




             ); ++itr ) {}

      return basic_path<String, Traits>( m_path.substr( itr.m_pos ) );
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::root_name() const
    {
      iterator itr( begin() );

      return ( itr.m_pos != m_path.size()
        && (
            ( itr.m_name.size() > 1
              && itr.m_name[0] == slash<path_type>::value
              && itr.m_name[1] == slash<path_type>::value
            )




           ) )
        ? *itr
        : String();
    }

    template<class String, class Traits>
    String basic_path<String, Traits>::root_directory() const
    {
      typename string_type::size_type start(
        detail::root_directory_start<String, Traits>( m_path, m_path.size() ) );

      return start == string_type::npos
        ? string_type()
        : m_path.substr( start, 1 );
    }

    template<class String, class Traits>
    basic_path<String, Traits> basic_path<String, Traits>::root_path() const
    {

      return basic_path<String, Traits>( root_name() ) /= root_directory();
    }



    template<class String, class Traits>
    inline bool basic_path<String, Traits>::is_complete() const
    {



      return has_root_directory();

    }

    template<class String, class Traits>
    inline bool basic_path<String, Traits>::has_root_path() const
    {
      return !root_path().empty();
    }

    template<class String, class Traits>
    inline bool basic_path<String, Traits>::has_root_name() const
    {
      return !root_name().empty();
    }

    template<class String, class Traits>
    inline bool basic_path<String, Traits>::has_root_directory() const
    {
      return !root_directory().empty();
    }



    template<class String, class Traits>
    void basic_path<String, Traits>::m_append_separator_if_needed()

    {
      if (



        *(m_path.end()-1) != slash<path_type>::value )
      {
        m_path += slash<path_type>::value;
      }
    }

    template<class String, class Traits>
    void basic_path<String, Traits>::m_append( value_type value )
    {
# 1093 "/usr/include/boost/filesystem/path.hpp" 3 4
      m_path += value;

    }



    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::operator /=
      ( const value_type * next_p )
    {

      if ( *next_p == slash<path_type>::value
        && *(next_p+1) == slash<path_type>::value
        && *(next_p+2) == colon<path_type>::value ) next_p += 3;


      if ( !empty() && *next_p != 0
        && !detail::is_separator<path_type>( *next_p ) )
      { m_append_separator_if_needed(); }

      for ( ; *next_p != 0; ++next_p ) m_append( *next_p );
      return *this;
    }


    template<class String, class Traits> template <class InputIterator>
      basic_path<String, Traits> & basic_path<String, Traits>::append(
        InputIterator first, InputIterator last )
    {

      if ( !empty() && first != last
        && !detail::is_separator<path_type>( *first ) )
      { m_append_separator_if_needed(); }




      bool was_escape_sequence(true);
      std::size_t append_count(0);
      typename String::size_type initial_pos( m_path.size() );

      for ( ; first != last && *first; ++first )
      {
        if ( append_count == 0 && *first != slash<path_type>::value )
          was_escape_sequence = false;
        if ( append_count == 1 && *first != slash<path_type>::value )
          was_escape_sequence = false;
        if ( append_count == 2 && *first != colon<path_type>::value )
          was_escape_sequence = false;
        m_append( *first );
        ++append_count;
      }


      if ( was_escape_sequence && append_count >= 3 )
        m_path.erase( initial_pos, 3 );

      return *this;
    }






    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::canonize()
    {
      static const typename string_type::value_type dot_str[]
        = { dot<path_type>::value, 0 };

      if ( m_path.empty() ) return *this;

      path_type temp;

      for ( iterator itr( begin() ); itr != end(); ++itr )
      {
        temp /= *itr;
      };

      if ( temp.empty() ) temp /= dot_str;
      m_path = temp.m_path;
      return *this;
    }



    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::normalize()
    {
      static const typename string_type::value_type dot_str[]
        = { dot<path_type>::value, 0 };

      if ( m_path.empty() ) return *this;

      path_type temp;
      iterator start( begin() );
      iterator last( end() );
      iterator stop( last-- );
      for ( iterator itr( start ); itr != stop; ++itr )
      {

        if ( itr->size() == 1
          && (*itr)[0] == dot<path_type>::value
          && itr != start
          && itr != last ) continue;


        if ( !temp.empty()
          && itr->size() == 2
          && (*itr)[0] == dot<path_type>::value
          && (*itr)[1] == dot<path_type>::value )
        {
          string_type lf( temp.filename() );
          if ( lf.size() > 0
            && (lf.size() != 1
              || (lf[0] != dot<path_type>::value
                && lf[0] != slash<path_type>::value))
            && (lf.size() != 2
              || (lf[0] != dot<path_type>::value
                && lf[1] != dot<path_type>::value



                 )
               )
            )
          {
            temp.remove_filename();

            if ( temp.m_path.size() > 0
              && temp.m_path[temp.m_path.size()-1]
                == slash<path_type>::value )
            {
              typename string_type::size_type rds(
                detail::root_directory_start<String,Traits>( temp.m_path,
                  temp.m_path.size() ) );
              if ( rds == string_type::npos
                || rds != temp.m_path.size()-1 )
                { temp.m_path.erase( temp.m_path.size()-1 ); }
            }

            iterator next( itr );
            if ( temp.empty() && ++next != stop
              && next == last && *last == dot_str ) temp /= dot_str;
            continue;
          }
        }

        temp /= *itr;
      };

      if ( temp.empty() ) temp /= dot_str;
      m_path = temp.m_path;
      return *this;
    }





    template<class String, class Traits>
    basic_path<String, Traits> & basic_path<String, Traits>::remove_filename()
    {
      m_path.erase(
        detail::filename_pos<String, Traits>( m_path, m_path.size() ) );
      return *this;
    }

    template<class String, class Traits>
    basic_path<String, Traits> &
    basic_path<String, Traits>::replace_extension( const string_type & new_ext )
    {

      string_type old_ext = extension();
      if ( !old_ext.empty() )
        m_path.erase( m_path.size() - old_ext.size() );

      if ( !new_ext.empty() && new_ext[0] != dot<path_type>::value )
        m_path += dot<path_type>::value;

      m_path += new_ext;

      return *this;
    }




    template<class String, class Traits>
    const String
    basic_path<String, Traits>::file_string() const
    {
# 1334 "/usr/include/boost/filesystem/path.hpp" 3 4
      return m_path;

    }



    template<class String, class Traits>
    typename basic_path<String, Traits>::iterator basic_path<String, Traits>::begin() const
    {
      iterator itr;
      itr.m_path_ptr = this;
      typename string_type::size_type element_size;
      detail::first_element<String, Traits>( m_path, itr.m_pos, element_size );
      itr.m_name = m_path.substr( itr.m_pos, element_size );
      return itr;
    }

    template<class String, class Traits>
    typename basic_path<String, Traits>::iterator basic_path<String, Traits>::end() const
      {
        iterator itr;
        itr.m_path_ptr = this;
        itr.m_pos = m_path.size();
        return itr;
      }

    namespace detail
    {


      template<class Path>
      void iterator_helper<Path>::do_increment( iterator & itr )
      {
        typedef typename Path::string_type string_type;
        typedef typename Path::traits_type traits_type;

        ((itr.m_pos < itr.m_path_ptr->m_path.size() && "basic_path::iterator increment past end()") ? static_cast<void> (0) : __assert_fail ("itr.m_pos < itr.m_path_ptr->m_path.size() && \"basic_path::iterator increment past end()\"", "/usr/include/boost/filesystem/path.hpp", 1370, __PRETTY_FUNCTION__));

        bool was_net( itr.m_name.size() > 2
          && itr.m_name[0] == slash<Path>::value
          && itr.m_name[1] == slash<Path>::value
          && itr.m_name[2] != slash<Path>::value );


        itr.m_pos += itr.m_name.size();


        if ( itr.m_pos == itr.m_path_ptr->m_path.size() )
        {
          itr.m_name.erase( itr.m_name.begin(), itr.m_name.end() );
          return;
        }


        if ( itr.m_path_ptr->m_path[itr.m_pos] == slash<Path>::value )
        {

          if ( was_net




             )
          {
            itr.m_name = slash<Path>::value;
            return;
          }


          while ( itr.m_pos != itr.m_path_ptr->m_path.size()
            && itr.m_path_ptr->m_path[itr.m_pos] == slash<Path>::value )
            { ++itr.m_pos; }


          if ( itr.m_pos == itr.m_path_ptr->m_path.size()
            && detail::is_non_root_slash< string_type, traits_type >(
                itr.m_path_ptr->m_path, itr.m_pos-1 ) )
          {
            --itr.m_pos;
            itr.m_name = dot<Path>::value;
            return;
          }
        }


        typename string_type::size_type end_pos(
          itr.m_path_ptr->m_path.find( slash<Path>::value, itr.m_pos ) );
        itr.m_name = itr.m_path_ptr->m_path.substr( itr.m_pos, end_pos - itr.m_pos );
      }



      template<class Path>
      void iterator_helper<Path>::do_decrement( iterator & itr )
      {
        ((itr.m_pos && "basic_path::iterator decrement past begin()") ? static_cast<void> (0) : __assert_fail ("itr.m_pos && \"basic_path::iterator decrement past begin()\"", "/usr/include/boost/filesystem/path.hpp", 1429, __PRETTY_FUNCTION__));

        typedef typename Path::string_type string_type;
        typedef typename Path::traits_type traits_type;

        typename string_type::size_type end_pos( itr.m_pos );

        typename string_type::size_type root_dir_pos(
          detail::root_directory_start<string_type, traits_type>(
            itr.m_path_ptr->m_path, end_pos ) );


        if ( itr.m_pos == itr.m_path_ptr->m_path.size()
          && itr.m_path_ptr->m_path.size() > 1
          && itr.m_path_ptr->m_path[itr.m_pos-1] == slash<Path>::value
          && detail::is_non_root_slash< string_type, traits_type >(
               itr.m_path_ptr->m_path, itr.m_pos-1 )
           )
        {
          --itr.m_pos;
            itr.m_name = dot<Path>::value;
            return;
        }


        for (
          ;
          end_pos > 0
          && (end_pos-1) != root_dir_pos
          && itr.m_path_ptr->m_path[end_pos-1] == slash<Path>::value
          ;
          --end_pos ) {}

        itr.m_pos = detail::filename_pos<string_type, traits_type>
            ( itr.m_path_ptr->m_path, end_pos );
        itr.m_name = itr.m_path_ptr->m_path.substr( itr.m_pos, end_pos - itr.m_pos );
      }
    }



    template<class Path>
    basic_filesystem_error<Path>::basic_filesystem_error(
      const std::string & what_arg, system::error_code ec )
      : system::system_error(ec, what_arg)
    {
      try
      {
        m_imp_ptr.reset( new m_imp );
      }
      catch (...) { m_imp_ptr.reset(); }
    }

    template<class Path>
    basic_filesystem_error<Path>::basic_filesystem_error(
      const std::string & what_arg, const path_type & path1_arg,
      system::error_code ec )
      : system::system_error(ec, what_arg)
    {
      try
      {
        m_imp_ptr.reset( new m_imp );
        m_imp_ptr->m_path1 = path1_arg;
      }
      catch (...) { m_imp_ptr.reset(); }
    }

    template<class Path>
    basic_filesystem_error<Path>::basic_filesystem_error(
      const std::string & what_arg, const path_type & path1_arg,
      const path_type & path2_arg, system::error_code ec )
      : system::system_error(ec, what_arg)
    {
      try
      {
        m_imp_ptr.reset( new m_imp );
        m_imp_ptr->m_path1 = path1_arg;
        m_imp_ptr->m_path2 = path2_arg;
      }
      catch (...) { m_imp_ptr.reset(); }
    }

  }
}

# 1 "/usr/include/boost/config/abi_suffix.hpp" 1 3 4
# 1515 "/usr/include/boost/filesystem/path.hpp" 2 3 4
# 14 "../src/worker.cpp" 2

using namespace cocaine;
using namespace cocaine::engine;
using namespace cocaine::io;
using namespace cocaine::logging;

namespace fs = boost::filesystem;

namespace {
  struct upstream_t:
    public api::stream_t
  {
    upstream_t(const unique_id_t& id,
               worker_t * const worker):
      m_id(id),
      m_worker(worker),
      m_state(state_t::open)
      { }

    virtual
    ~upstream_t() {
      if(m_state != state_t::closed) {
        close();
      }
    }

    virtual
    void
    push(const char * chunk,
         size_t size) {
      switch(m_state) {
        case state_t::open:
          send<rpc::chunk>(std::string(chunk, size));

          break;

        case state_t::closed:
          throw cocaine::error_t("the stream has been closed");
      }
    }

    virtual
    void
    error(error_code code,
          const std::string& message) {
      switch(m_state) {
        case state_t::open:
          m_state = state_t::closed;

          send<rpc::error>(static_cast<int>(code), message);
          send<rpc::choke>();

          break;

        case state_t::closed:
          throw cocaine::error_t("the stream has been closed");
      }
    }

    virtual
    void
    close() {
      switch(m_state) {
        case state_t::open:
          m_state = state_t::closed;

          send<rpc::choke>();

          break;

        case state_t::closed:
          throw cocaine::error_t("the stream has been closed");
      }
    }

  private:
    template<class Event, typename... Args>
    void
    send(Args&&... args) {
      m_worker->send<Event>(m_id, std::forward<Args>(args)...);
    }

  private:
    const unique_id_t m_id;
    worker_t * const m_worker;

    enum class state_t: int {
      open,
        closed
        };

    state_t m_state;
  };
}

worker_t::worker_t(context_t& context,
                   worker_config_t config):
  m_context(context),
  m_log(new log_t(context, cocaine::format("app/%s", config.app))),
  m_id(config.uuid),
  m_channel(context, 5, m_id)
{
  std::string endpoint = cocaine::format(
    "ipc://%1%/engines/%2%",
    m_context.config.path.runtime,
    config.app);

  m_channel.connect(endpoint);




  m_watcher.set<worker_t, &worker_t::on_event>(this);
  m_watcher.start(m_channel.fd(), ev::READ);
  m_checker.set<worker_t, &worker_t::on_check>(this);
  m_checker.start();

  m_heartbeat_timer.set<worker_t, &worker_t::on_heartbeat>(this);
  m_heartbeat_timer.start(0.0f, 5.0f);



  try {
    m_manifest.reset(new manifest_t(m_context, config.app));
    m_profile.reset(new profile_t(m_context, config.profile));

    fs::path path = fs::path(m_context.config.path.spool) / config.app;

    m_sandbox = m_context.get<api::sandbox_t>(
      m_manifest->sandbox.type,
      m_context,
      m_manifest->name,
      m_manifest->sandbox.args,
      path.string()
      );
  } catch(const std::exception& e) {
    terminate(rpc::suicide::abnormal, e.what());
    throw;
  } catch(...) {
    terminate(rpc::suicide::abnormal, "unexpected exception");
    throw;
  }

  m_disown_timer.set<worker_t, &worker_t::on_disown>(this);
  m_disown_timer.start(m_profile->heartbeat_timeout);
}

worker_t::~worker_t() {

}

void
worker_t::run() {
  m_loop.loop();
}

void
worker_t::on_event(ev::io&, int) {
  m_checker.stop();

  if(m_channel.pending()) {
    m_checker.start();
    process();
  }
}

void
worker_t::on_check(ev::prepare&, int) {
  m_loop.feed_fd_event(m_channel.fd(), ev::READ);
}

void
worker_t::on_heartbeat(ev::timer&, int) {
  scoped_option<
    options::send_timeout
    > option(m_channel, 0);

  send<rpc::heartbeat>();
}

void
worker_t::on_disown(ev::timer&, int) {
  if(m_log->verbosity() >= logging::error) m_log->emit(logging::error, "worker %s has lost the controlling engine", m_id);;





  m_loop.unloop(ev::ALL);
}

void
worker_t::process() {
  int counter = defaults::io_bulk_size;

  do {

    ((!m_channel.more()) ? static_cast<void> (0) : __assert_fail ("!m_channel.more()", "../src/worker.cpp", 211, __PRETTY_FUNCTION__));

    int message_id = -1;

      {
        scoped_option<
          options::receive_timeout
          > option(m_channel, 0);

        if(!m_channel.recv(message_id)) {
          return;
        }
      }

      if(m_log->verbosity() >= logging::debug) m_log->emit(logging::debug, "worker %s received type %d message", m_id, message_id);;





      switch(message_id) {
        case event_traits<rpc::heartbeat>::id:
          m_disown_timer.stop();
          m_disown_timer.start(m_profile->heartbeat_timeout);

          break;

        case event_traits<rpc::invoke>::id: {
          unique_id_t session_id(uninitialized);
          std::string event;

          m_channel.recv<rpc::invoke>(session_id, event);

          boost::shared_ptr<api::stream_t> upstream(
            boost::make_shared<upstream_t>(session_id, this)
            );

          try {
            io_pair_t io = {
              upstream,
              m_sandbox->invoke(event, upstream)
            };

            m_streams.emplace(session_id, io);
          } catch(const std::exception& e) {
            upstream->error(invocation_error, e.what());
          } catch(...) {
            upstream->error(invocation_error, "unexpected exception");
          }

          break;
        }

        case event_traits<rpc::chunk>::id: {
          unique_id_t session_id(uninitialized);
          std::string message;

          m_channel.recv<rpc::chunk>(session_id, message);

          stream_map_t::iterator it(m_streams.find(session_id));



          if(it != m_streams.end()) {
            try {
              it->second.downstream->push(message.data(), message.size());
            } catch(const std::exception& e) {
              it->second.upstream->error(invocation_error, e.what());
              m_streams.erase(it);
            } catch(...) {
              it->second.upstream->error(invocation_error, "unexpected exception");
              m_streams.erase(it);
            }
          }

          break;
        }

        case event_traits<rpc::choke>::id: {
          unique_id_t session_id(uninitialized);

          m_channel.recv<rpc::choke>(session_id);

          stream_map_t::iterator it = m_streams.find(session_id);



          if(it != m_streams.end()) {
            try {
              it->second.downstream->close();
            } catch(const std::exception& e) {
              it->second.upstream->error(invocation_error, e.what());
            } catch(...) {
              it->second.upstream->error(invocation_error, "unexpected exception");
            }

            m_streams.erase(it);
          }

          break;
        }

        case event_traits<rpc::terminate>::id:
          terminate(rpc::suicide::normal, "per request");
          break;

        default:
          if(m_log->verbosity() >= logging::warning) m_log->emit(logging::warning, "worker %s dropping unknown type %d message", m_id, message_id);;






          m_channel.drop();
      }
  } while(--counter);


  m_loop.feed_fd_event(m_channel.fd(), ev::READ);

}

void
worker_t::terminate(rpc::suicide::reasons reason,
                    const std::string& message)
{
  send<rpc::suicide>(static_cast<int>(reason), message);
  m_loop.unloop(ev::ALL);
}
